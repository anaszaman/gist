Directory structure:
└── Algebra-Frontend/
    ├── README.md
    ├── codegen.ts
    ├── commitlint.config.cjs
    ├── components.json
    ├── index.html
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── tsconfig.node.json
    ├── vite.config.ts
    ├── wagmi.config.ts
    ├── .eslintrc.cjs
    ├── .npmrc.pages
    ├── packages/
    │   └── glyph-exchange-integral-sdk-1.1.0.tgz
    ├── public/
    │   ├── advertising/
    │   ├── fonts/
    │   │   ├── FraktionMono-Bold.otf
    │   │   ├── FraktionMono-BoldItalic.otf
    │   │   ├── FraktionMono-Regular.otf
    │   │   ├── FraktionMono-RegularItalic.otf
    │   │   └── Geneva.ttf
    │   ├── plugins/
    │   └── tokens/
    ├── scripts/
    │   └── deploy.sh
    ├── src/
    │   ├── App.tsx
    │   ├── app.d.ts
    │   ├── generated.ts
    │   ├── main.tsx
    │   ├── twin.d.ts
    │   ├── vite-env.d.ts
    │   ├── abis/
    │   │   ├── IceCreamSwapRouter.ts
    │   │   ├── algebraFactory.ts
    │   │   ├── algebraPool.ts
    │   │   ├── algebraPoolDeployer.ts
    │   │   ├── algebraPositionManager.ts
    │   │   ├── algebraQuoter.ts
    │   │   ├── algebraQuoterV2.ts
    │   │   ├── algebraRouter.ts
    │   │   ├── gammaHypervisor.ts
    │   │   ├── gammaUniProxy.ts
    │   │   ├── index.ts
    │   │   ├── farming/
    │   │   │   ├── algebraEternalFarming.ts
    │   │   │   ├── farmingCenter.ts
    │   │   │   └── index.ts
    │   │   ├── plugins/
    │   │   │   ├── algebraBasePlugin.ts
    │   │   │   └── index.ts
    │   │   └── tokens/
    │   │       ├── index.ts
    │   │       └── wNative.ts
    │   ├── components/
    │   │   ├── common/
    │   │   │   ├── Banner.tsx
    │   │   │   ├── Bulletin.tsx
    │   │   │   ├── Checkbox.tsx
    │   │   │   ├── Collapsible.tsx
    │   │   │   ├── FloatingButton.tsx
    │   │   │   ├── Image.tsx
    │   │   │   ├── LineBoxBase.tsx
    │   │   │   ├── PageSelector.tsx
    │   │   │   ├── Popver.tsx
    │   │   │   ├── SearchBox.tsx
    │   │   │   ├── SeparateBar.tsx
    │   │   │   ├── Svg.tsx
    │   │   │   ├── WarningBox.tsx
    │   │   │   ├── Card/
    │   │   │   │   └── index.tsx
    │   │   │   ├── CardInfo/
    │   │   │   │   └── index.tsx
    │   │   │   ├── CurrencyLogo/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Footer/
    │   │   │   │   ├── MenuModal.tsx
    │   │   │   │   ├── Socials.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── Header/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Info/
    │   │   │   │   ├── InfoBase.tsx
    │   │   │   │   └── InfoItem.tsx
    │   │   │   ├── Layout/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Loader/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Navigation/
    │   │   │   │   ├── External.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── PageContainer/
    │   │   │   │   └── index.tsx
    │   │   │   ├── PageTitle/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Panel/
    │   │   │   │   ├── PanelBase.tsx
    │   │   │   │   ├── PanelContainer.tsx
    │   │   │   │   ├── PanelFooter.tsx
    │   │   │   │   └── PanelTitle.tsx
    │   │   │   ├── PluginIcons/
    │   │   │   │   └── index.tsx
    │   │   │   ├── PoweredBy/
    │   │   │   │   ├── Aggregator.tsx
    │   │   │   │   └── Algebra.tsx
    │   │   │   ├── Settings/
    │   │   │   │   └── index.tsx
    │   │   │   ├── Table/
    │   │   │   │   ├── common.tsx
    │   │   │   │   ├── loadingState.tsx
    │   │   │   │   ├── myPositionsColumns.tsx
    │   │   │   │   ├── myPositionsTable.tsx
    │   │   │   │   ├── poolsColumns.tsx
    │   │   │   │   └── poolsTable.tsx
    │   │   │   ├── TokenSelector/
    │   │   │   │   └── index.tsx
    │   │   │   └── TransactionCard/
    │   │   │       └── index.tsx
    │   │   ├── create-pool/
    │   │   │   ├── CreatePoolForm/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SelectPair/
    │   │   │   │   └── index.tsx
    │   │   │   └── Summary/
    │   │   │       └── index.tsx
    │   │   ├── create-position/
    │   │   │   ├── AddLiquidityButton/
    │   │   │   │   └── index.tsx
    │   │   │   ├── AmountsSection/
    │   │   │   │   └── index.tsx
    │   │   │   ├── EnterAmounts/
    │   │   │   │   └── index.tsx
    │   │   │   ├── EnterAmountsCard/
    │   │   │   │   └── index.tsx
    │   │   │   ├── LiquidityChart/
    │   │   │   │   ├── chart.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── PresetTabs/
    │   │   │   │   └── index.tsx
    │   │   │   ├── RangeSelector/
    │   │   │   │   └── index.tsx
    │   │   │   ├── RangeSelectorPart/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SelectRange/
    │   │   │   │   └── index.tsx
    │   │   │   └── TokenRatio/
    │   │   │       └── index.tsx
    │   │   ├── farming/
    │   │   │   ├── ActiveFarming/
    │   │   │   │   └── index.tsx
    │   │   │   ├── FarmingPositionCard/
    │   │   │   │   └── index.tsx
    │   │   │   └── FarmingPositionImg/
    │   │   │       └── index.tsx
    │   │   ├── modals/
    │   │   │   ├── IncreaseLiquidityModal/
    │   │   │   │   └── index.tsx
    │   │   │   ├── RemoveLiquidityModal/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SelectPositionFarmModal/
    │   │   │   │   └── index.tsx
    │   │   │   └── TokenSelectorModal/
    │   │   │       └── index.tsx
    │   │   ├── pool/
    │   │   │   ├── FilterPopover/
    │   │   │   │   └── index.tsx
    │   │   │   ├── MyPositions/
    │   │   │   │   └── index.tsx
    │   │   │   ├── MyPositionsToolbar/
    │   │   │   │   └── index.tsx
    │   │   │   └── PoolHeader/
    │   │   │       └── index.tsx
    │   │   ├── pools/
    │   │   │   └── PoolsList/
    │   │   │       ├── blacklistPools.ts
    │   │   │       ├── index.tsx
    │   │   │       └── pluginPools.ts
    │   │   ├── position/
    │   │   │   ├── ActiveFarmingCard/
    │   │   │   │   └── index.tsx
    │   │   │   ├── ClosedFarmingCard/
    │   │   │   │   └── index.tsx
    │   │   │   ├── CollectFees/
    │   │   │   │   └── index.tsx
    │   │   │   ├── IncreaseLiquidityButton/
    │   │   │   │   └── index.tsx
    │   │   │   ├── PositionCard/
    │   │   │   │   ├── GammaManager.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── PositionNFT/
    │   │   │   │   └── index.tsx
    │   │   │   └── PositionRangeChart/
    │   │   │       └── index.tsx
    │   │   ├── swap/
    │   │   │   ├── SwitchBar.tsx
    │   │   │   ├── AggregatorPanel/
    │   │   │   │   ├── SwapButton.tsx
    │   │   │   │   ├── SwapPair.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── IntegralPools/
    │   │   │   │   └── index.tsx
    │   │   │   ├── MarketDepthChart/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SwapChart/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SwapPair/
    │   │   │   │   └── index.tsx
    │   │   │   ├── SwapParams/
    │   │   │   │   └── index.tsx
    │   │   │   ├── TokenCard/
    │   │   │   │   └── index.tsx
    │   │   │   └── V4AMMPanel/
    │   │   │       ├── SwapButton.tsx
    │   │   │       └── index.tsx
    │   │   └── ui/
    │   │       ├── avatar.tsx
    │   │       ├── button.tsx
    │   │       ├── card.tsx
    │   │       ├── credenza.tsx
    │   │       ├── dialog.tsx
    │   │       ├── drawer.tsx
    │   │       ├── hover-card.tsx
    │   │       ├── input.tsx
    │   │       ├── pagination.tsx
    │   │       ├── popover.tsx
    │   │       ├── separator.tsx
    │   │       ├── skeleton.tsx
    │   │       ├── slider.tsx
    │   │       ├── switch.tsx
    │   │       ├── table.tsx
    │   │       ├── tabs.tsx
    │   │       ├── toast.tsx
    │   │       ├── toaster.tsx
    │   │       └── use-toast.ts
    │   ├── constants/
    │   │   ├── addresses.ts
    │   │   ├── api.ts
    │   │   ├── default-chain-id.ts
    │   │   ├── max-uint128.ts
    │   │   ├── routing.ts
    │   │   └── tokens.ts
    │   ├── graphql/
    │   │   ├── clients/
    │   │   │   └── index.ts
    │   │   ├── generated/
    │   │   │   └── graphql.tsx
    │   │   ├── queries/
    │   │   │   ├── blocks.ts
    │   │   │   ├── farmings.ts
    │   │   │   ├── global.ts
    │   │   │   ├── pools.ts
    │   │   │   └── tokens.ts
    │   │   ├── schemas/
    │   │   │   ├── algebra.graphql
    │   │   │   ├── blocklytics.graphql
    │   │   │   └── farming.graphql
    │   │   └── utils/
    │   │       ├── getBlocksFromTimestamps.ts
    │   │       └── splitQuery.ts
    │   ├── hooks/
    │   │   ├── common/
    │   │   │   ├── useAlgebraToken.ts
    │   │   │   ├── useApprove.ts
    │   │   │   ├── useCurrency.ts
    │   │   │   ├── useDebounce.ts
    │   │   │   ├── useFuse.ts
    │   │   │   ├── useGamma.ts
    │   │   │   ├── useMediaQuery.ts
    │   │   │   ├── useNeedAllowance.ts
    │   │   │   ├── useTransactionAwait.tsx
    │   │   │   ├── useUSDCValue.ts
    │   │   │   └── useWeb3.ts
    │   │   ├── farming/
    │   │   │   ├── useActiveFarming.ts
    │   │   │   ├── useClosedFarmings.ts
    │   │   │   ├── useFarmApprove.ts
    │   │   │   ├── useFarmCheckApprove.ts
    │   │   │   ├── useFarmHarvest.ts
    │   │   │   ├── useFarmStake.ts
    │   │   │   ├── useFarmingAPR.ts
    │   │   │   └── useRewardEarnedUSD.ts
    │   │   ├── graphql/
    │   │   │   └── useClients.ts
    │   │   ├── pools/
    │   │   │   ├── usePool.ts
    │   │   │   ├── usePoolPlugins.ts
    │   │   │   ├── usePoolTickData.ts
    │   │   │   └── usePoolsList.ts
    │   │   ├── positions/
    │   │   │   ├── usePositionAPR.ts
    │   │   │   ├── usePositionFees.ts
    │   │   │   └── usePositions.ts
    │   │   ├── swap/
    │   │   │   ├── useAggregatorData.ts
    │   │   │   ├── useAllCurrencyCombinations.ts
    │   │   │   ├── useAllRoutes.ts
    │   │   │   ├── useBestTrade.ts
    │   │   │   ├── useQuotesResults.ts
    │   │   │   ├── useSwapCallArguments.ts
    │   │   │   ├── useSwapCallback.ts
    │   │   │   ├── useSwapChart.ts
    │   │   │   ├── useSwapPools.ts
    │   │   │   ├── useSwapSlippageTolerance.ts
    │   │   │   └── useWrapCallback.ts
    │   │   └── tokens/
    │   │       └── useAllTokens.ts
    │   ├── lib/
    │   │   └── utils.ts
    │   ├── pages/
    │   │   ├── index.ts
    │   │   ├── CreatePool/
    │   │   │   └── index.tsx
    │   │   ├── NewPosition/
    │   │   │   └── index.tsx
    │   │   ├── Page404/
    │   │   │   └── index.tsx
    │   │   ├── Pool/
    │   │   │   └── index.tsx
    │   │   ├── Pools/
    │   │   │   └── index.tsx
    │   │   └── Swap/
    │   │       ├── SwapSelector.tsx
    │   │       ├── index.tsx
    │   │       └── types.ts
    │   ├── scripts/
    │   │   └── loadSchema.js
    │   ├── state/
    │   │   ├── burnStore.ts
    │   │   ├── mintStore.ts
    │   │   ├── pendingTransactionsStore.ts
    │   │   ├── poolsStore.ts
    │   │   ├── positionFilterStore.ts
    │   │   ├── swapStore.ts
    │   │   ├── tokensStore.ts
    │   │   └── userStore.ts
    │   ├── styles/
    │   │   ├── fonts.css
    │   │   ├── index.scss
    │   │   └── index.tsx
    │   ├── types/
    │   │   ├── approve-state.ts
    │   │   ├── common.ts
    │   │   ├── farming-info.ts
    │   │   ├── formatted-position.ts
    │   │   ├── gamma-state.ts
    │   │   ├── manage-liquidity.ts
    │   │   ├── page-selector.ts
    │   │   ├── pool-table-state.ts
    │   │   ├── position-filter-status.ts
    │   │   ├── position-state.ts
    │   │   ├── presets.ts
    │   │   ├── swap-chart.ts
    │   │   ├── swap-field.ts
    │   │   ├── swap-quote.ts
    │   │   ├── swap-state.ts
    │   │   └── trade-state.ts
    │   └── utils/
    │       ├── index.ts
    │       ├── common/
    │       │   ├── formatAmount.ts
    │       │   ├── formatBalance.ts
    │       │   ├── formatCurrency.ts
    │       │   ├── formatPercent.ts
    │       │   ├── formatPlural.ts
    │       │   ├── formatUSD.ts
    │       │   └── truncateHash.ts
    │       ├── farming/
    │       │   ├── getFarmingRewards.ts
    │       │   ├── getRewardsCalldata.ts
    │       │   └── isSameRewards.ts
    │       ├── pool/
    │       │   └── getPoolAPR.ts
    │       ├── positions/
    │       │   ├── getPositionAPR.ts
    │       │   └── getPositionFees.ts
    │       └── swap/
    │           ├── computePriceImpact.ts
    │           └── prices.ts
    └── .husky/
        ├── commit-msg
        ├── pre-commit
        └── _/
            ├── applypatch-msg
            ├── commit-msg
            ├── h
            ├── husky.sh
            ├── post-applypatch
            ├── post-checkout
            ├── post-commit
            ├── post-merge
            ├── post-rewrite
            ├── pre-applypatch
            ├── pre-auto-gc
            ├── pre-commit
            ├── pre-merge-commit
            ├── pre-push
            ├── pre-rebase
            ├── prepare-commit-msg
            └── .gitignore

================================================
File: README.md
================================================
# Algebra Integral UI

[Algebra Integral on Holesky](https://integral.algebra.finance)

To launch the application locally:

```yarn```

```yarn codegen && yarn wagmi-generate```

```yarn dev```

# Environment variable
```.env.production``` or ```.env.development```
```
VITE_ENVIRONMENT=PROD
VITE_SITEMAP_URL=""
VITE_WALLETCONNECT_PROJECT_ID=""
VITE_INFO_GRAPH_PROD=""
VITE_BLOCKS_GRAPH_PROD=""
VITE_FARMING_GRAPH_PROD=""
VITE_BACKEND_URL_PROD=""
VITE_RPC_URL_PROD=""
```



================================================
File: codegen.ts
================================================
import type { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
    overwrite: true,
    schema: ["src/graphql/schemas/*.graphql"],
    documents: "src/graphql/queries/!(*.d).{ts,tsx}",
    generates: {
        // [`src/graphql/schemas/[FILE NAME].graphql`]: {
        //     schema: "[GRAPH URL]",
        //     plugins: ["schema-ast"],
        // },

        "src/graphql/generated/graphql.tsx": {
            plugins: ["typescript", "typescript-operations", "typescript-react-apollo"],
            config: {
                withHooks: true,
                withResultType: true,
            },
        },
    },
};

export default config;



================================================
File: commitlint.config.cjs
================================================
module.exports = { extends: ["@commitlint/config-conventional"] };


================================================
File: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}


================================================
File: index.html
================================================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Glyph Exchange V4 | Bitcoin-powered DEX on Core DAO</title>
  <meta name="description"
    content="Glyph Exchange is the Flagship DEX on Bitcoin-powered Core DAO network. The protocol drives EVM liquidity to the Bitcoin ecosystem. Trade BRC-20s with ERC-20s and any inscription assets with a comprehensive suite of DeFi features." />
  <meta name="keywords"
    content="glyph, glyph exchange, satoshi plus, Inscription, core dao, BRC20, BRC-20, BRC20s, BRC-20s, ordinals, ordinal theory, bitcoin defi, btcfi, bitcoin fi, bitcoin defi project, solidly, 3 3, bitcoin defi ecosystem, coredao swap, amm, automatic market maker, uniswap v2, uniswap v3, camelot, velodrome, bitcoin, btc" />
</head>

<body>
  <div id="root">
    <div class="loader">
      <style>.loader{position:fixed;left:0;top:0;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center;background-color:lightgray;background:url("/bg-fragment.png"),lightgray 0% 0% / 69.9999988079071px 69.9999988079071px repeat;}</style>
      <img width="30" height="31" src="/loading.gif" alt="">
    </div>
  </div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>


================================================
File: package.json
================================================
{
    "name": "algebra-integral",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "prepare": "husky",
        "dev": "vite",
        "wagmi-generate": "wagmi generate",
        "build": "yarn codegen && yarn wagmi-generate && vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview",
        "codegen": "graphql-codegen --config codegen.ts "
    },
    "dependencies": {
        "@apollo/client": "^3.11.8",
        "@glyph-exchange/integral-sdk": "file:packages/glyph-exchange-integral-sdk-1.1.0.tgz",
        "@radix-ui/react-avatar": "^1.1.1",
        "@radix-ui/react-dialog": "^1.1.2",
        "@radix-ui/react-hover-card": "^1.1.2",
        "@radix-ui/react-popover": "^1.1.2",
        "@radix-ui/react-separator": "^1.1.0",
        "@radix-ui/react-slider": "^1.2.1",
        "@radix-ui/react-slot": "^1.1.0",
        "@radix-ui/react-switch": "^1.1.1",
        "@radix-ui/react-tabs": "^1.1.1",
        "@radix-ui/react-toast": "^1.2.2",
        "@tanstack/react-table": "^8.20.5",
        "@web3modal/wagmi": "3.1.0",
        "class-variance-authority": "^0.7.0",
        "clsx": "^2.1.1",
        "dayjs": "^1.11.13",
        "fuse.js": "^7.0.0",
        "graphql": "^16.9.0",
        "jsbi": "^3.2.5",
        "lightweight-charts": "^4.2.1",
        "localforage": "^1.10.0",
        "lodash.keyby": "^4.6.0",
        "lodash.merge": "^4.6.2",
        "lucide-react": "^0.279.0",
        "match-sorter": "^6.4.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-headless-pagination": "^1.1.6",
        "react-lazy-load-image-component": "^1.6.2",
        "react-router-dom": "^6.27.0",
        "react-use": "^17.5.1",
        "react-window": "^1.8.10",
        "recharts": "^2.13.0",
        "sort-by": "^1.2.0",
        "swr": "^2.2.5",
        "tailwind-merge": "^1.14.0",
        "tailwindcss-animate": "^1.0.7",
        "usehooks-ts": "^2.16.0",
        "vaul": "^0.9.9",
        "viem": "^1.21.4",
        "wagmi": "^1.4.13",
        "zustand": "^4.5.5"
    },
    "devDependencies": {
        "@commitlint/cli": "^19.5.0",
        "@commitlint/config-conventional": "^19.5.0",
        "@graphql-codegen/cli": "5.0.0",
        "@graphql-codegen/client-preset": "4.1.0",
        "@graphql-codegen/typescript": "^4.1.0",
        "@graphql-codegen/typescript-operations": "^4.3.0",
        "@graphql-codegen/typescript-react-apollo": "^4.3.2",
        "@types/lodash.keyby": "^4.6.9",
        "@types/lodash.merge": "^4.6.9",
        "@types/node": "^20.16.13",
        "@types/react": "^18.3.11",
        "@types/react-dom": "^18.3.1",
        "@types/react-lazy-load-image-component": "^1.6.4",
        "@types/react-window": "^1.8.8",
        "@typescript-eslint/eslint-plugin": "^6.21.0",
        "@typescript-eslint/parser": "^6.21.0",
        "@vitejs/plugin-react-swc": "^3.7.1",
        "@wagmi/cli": "^1.5.2",
        "autoprefixer": "^10.4.20",
        "eslint": "^8.57.1",
        "eslint-config-prettier": "^9.1.0",
        "eslint-config-typescript": "^3.0.0",
        "eslint-plugin-react-hooks": "^4.6.2",
        "eslint-plugin-react-refresh": "^0.4.13",
        "husky": "^9.1.6",
        "lint-staged": "^15.2.10",
        "postcss": "^8.4.47",
        "prettier": "^3.3.3",
        "prettier-plugin-tailwindcss": "^0.6.8",
        "sass": "^1.80.3",
        "styled-components": "^6.1.13",
        "tailwindcss": "^3.4.14",
        "twin.macro": "^3.4.1",
        "typescript": "^5.6.3",
        "vite": "^4.5.5",
        "vite-plugin-babel-macros": "^1.0.6",
        "vite-plugin-sitemap": "^0.6.2"
    },
    "prettier": {
        "tabWidth": 4,
        "useTabs": false,
        "printWidth": 100,
        "plugins": [
            "prettier-plugin-tailwindcss"
        ],
        "tailwindFunctions": [
            "tw"
        ]
    },
    "lint-staged": {
        "*.{ts,tsx}": "eslint --cache --fix",
        "*.{ts,tsx,css,scss,json}": "prettier --write"
    },
    "babelMacros": {
        "twin": {
            "preset": "styled-components"
        }
    }
}


================================================
File: postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
File: tailwind.config.js
================================================
import plugin from "tailwindcss/plugin";

/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: ["class"],
    content: [
        "./pages/**/*.{ts,tsx}",
        "./components/**/*.{ts,tsx}",
        "./app/**/*.{ts,tsx}",
        "./src/**/*.{ts,tsx}",
    ],
    theme: {
        screens: {
            xs: "380px",
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1280px",
            "2xl": "1400px",
            m: { max: "431px" },
            mobile: { max: "431px" },
            pc: { min: "431px" },
        },
        container: {
            center: true,
            padding: "2rem",
            screens: {
                "2xl": "1400px",
            },
        },
        extend: {
            colors: {
                border: "#5F5F82",
                input: "hsl(var(--input))",
                ring: "hsl(var(--ring))",
                background: "hsl(var(--background))",
                foreground: "hsl(var(--foreground))",
                primary: {
                    DEFAULT: "hsl(var(--primary))",
                    foreground: "hsl(var(--primary-foreground))",
                    button: "#2797ff",
                    text: "#56adff",
                },
                secondary: {
                    DEFAULT: "hsl(var(--secondary))",
                    foreground: "hsl(var(--secondary-foreground))",
                },
                destructive: {
                    DEFAULT: "hsl(var(--destructive))",
                    foreground: "hsl(var(--destructive-foreground))",
                },
                muted: {
                    DEFAULT: "hsl(var(--muted))",
                    foreground: "hsl(var(--muted-foreground))",
                    primary: "#0a2b49",
                },
                accent: {
                    DEFAULT: "hsl(var(--accent))",
                    foreground: "hsl(var(--accent-foreground))",
                },
                popover: {
                    DEFAULT: "hsl(var(--popover))",
                    foreground: "hsl(var(--popover-foreground))",
                },
                card: {
                    DEFAULT: "#1A1D2B",
                    foreground: "hsl(var(--card-foreground))",
                    hover: "#2e3242",
                    dark: "#101321",
                    light: "#31333e",
                },
            },
            borderRadius: {
                lg: "var(--radius)",
                md: "calc(var(--radius) - 2px)",
                sm: "calc(var(--radius) - 4px)",
            },
            keyframes: {
                "accordion-down": {
                    from: { height: 0 },
                    to: { height: "var(--radix-accordion-content-height)" },
                },
                "accordion-up": {
                    from: { height: "var(--radix-accordion-content-height)" },
                    to: { height: 0 },
                },
                "fade-in": {
                    "0%": { opacity: 0, transform: "translateY(10px)" },
                    "100%": { opacity: 1, transform: "translateY(0)" },
                },
            },
            animation: {
                "accordion-down": "accordion-down 0.2s ease-out",
                "accordion-up": "accordion-up 0.2s ease-out",
                "fade-in": "fade-in 0.2s ease-out",
            },
            backgroundImage: {
                "card-gradient": "linear-gradient(224deg, #1A1D2B 1.67%, #090B15 97.94%)",
            },
            borderColor: {
                "card-border": "#5F5F82",
            },
            dropShadow: {
                cyan: "0 0 5px rgba(7, 142, 253, 0.8)",
                pink: "0 0 5px rgba(255, 120, 217, 0.7)",
            },
        },
    },
    plugins: [
        require("tailwindcss-animate"),
        plugin(function ({ addUtilities, matchUtilities }) {
            addUtilities({
                ".b1": { border: "1px solid #000" },
                ".bl1": { borderLeft: "1px solid #000" },
                ".br1": { borderRight: "1px solid #000" },
                ".bt1": { borderTop: "1px solid #000" },
                ".bb1": { borderBottom: "1px solid #000" },
                ".bx1": { borderLeft: "1px solid #000", borderRight: "1px solid #000" },
                ".by1": { borderTop: "1px solid #000", borderBottom: "1px solid #000" },
            });
            matchUtilities({
                b1: (value) => ({ border: `1px solid ${value}` }),
                bl1: (value) => ({ borderLeft: `1px solid ${value}` }),
                br1: (value) => ({ borderRight: `1px solid ${value}` }),
                bt1: (value) => ({ borderTop: `1px solid ${value}` }),
                bb1: (value) => ({ borderBottom: `1px solid ${value}` }),
                bx1: (value) => ({
                    borderLeft: `1px solid ${value}`,
                    borderRight: `1px solid ${value}`,
                }),
                by1: (value) => ({
                    borderTop: `1px solid ${value}`,
                    borderBottom: `1px solid ${value}`,
                }),
            });
        }),
    ],
};



================================================
File: tsconfig.json
================================================
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,

        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",

        /* Linting */
        "strict": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noFallthroughCasesInSwitch": true,
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        }
    },
    "include": ["src"],
    "exclude": ["src/generated.ts"],
    "references": [{ "path": "./tsconfig.node.json" }]
}



================================================
File: tsconfig.node.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
File: vite.config.ts
================================================
import path from "path";
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react-swc";
import macros from "vite-plugin-babel-macros";
import sitemap from "vite-plugin-sitemap";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, process.cwd(), "VITE_");
    return {
        plugins: [
            react(),
            macros(),
            sitemap({
                hostname: env.VITE_SITEMAP_URL || "https://app-v4.glyph.exchange",
                dynamicRoutes: [
                    "/swap",
                    "/pools",
                    "/pools/create",
                    "/pool/:pool",
                    "/pool/:pool/new-position",
                ],
            }),
        ],
        optimizeDeps: {
            esbuildOptions: {
                target: "es2020",
            },
        },
        esbuild: {
            pure: env.VITE_LOG_ENABLE ? [] : ["console.log"],
            drop: ["debugger"],
            logOverride: { "this-is-undefined-in-esm": "silent" },
        },
        resolve: {
            alias: {
                "@": path.resolve(__dirname, "./src"),
            },
        },
    };
});



================================================
File: wagmi.config.ts
================================================
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import { ContractConfig, defineConfig } from "@wagmi/cli";
import { actions, react } from "@wagmi/cli/plugins";
import {
    ALGEBRA_ETERNAL_FARMING,
    ALGEBRA_FACTORY,
    ALGEBRA_POSITION_MANAGER,
    ALGEBRA_QUOTER,
    ALGEBRA_QUOTER_V2,
    ALGEBRA_ROUTER,
    FARMING_CENTER,
    GAMMA_UNIPROXY,
} from "./src/constants/addresses";
import {
    algebraFactoryABI,
    algebraPoolABI,
    algebraPositionManagerABI,
    algebraQuoterABI,
    algebraBasePluginABI,
    algebraRouterABI,
    algebraQuoterV2ABI,
    algebraEternalFarmingABI,
    farmingCenterABI,
    wNativeABI,
    gammaHypervisorABI,
    gammaUniProxyABI,
} from "./src/abis";

const contracts: ContractConfig[] = [
    {
        address: ALGEBRA_FACTORY,
        abi: algebraFactoryABI,
        name: "AlgebraFactory",
    },
    {
        abi: algebraPoolABI,
        name: "AlgebraPool",
    },
    {
        abi: algebraBasePluginABI,
        name: "AlgebraBasePlugin",
    },
    {
        address: ALGEBRA_POSITION_MANAGER,
        abi: algebraPositionManagerABI,
        name: "AlgebraPositionManager",
    },
    {
        address: ALGEBRA_QUOTER,
        abi: algebraQuoterABI,
        name: "AlgebraQuoter",
    },
    {
        address: ALGEBRA_QUOTER_V2,
        abi: algebraQuoterV2ABI,
        name: "AlgerbaQuoterV2",
    },
    {
        address: ALGEBRA_ROUTER,
        abi: algebraRouterABI,
        name: "AlgebraRouter",
    },
    {
        address: ALGEBRA_ETERNAL_FARMING,
        abi: algebraEternalFarmingABI,
        name: "AlgebraEternalFarming",
    },
    {
        address: FARMING_CENTER,
        abi: farmingCenterABI,
        name: "FarmingCenter",
    },
    {
        abi: wNativeABI,
        name: "WrappedNative",
    },
    {
        address: ADDRESS_ZERO,
        abi: gammaHypervisorABI,
        name: "gammaHypervisor",
    },
    {
        address: GAMMA_UNIPROXY,
        abi: gammaUniProxyABI,
        name: "gammaUniProxy",
    },
];

export default defineConfig({
    out: "src/generated.ts",
    contracts,
    plugins: [
        actions({
            watchContractEvent: false,
        }),
        react({
            useContractEvent: false,
            useContractItemEvent: false,
        }),
    ],
});



================================================
File: .eslintrc.cjs
================================================
module.exports = {
    root: true,
    env: { browser: true, es2020: true },
    extends: [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended",
        "plugin:react-hooks/recommended",
        "typescript",
        "prettier",
    ],
    ignorePatterns: ["dist", ".eslintrc.cjs"],
    parser: "@typescript-eslint/parser",
    plugins: ["react-refresh"],
    rules: {
        "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
        "no-unused-vars": "off",
        "@typescript-eslint/no-unused-vars": "warn",
        "@typescript-eslint/no-explicit-any": "warn",
        "react-refresh/only-export-components": "off",
    },
};



================================================
File: .npmrc.pages
================================================
//npm.pkg.github.com/:_authToken=${GPR_TOKEN}
@glyph-exchange:registry=https://npm.pkg.github.com


================================================
File: packages/glyph-exchange-integral-sdk-1.1.0.tgz
================================================
[Non-text file]



================================================
File: public/fonts/FraktionMono-Bold.otf
================================================
[Non-text file]


================================================
File: public/fonts/FraktionMono-BoldItalic.otf
================================================
[Non-text file]


================================================
File: public/fonts/FraktionMono-Regular.otf
================================================
[Non-text file]


================================================
File: public/fonts/FraktionMono-RegularItalic.otf
================================================
[Non-text file]


================================================
File: public/fonts/Geneva.ttf
================================================
[Non-text file]




================================================
File: scripts/deploy.sh
================================================
export >> .env.production
yarn build


================================================
File: src/App.tsx
================================================
import { createWeb3Modal, defaultWagmiConfig } from "@web3modal/wagmi/react";
import GlobalStyles from "./styles";
import { WagmiConfig } from "wagmi";
import Layout from "@/components/common/Layout";
import { defineChain } from "viem";
import { Environment } from "@/types/common";
import { ChainId } from "@glyph-exchange/integral-sdk";

const projectId = import.meta.env.VITE_WALLETCONNECT_PROJECT_ID;

const CHAIN_ENV: ChainEnv = {
    [Environment.PROD]: defineChain({
        id: ChainId.CoreMainnet,
        network: "core",
        name: "Core",
        nativeCurrency: { name: "Core", symbol: "CORE", decimals: 18 },
        rpcUrls: {
            default: {
                http: [import.meta.env.VITE_RPC_URL_PROD || "https://rpc.coredao.org"],
            },
            public: {
                http: [import.meta.env.VITE_RPC_URL_PROD || "https://rpc.coredao.org"],
            },
        },
        blockExplorers: {
            etherscan: {
                name: "Corescan",
                url: "https://scan.coredao.org",
            },
            default: {
                name: "Corescan",
                url: "https://scan.coredao.org",
            },
        },
    }),
    [Environment.DEV]: defineChain({
        id: ChainId.CoreTestnet,
        network: "core",
        name: "Core",
        nativeCurrency: { name: "Core", symbol: "tCORE", decimals: 18 },
        rpcUrls: {
            default: {
                http: [import.meta.env.VITE_RPC_URL_DEV || "https://rpc.test.btcs.network"],
            },
            public: {
                http: [import.meta.env.VITE_RPC_URL_DEV || "https://rpc.test.btcs.network"],
            },
        },
        blockExplorers: {
            etherscan: {
                name: "Corescan",
                url: "https://scan.test.btcs.network",
            },
            default: {
                name: "Corescan",
                url: "https://scan.test.btcs.network",
            },
        },
        testnet: true,
    }),
};

export const coreChain = CHAIN_ENV[import.meta.env.VITE_ENVIRONMENT];

const chains = [coreChain];
const wagmiConfig = defaultWagmiConfig({
    chains,
    projectId,
    metadata: {
        name: "Glyph Exchange v4",
        description: "DEX Engine",
        url: "https://app-v4.glyph.exchange",
        icons: ["/G.png"],
    },
});

createWeb3Modal({
    wagmiConfig,
    projectId,
    chains,
    chainImages: {
        [ChainId.CoreMainnet]: "/core.svg",
        [ChainId.CoreTestnet]: "/core.svg",
    },
    defaultChain: coreChain,
    themeMode: "light",
    themeVariables: {
        "--w3m-accent": "#f7931a",
        "--w3m-font-family": "FraktionMono-Regular",
        "--w3m-border-radius-master": "0px",
    },
});

function App({ children }: { children: React.ReactNode }) {
    return (
        <WagmiConfig config={wagmiConfig}>
            <GlobalStyles />
            <Layout>{children}</Layout>
        </WagmiConfig>
    );
}

export default App;



================================================
File: src/app.d.ts
================================================
import { FC, HTMLProps } from "react";
import { Address, Chain } from "viem";

declare global {
    type Account = `0x${string}`;

    type Maybe<T> = T | null | undefined;
    type MaybeArray<T> = T | T[] | null | undefined;
    type MaybePromise<T> = T | Promise<T> | null | undefined;
    type Position =
        | "top"
        | "top-right"
        | "right"
        | "bottom-right"
        | "bottom"
        | "bottom-left"
        | "left"
        | "top-left";

    type Props = HTMLProps<HTMLDivElement>;
    type Override<P, S> = Omit<P, keyof S> & S;
    type FCProps<T = undefined> = T extends undefined ? FC<Props> : FC<Override<Props, T>>;

    enum Environment {
        DEV = "DEV",
        PROD = "PROD",
    }
    type AddressesEnv = Record<Environment, Record<string, Address>>;
    type BlacklistPoolsEnv = Record<Environment, Address[]>;
    type PluginPoolsEnv = Record<Environment, Address[]>;
    type DefaultChainEnv = Record<Environment, Record<string, string>>;
    type ChainEnv = Record<Environment, Chain>;
    type GraphEnv = Record<Environment, Record<string, string>>;
    type ApiEnv = Record<Environment, Record<string, string>>;
}

export {};



================================================
File: src/generated.ts
================================================
import {
    getContract,
    GetContractArgs,
    readContract,
    ReadContractConfig,
    writeContract,
    WriteContractArgs,
    WriteContractPreparedArgs,
    WriteContractUnpreparedArgs,
    prepareWriteContract,
    PrepareWriteContractConfig,
} from 'wagmi/actions'

import {
    useContractRead,
    UseContractReadConfig,
    useContractWrite,
    UseContractWriteConfig,
    usePrepareContractWrite,
    UsePrepareContractWriteConfig,
} from 'wagmi'
import { ReadContractResult, WriteContractMode, PrepareWriteContractResult } from 'wagmi/actions'

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraBasePlugin
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraBasePluginABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_pool', internalType: 'address', type: 'address' },
            { name: '_factory', internalType: 'address', type: 'address' },
            { name: '_pluginFactory', internalType: 'address', type: 'address' },
        ],
    },
    { type: 'error', inputs: [], name: 'targetIsTooOld' },
    { type: 'error', inputs: [], name: 'volatilityOracleAlreadyInitialized' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            {
                name: 'feeConfig',
                internalType: 'struct AlgebraFeeConfiguration',
                type: 'tuple',
                components: [
                    { name: 'alpha1', internalType: 'uint16', type: 'uint16' },
                    { name: 'alpha2', internalType: 'uint16', type: 'uint16' },
                    { name: 'beta1', internalType: 'uint32', type: 'uint32' },
                    { name: 'beta2', internalType: 'uint32', type: 'uint32' },
                    { name: 'gamma1', internalType: 'uint16', type: 'uint16' },
                    { name: 'gamma2', internalType: 'uint16', type: 'uint16' },
                    { name: 'baseFee', internalType: 'uint16', type: 'uint16' },
                ],
                indexed: false,
            },
        ],
        name: 'FeeConfiguration',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'newIncentive', internalType: 'address', type: 'address', indexed: false },
        ],
        name: 'Incentive',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'newPlugin', internalType: 'address', type: 'address', indexed: false }],
        name: 'LimitOrderPlugin',
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'ALGEBRA_BASE_PLUGIN_MANAGER',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'afterFlash',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'uint160', type: 'uint160' },
            { name: 'tick', internalType: 'int24', type: 'int24' },
        ],
        name: 'afterInitialize',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'int24', type: 'int24' },
            { name: '', internalType: 'int24', type: 'int24' },
            { name: '', internalType: 'int128', type: 'int128' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'afterModifyPosition',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: 'zeroToOne', internalType: 'bool', type: 'bool' },
            { name: '', internalType: 'int256', type: 'int256' },
            { name: '', internalType: 'uint160', type: 'uint160' },
            { name: '', internalType: 'int256', type: 'int256' },
            { name: '', internalType: 'int256', type: 'int256' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'afterSwap',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'uint256', type: 'uint256' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'beforeFlash',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'uint160', type: 'uint160' },
        ],
        name: 'beforeInitialize',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'int24', type: 'int24' },
            { name: '', internalType: 'int24', type: 'int24' },
            { name: '', internalType: 'int128', type: 'int128' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'beforeModifyPosition',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'bool', type: 'bool' },
            { name: '', internalType: 'int256', type: 'int256' },
            { name: '', internalType: 'uint160', type: 'uint160' },
            { name: '', internalType: 'bool', type: 'bool' },
            { name: '', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'beforeSwap',
        outputs: [{ name: '', internalType: 'bytes4', type: 'bytes4' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: '_config',
                internalType: 'struct AlgebraFeeConfiguration',
                type: 'tuple',
                components: [
                    { name: 'alpha1', internalType: 'uint16', type: 'uint16' },
                    { name: 'alpha2', internalType: 'uint16', type: 'uint16' },
                    { name: 'beta1', internalType: 'uint32', type: 'uint32' },
                    { name: 'beta2', internalType: 'uint32', type: 'uint32' },
                    { name: 'gamma1', internalType: 'uint16', type: 'uint16' },
                    { name: 'gamma2', internalType: 'uint16', type: 'uint16' },
                    { name: 'baseFee', internalType: 'uint16', type: 'uint16' },
                ],
            },
        ],
        name: 'changeFeeConfiguration',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'defaultPluginConfig',
        outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'feeConfig',
        outputs: [
            { name: 'alpha1', internalType: 'uint16', type: 'uint16' },
            { name: 'alpha2', internalType: 'uint16', type: 'uint16' },
            { name: 'beta1', internalType: 'uint32', type: 'uint32' },
            { name: 'beta2', internalType: 'uint32', type: 'uint32' },
            { name: 'gamma1', internalType: 'uint16', type: 'uint16' },
            { name: 'gamma2', internalType: 'uint16', type: 'uint16' },
            { name: 'baseFee', internalType: 'uint16', type: 'uint16' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getCurrentFee',
        outputs: [{ name: 'fee', internalType: 'uint16', type: 'uint16' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'secondsAgo', internalType: 'uint32', type: 'uint32' }],
        name: 'getSingleTimepoint',
        outputs: [
            { name: 'tickCumulative', internalType: 'int56', type: 'int56' },
            { name: 'volatilityCumulative', internalType: 'uint88', type: 'uint88' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'secondsAgos', internalType: 'uint32[]', type: 'uint32[]' }],
        name: 'getTimepoints',
        outputs: [
            { name: 'tickCumulatives', internalType: 'int56[]', type: 'int56[]' },
            { name: 'volatilityCumulatives', internalType: 'uint88[]', type: 'uint88[]' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'incentive',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'initialize',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'targetIncentive', internalType: 'address', type: 'address' }],
        name: 'isIncentiveConnected',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'isInitialized',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'lastTimepointTimestamp',
        outputs: [{ name: '', internalType: 'uint32', type: 'uint32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'limitOrderPlugin',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'pool',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'startIndex', internalType: 'uint16', type: 'uint16' },
            { name: 'amount', internalType: 'uint16', type: 'uint16' },
        ],
        name: 'prepayTimepointsStorageSlots',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newIncentive', internalType: 'address', type: 'address' }],
        name: 'setIncentive',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'plugin', internalType: 'address', type: 'address' }],
        name: 'setLimitOrderPlugin',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'timepointIndex',
        outputs: [{ name: '', internalType: 'uint16', type: 'uint16' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
        name: 'timepoints',
        outputs: [
            { name: 'initialized', internalType: 'bool', type: 'bool' },
            { name: 'blockTimestamp', internalType: 'uint32', type: 'uint32' },
            { name: 'tickCumulative', internalType: 'int56', type: 'int56' },
            { name: 'volatilityCumulative', internalType: 'uint88', type: 'uint88' },
            { name: 'tick', internalType: 'int24', type: 'int24' },
            { name: 'averageTick', internalType: 'int24', type: 'int24' },
            { name: 'windowStartIndex', internalType: 'uint16', type: 'uint16' },
        ],
    },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraEternalFarming
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraEternalFarmingABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_deployer', internalType: 'contract IAlgebraPoolDeployer', type: 'address' },
            {
                name: '_nonfungiblePositionManager',
                internalType: 'contract INonfungiblePositionManager',
                type: 'address',
            },
        ],
    },
    { type: 'error', inputs: [], name: 'anotherFarmingIsActive' },
    { type: 'error', inputs: [], name: 'claimToZeroAddress' },
    { type: 'error', inputs: [], name: 'emergencyActivated' },
    { type: 'error', inputs: [], name: 'farmDoesNotExist' },
    { type: 'error', inputs: [], name: 'incentiveNotExist' },
    { type: 'error', inputs: [], name: 'incentiveStopped' },
    { type: 'error', inputs: [], name: 'invalidPool' },
    { type: 'error', inputs: [], name: 'invalidTokenAmount' },
    { type: 'error', inputs: [], name: 'minimalPositionWidthTooWide' },
    { type: 'error', inputs: [], name: 'pluginNotConnected' },
    { type: 'error', inputs: [], name: 'poolReentrancyLock' },
    { type: 'error', inputs: [], name: 'positionIsTooNarrow' },
    { type: 'error', inputs: [], name: 'reentrancyLock' },
    { type: 'error', inputs: [], name: 'tokenAlreadyFarmed' },
    { type: 'error', inputs: [], name: 'zeroLiquidity' },
    { type: 'error', inputs: [], name: 'zeroRewardAmount' },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'newStatus', internalType: 'bool', type: 'bool', indexed: false }],
        name: 'EmergencyWithdraw',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            {
                name: 'rewardToken',
                internalType: 'contract IERC20Minimal',
                type: 'address',
                indexed: true,
            },
            {
                name: 'bonusRewardToken',
                internalType: 'contract IERC20Minimal',
                type: 'address',
                indexed: true,
            },
            { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address', indexed: true },
            { name: 'virtualPool', internalType: 'address', type: 'address', indexed: false },
            { name: 'nonce', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'reward', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'bonusReward', internalType: 'uint256', type: 'uint256', indexed: false },
            {
                name: 'minimalAllowedPositionWidth',
                internalType: 'uint24',
                type: 'uint24',
                indexed: false,
            },
        ],
        name: 'EternalFarmingCreated',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'rewardAddress', internalType: 'address', type: 'address', indexed: true },
            { name: 'bonusRewardToken', internalType: 'address', type: 'address', indexed: false },
            { name: 'owner', internalType: 'address', type: 'address', indexed: false },
            { name: 'reward', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'bonusReward', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'FarmEnded',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'liquidity', internalType: 'uint128', type: 'uint128', indexed: false },
        ],
        name: 'FarmEntered',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'farmingCenter', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'FarmingCenter',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: true }],
        name: 'IncentiveDeactivated',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'rewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'bonusRewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: false },
        ],
        name: 'RewardAmountsDecreased',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'to', internalType: 'address', type: 'address', indexed: true },
            { name: 'reward', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'rewardAddress', internalType: 'address', type: 'address', indexed: true },
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'RewardClaimed',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'rewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'bonusRewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: false },
        ],
        name: 'RewardsAdded',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: false },
            { name: 'rewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'bonusRewardAmount', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'RewardsCollected',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'rewardRate', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'bonusRewardRate', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32', indexed: false },
        ],
        name: 'RewardsRatesChanged',
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'FARMINGS_ADMINISTRATOR_ROLE',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'INCENTIVE_MAKER_ROLE',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'rewardAmount', internalType: 'uint128', type: 'uint128' },
            { name: 'bonusRewardAmount', internalType: 'uint128', type: 'uint128' },
        ],
        name: 'addRewards',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'rewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'amountRequested', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'claimReward',
        outputs: [{ name: 'reward', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'rewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'amountRequested', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'claimRewardFrom',
        outputs: [{ name: 'reward', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: '_owner', internalType: 'address', type: 'address' },
        ],
        name: 'collectRewards',
        outputs: [
            { name: 'reward', internalType: 'uint256', type: 'uint256' },
            { name: 'bonusReward', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            {
                name: 'params',
                internalType: 'struct IAlgebraEternalFarming.IncentiveParams',
                type: 'tuple',
                components: [
                    { name: 'reward', internalType: 'uint128', type: 'uint128' },
                    { name: 'bonusReward', internalType: 'uint128', type: 'uint128' },
                    { name: 'rewardRate', internalType: 'uint128', type: 'uint128' },
                    { name: 'bonusRewardRate', internalType: 'uint128', type: 'uint128' },
                    { name: 'minimalPositionWidth', internalType: 'uint24', type: 'uint24' },
                ],
            },
            { name: 'plugin', internalType: 'address', type: 'address' },
        ],
        name: 'createEternalFarming',
        outputs: [{ name: 'virtualPool', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'deactivateIncentive',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'rewardAmount', internalType: 'uint128', type: 'uint128' },
            { name: 'bonusRewardAmount', internalType: 'uint128', type: 'uint128' },
        ],
        name: 'decreaseRewardsAmount',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'enterFarming',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: '_owner', internalType: 'address', type: 'address' },
        ],
        name: 'exitFarming',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'farmingCenter',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'incentiveId', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'farms',
        outputs: [
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'tickLower', internalType: 'int24', type: 'int24' },
            { name: 'tickUpper', internalType: 'int24', type: 'int24' },
            { name: 'innerRewardGrowth0', internalType: 'uint256', type: 'uint256' },
            { name: 'innerRewardGrowth1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'getRewardInfo',
        outputs: [
            { name: 'reward', internalType: 'uint256', type: 'uint256' },
            { name: 'bonusReward', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'incentiveId', internalType: 'bytes32', type: 'bytes32' }],
        name: 'incentives',
        outputs: [
            { name: 'totalReward', internalType: 'uint128', type: 'uint128' },
            { name: 'bonusReward', internalType: 'uint128', type: 'uint128' },
            { name: 'virtualPoolAddress', internalType: 'address', type: 'address' },
            { name: 'minimalPositionWidth', internalType: 'uint24', type: 'uint24' },
            { name: 'deactivated', internalType: 'bool', type: 'bool' },
            { name: 'pluginAddress', internalType: 'address', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'isEmergencyWithdrawActivated',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'incentiveId', internalType: 'bytes32', type: 'bytes32' }],
        name: 'isIncentiveDeactivated',
        outputs: [{ name: 'res', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'nonfungiblePositionManager',
        outputs: [
            { name: '', internalType: 'contract INonfungiblePositionManager', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'numOfIncentives',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address' },
            { name: 'rewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
        ],
        name: 'rewards',
        outputs: [{ name: 'rewardAmount', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newStatus', internalType: 'bool', type: 'bool' }],
        name: 'setEmergencyWithdrawStatus',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: '_farmingCenter', internalType: 'address', type: 'address' }],
        name: 'setFarmingCenterAddress',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'rewardRate', internalType: 'uint128', type: 'uint128' },
            { name: 'bonusRewardRate', internalType: 'uint128', type: 'uint128' },
        ],
        name: 'setRates',
        outputs: [],
    },
] as const

export const algebraEternalFarmingAddress = '0xf3784e22F36FfA9292423b08392726440F5Fe81E' as const

export const algebraEternalFarmingConfig = {
    address: algebraEternalFarmingAddress,
    abi: algebraEternalFarmingABI,
} as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraFactory
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraFactoryABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [{ name: '_poolDeployer', internalType: 'address', type: 'address' }],
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            {
                name: 'newDefaultCommunityFee',
                internalType: 'uint8',
                type: 'uint8',
                indexed: false,
            },
        ],
        name: 'DefaultCommunityFee',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'newFarmingAddress', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'FarmingAddress',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'alpha1', internalType: 'uint16', type: 'uint16', indexed: false },
            { name: 'alpha2', internalType: 'uint16', type: 'uint16', indexed: false },
            { name: 'beta1', internalType: 'uint32', type: 'uint32', indexed: false },
            { name: 'beta2', internalType: 'uint32', type: 'uint32', indexed: false },
            { name: 'gamma1', internalType: 'uint16', type: 'uint16', indexed: false },
            { name: 'gamma2', internalType: 'uint16', type: 'uint16', indexed: false },
            { name: 'baseFee', internalType: 'uint16', type: 'uint16', indexed: false },
        ],
        name: 'FeeConfiguration',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'previousOwner', internalType: 'address', type: 'address', indexed: true },
            { name: 'newOwner', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'OwnershipTransferStarted',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'previousOwner', internalType: 'address', type: 'address', indexed: true },
            { name: 'newOwner', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'OwnershipTransferred',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'token0', internalType: 'address', type: 'address', indexed: true },
            { name: 'token1', internalType: 'address', type: 'address', indexed: true },
            { name: 'pool', internalType: 'address', type: 'address', indexed: false },
        ],
        name: 'Pool',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'previousAdminRole', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'newAdminRole', internalType: 'bytes32', type: 'bytes32', indexed: true },
        ],
        name: 'RoleAdminChanged',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'account', internalType: 'address', type: 'address', indexed: true },
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'RoleGranted',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32', indexed: true },
            { name: 'account', internalType: 'address', type: 'address', indexed: true },
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
        ],
        name: 'RoleRevoked',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'timestamp', internalType: 'uint256', type: 'uint256', indexed: false }],
        name: 'renounceOwnershipFinished',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'timestamp', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'finishTimestamp', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'renounceOwnershipStarted',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'timestamp', internalType: 'uint256', type: 'uint256', indexed: false }],
        name: 'renounceOwnershipStopped',
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'DEFAULT_ADMIN_ROLE',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'acceptOwnership',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'baseFeeConfiguration',
        outputs: [
            { name: 'alpha1', internalType: 'uint16', type: 'uint16' },
            { name: 'alpha2', internalType: 'uint16', type: 'uint16' },
            { name: 'beta1', internalType: 'uint32', type: 'uint32' },
            { name: 'beta2', internalType: 'uint32', type: 'uint32' },
            { name: 'gamma1', internalType: 'uint16', type: 'uint16' },
            { name: 'gamma2', internalType: 'uint16', type: 'uint16' },
            { name: 'baseFee', internalType: 'uint16', type: 'uint16' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'communityVault',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenA', internalType: 'address', type: 'address' },
            { name: 'tokenB', internalType: 'address', type: 'address' },
        ],
        name: 'createPool',
        outputs: [{ name: 'pool', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'defaultCommunityFee',
        outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'farmingAddress',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'role', internalType: 'bytes32', type: 'bytes32' }],
        name: 'getRoleAdmin',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'index', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'getRoleMember',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'role', internalType: 'bytes32', type: 'bytes32' }],
        name: 'getRoleMemberCount',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'account', internalType: 'address', type: 'address' },
        ],
        name: 'grantRole',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'account', internalType: 'address', type: 'address' },
        ],
        name: 'hasRole',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'account', internalType: 'address', type: 'address' },
        ],
        name: 'hasRoleOrOwner',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'owner',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'pendingOwner',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: '', internalType: 'address', type: 'address' },
            { name: '', internalType: 'address', type: 'address' },
        ],
        name: 'poolByPair',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'poolDeployer',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'renounceOwnership',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'renounceOwnershipStartTimestamp',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'account', internalType: 'address', type: 'address' },
        ],
        name: 'renounceRole',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'role', internalType: 'bytes32', type: 'bytes32' },
            { name: 'account', internalType: 'address', type: 'address' },
        ],
        name: 'revokeRole',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: '_config',
                internalType: 'struct IAlgebraFeeConfiguration.Configuration',
                type: 'tuple',
                components: [
                    { name: 'alpha1', internalType: 'uint16', type: 'uint16' },
                    { name: 'alpha2', internalType: 'uint16', type: 'uint16' },
                    { name: 'beta1', internalType: 'uint32', type: 'uint32' },
                    { name: 'beta2', internalType: 'uint32', type: 'uint32' },
                    { name: 'gamma1', internalType: 'uint16', type: 'uint16' },
                    { name: 'gamma2', internalType: 'uint16', type: 'uint16' },
                    { name: 'baseFee', internalType: 'uint16', type: 'uint16' },
                ],
            },
        ],
        name: 'setBaseFeeConfiguration',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newDefaultCommunityFee', internalType: 'uint8', type: 'uint8' }],
        name: 'setDefaultCommunityFee',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newFarmingAddress', internalType: 'address', type: 'address' }],
        name: 'setFarmingAddress',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'startRenounceOwnership',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'stopRenounceOwnership',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'interfaceId', internalType: 'bytes4', type: 'bytes4' }],
        name: 'supportsInterface',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newOwner', internalType: 'address', type: 'address' }],
        name: 'transferOwnership',
        outputs: [],
    },
] as const

export const algebraFactoryAddress = '0x74EfE55beA4988e7D92D03EFd8ddB8BF8b7bD597' as const

export const algebraFactoryConfig = {
    address: algebraFactoryAddress,
    abi: algebraFactoryABI,
} as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraPool
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraPoolABI = [
    { type: 'error', inputs: [], name: 'alreadyInitialized' },
    { type: 'error', inputs: [], name: 'arithmeticError' },
    { type: 'error', inputs: [], name: 'bottomTickLowerThanMIN' },
    { type: 'error', inputs: [], name: 'dynamicFeeActive' },
    { type: 'error', inputs: [], name: 'dynamicFeeDisabled' },
    { type: 'error', inputs: [], name: 'flashInsufficientPaid0' },
    { type: 'error', inputs: [], name: 'flashInsufficientPaid1' },
    { type: 'error', inputs: [], name: 'insufficientInputAmount' },
    { type: 'error', inputs: [], name: 'invalidAmountRequired' },
    {
        type: 'error',
        inputs: [{ name: 'selector', internalType: 'bytes4', type: 'bytes4' }],
        name: 'invalidHookResponse',
    },
    { type: 'error', inputs: [], name: 'invalidLimitSqrtPrice' },
    { type: 'error', inputs: [], name: 'invalidNewCommunityFee' },
    { type: 'error', inputs: [], name: 'invalidNewTickSpacing' },
    { type: 'error', inputs: [], name: 'liquidityAdd' },
    { type: 'error', inputs: [], name: 'liquidityOverflow' },
    { type: 'error', inputs: [], name: 'liquiditySub' },
    { type: 'error', inputs: [], name: 'locked' },
    { type: 'error', inputs: [], name: 'notAllowed' },
    { type: 'error', inputs: [], name: 'notInitialized' },
    { type: 'error', inputs: [], name: 'onlyFarming' },
    { type: 'error', inputs: [], name: 'pluginIsNotConnected' },
    { type: 'error', inputs: [], name: 'priceOutOfRange' },
    { type: 'error', inputs: [], name: 'tickInvalidLinks' },
    { type: 'error', inputs: [], name: 'tickIsNotInitialized' },
    { type: 'error', inputs: [], name: 'tickIsNotSpaced' },
    { type: 'error', inputs: [], name: 'tickOutOfRange' },
    { type: 'error', inputs: [], name: 'topTickAboveMAX' },
    { type: 'error', inputs: [], name: 'topTickLowerOrEqBottomTick' },
    { type: 'error', inputs: [], name: 'transferFailed' },
    { type: 'error', inputs: [], name: 'zeroAmountRequired' },
    { type: 'error', inputs: [], name: 'zeroLiquidityActual' },
    { type: 'error', inputs: [], name: 'zeroLiquidityDesired' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'bottomTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'topTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'liquidityAmount', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Burn',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'recipient', internalType: 'address', type: 'address', indexed: false },
            { name: 'bottomTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'topTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'amount0', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'amount1', internalType: 'uint128', type: 'uint128', indexed: false },
        ],
        name: 'Collect',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'communityFeeNew', internalType: 'uint16', type: 'uint16', indexed: false },
        ],
        name: 'CommunityFee',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'fee', internalType: 'uint16', type: 'uint16', indexed: false }],
        name: 'Fee',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
            { name: 'recipient', internalType: 'address', type: 'address', indexed: true },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'paid0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'paid1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Flash',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'price', internalType: 'uint160', type: 'uint160', indexed: false },
            { name: 'tick', internalType: 'int24', type: 'int24', indexed: false },
        ],
        name: 'Initialize',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'sender', internalType: 'address', type: 'address', indexed: false },
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'bottomTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'topTick', internalType: 'int24', type: 'int24', indexed: true },
            { name: 'liquidityAmount', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Mint',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'newPluginAddress', internalType: 'address', type: 'address', indexed: false },
        ],
        name: 'Plugin',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'newPluginConfig', internalType: 'uint8', type: 'uint8', indexed: false }],
        name: 'PluginConfig',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
            { name: 'recipient', internalType: 'address', type: 'address', indexed: true },
            { name: 'amount0', internalType: 'int256', type: 'int256', indexed: false },
            { name: 'amount1', internalType: 'int256', type: 'int256', indexed: false },
            { name: 'price', internalType: 'uint160', type: 'uint160', indexed: false },
            { name: 'liquidity', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'tick', internalType: 'int24', type: 'int24', indexed: false },
        ],
        name: 'Swap',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'newTickSpacing', internalType: 'int24', type: 'int24', indexed: false }],
        name: 'TickSpacing',
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'bottomTick', internalType: 'int24', type: 'int24' },
            { name: 'topTick', internalType: 'int24', type: 'int24' },
            { name: 'amount', internalType: 'uint128', type: 'uint128' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'burn',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'bottomTick', internalType: 'int24', type: 'int24' },
            { name: 'topTick', internalType: 'int24', type: 'int24' },
            { name: 'amount0Requested', internalType: 'uint128', type: 'uint128' },
            { name: 'amount1Requested', internalType: 'uint128', type: 'uint128' },
        ],
        name: 'collect',
        outputs: [
            { name: 'amount0', internalType: 'uint128', type: 'uint128' },
            { name: 'amount1', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'communityFeeLastTimestamp',
        outputs: [{ name: '', internalType: 'uint32', type: 'uint32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'communityVault',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'factory',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'fee',
        outputs: [{ name: 'currentFee', internalType: 'uint16', type: 'uint16' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'flash',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getCommunityFeePending',
        outputs: [
            { name: '', internalType: 'uint128', type: 'uint128' },
            { name: '', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getReserves',
        outputs: [
            { name: '', internalType: 'uint128', type: 'uint128' },
            { name: '', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'globalState',
        outputs: [
            { name: 'price', internalType: 'uint160', type: 'uint160' },
            { name: 'tick', internalType: 'int24', type: 'int24' },
            { name: 'fee', internalType: 'uint16', type: 'uint16' },
            { name: 'pluginConfig', internalType: 'uint8', type: 'uint8' },
            { name: 'communityFee', internalType: 'uint16', type: 'uint16' },
            { name: 'unlocked', internalType: 'bool', type: 'bool' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'initialPrice', internalType: 'uint160', type: 'uint160' }],
        name: 'initialize',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'liquidity',
        outputs: [{ name: '', internalType: 'uint128', type: 'uint128' }],
    },
    {
        stateMutability: 'pure',
        type: 'function',
        inputs: [],
        name: 'maxLiquidityPerTick',
        outputs: [{ name: '', internalType: 'uint128', type: 'uint128' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'leftoversRecipient', internalType: 'address', type: 'address' },
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'bottomTick', internalType: 'int24', type: 'int24' },
            { name: 'topTick', internalType: 'int24', type: 'int24' },
            { name: 'liquidityDesired', internalType: 'uint128', type: 'uint128' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'mint',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidityActual', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'nextTickGlobal',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'plugin',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
        name: 'positions',
        outputs: [
            { name: 'liquidity', internalType: 'uint256', type: 'uint256' },
            { name: 'innerFeeGrowth0Token', internalType: 'uint256', type: 'uint256' },
            { name: 'innerFeeGrowth1Token', internalType: 'uint256', type: 'uint256' },
            { name: 'fees0', internalType: 'uint128', type: 'uint128' },
            { name: 'fees1', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'prevTickGlobal',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newCommunityFee', internalType: 'uint16', type: 'uint16' }],
        name: 'setCommunityFee',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newFee', internalType: 'uint16', type: 'uint16' }],
        name: 'setFee',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newPluginAddress', internalType: 'address', type: 'address' }],
        name: 'setPlugin',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newConfig', internalType: 'uint8', type: 'uint8' }],
        name: 'setPluginConfig',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newTickSpacing', internalType: 'int24', type: 'int24' }],
        name: 'setTickSpacing',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'zeroToOne', internalType: 'bool', type: 'bool' },
            { name: 'amountRequired', internalType: 'int256', type: 'int256' },
            { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'swap',
        outputs: [
            { name: 'amount0', internalType: 'int256', type: 'int256' },
            { name: 'amount1', internalType: 'int256', type: 'int256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'leftoversRecipient', internalType: 'address', type: 'address' },
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'zeroToOne', internalType: 'bool', type: 'bool' },
            { name: 'amountToSell', internalType: 'int256', type: 'int256' },
            { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'swapWithPaymentInAdvance',
        outputs: [
            { name: 'amount0', internalType: 'int256', type: 'int256' },
            { name: 'amount1', internalType: 'int256', type: 'int256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'tickSpacing',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'int16', type: 'int16' }],
        name: 'tickTable',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'int24', type: 'int24' }],
        name: 'ticks',
        outputs: [
            { name: 'liquidityTotal', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidityDelta', internalType: 'int128', type: 'int128' },
            { name: 'prevTick', internalType: 'int24', type: 'int24' },
            { name: 'nextTick', internalType: 'int24', type: 'int24' },
            { name: 'outerFeeGrowth0Token', internalType: 'uint256', type: 'uint256' },
            { name: 'outerFeeGrowth1Token', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'token0',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'token1',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'totalFeeGrowth0Token',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'totalFeeGrowth1Token',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraPositionManager
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraPositionManagerABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_factory', internalType: 'address', type: 'address' },
            { name: '_WNativeToken', internalType: 'address', type: 'address' },
            { name: '_tokenDescriptor_', internalType: 'address', type: 'address' },
            { name: '_poolDeployer', internalType: 'address', type: 'address' },
        ],
    },
    { type: 'error', inputs: [], name: 'tickOutOfRange' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'approved', internalType: 'address', type: 'address', indexed: true },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
        ],
        name: 'Approval',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'operator', internalType: 'address', type: 'address', indexed: true },
            { name: 'approved', internalType: 'bool', type: 'bool', indexed: false },
        ],
        name: 'ApprovalForAll',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
            { name: 'recipient', internalType: 'address', type: 'address', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Collect',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
            { name: 'liquidity', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'DecreaseLiquidity',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            {
                name: 'farmingCenterAddress',
                internalType: 'address',
                type: 'address',
                indexed: false,
            },
        ],
        name: 'FarmingCenter',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true }],
        name: 'FarmingFailed',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
            { name: 'liquidityDesired', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'actualLiquidity', internalType: 'uint128', type: 'uint128', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'pool', internalType: 'address', type: 'address', indexed: false },
        ],
        name: 'IncreaseLiquidity',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'from', internalType: 'address', type: 'address', indexed: true },
            { name: 'to', internalType: 'address', type: 'address', indexed: true },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256', indexed: true },
        ],
        name: 'Transfer',
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'DOMAIN_SEPARATOR',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'PERMIT_TYPEHASH',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'WNativeToken',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'amount0Owed', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1Owed', internalType: 'uint256', type: 'uint256' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'algebraMintCallback',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'approve',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'approve', internalType: 'bool', type: 'bool' },
            { name: 'farmingAddress', internalType: 'address', type: 'address' },
        ],
        name: 'approveForFarming',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'owner', internalType: 'address', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'burn',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct INonfungiblePositionManager.CollectParams',
                type: 'tuple',
                components: [
                    { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'amount0Max', internalType: 'uint128', type: 'uint128' },
                    { name: 'amount1Max', internalType: 'uint128', type: 'uint128' },
                ],
            },
        ],
        name: 'collect',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token0', internalType: 'address', type: 'address' },
            { name: 'token1', internalType: 'address', type: 'address' },
            { name: 'sqrtPriceX96', internalType: 'uint160', type: 'uint160' },
        ],
        name: 'createAndInitializePoolIfNecessary',
        outputs: [{ name: 'pool', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct INonfungiblePositionManager.DecreaseLiquidityParams',
                type: 'tuple',
                components: [
                    { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
                    { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
                    { name: 'amount0Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount1Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'decreaseLiquidity',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'factory',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'farmingApprovals',
        outputs: [{ name: 'farmingCenterAddress', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'farmingCenter',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'getApproved',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct INonfungiblePositionManager.IncreaseLiquidityParams',
                type: 'tuple',
                components: [
                    { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount0Desired', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount1Desired', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount0Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount1Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'increaseLiquidity',
        outputs: [
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address' },
            { name: 'operator', internalType: 'address', type: 'address' },
        ],
        name: 'isApprovedForAll',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'isApprovedOrOwner',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct INonfungiblePositionManager.MintParams',
                type: 'tuple',
                components: [
                    { name: 'token0', internalType: 'address', type: 'address' },
                    { name: 'token1', internalType: 'address', type: 'address' },
                    { name: 'tickLower', internalType: 'int24', type: 'int24' },
                    { name: 'tickUpper', internalType: 'int24', type: 'int24' },
                    { name: 'amount0Desired', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount1Desired', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount0Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'amount1Min', internalType: 'uint256', type: 'uint256' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'mint',
        outputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [{ name: 'data', internalType: 'bytes[]', type: 'bytes[]' }],
        name: 'multicall',
        outputs: [{ name: 'results', internalType: 'bytes[]', type: 'bytes[]' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'name',
        outputs: [{ name: '', internalType: 'string', type: 'string' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'ownerOf',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'permit',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'poolDeployer',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'positions',
        outputs: [
            { name: 'nonce', internalType: 'uint88', type: 'uint88' },
            { name: 'operator', internalType: 'address', type: 'address' },
            { name: 'token0', internalType: 'address', type: 'address' },
            { name: 'token1', internalType: 'address', type: 'address' },
            { name: 'tickLower', internalType: 'int24', type: 'int24' },
            { name: 'tickUpper', internalType: 'int24', type: 'int24' },
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'feeGrowthInside0LastX128', internalType: 'uint256', type: 'uint256' },
            { name: 'feeGrowthInside1LastX128', internalType: 'uint256', type: 'uint256' },
            { name: 'tokensOwed0', internalType: 'uint128', type: 'uint128' },
            { name: 'tokensOwed1', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [],
        name: 'refundNativeToken',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'safeTransferFrom',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'safeTransferFrom',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'value', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermit',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'nonce', internalType: 'uint256', type: 'uint256' },
            { name: 'expiry', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitAllowed',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'nonce', internalType: 'uint256', type: 'uint256' },
            { name: 'expiry', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitAllowedIfNecessary',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'value', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitIfNecessary',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'operator', internalType: 'address', type: 'address' },
            { name: 'approved', internalType: 'bool', type: 'bool' },
        ],
        name: 'setApprovalForAll',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newFarmingCenter', internalType: 'address', type: 'address' }],
        name: 'setFarmingCenter',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'interfaceId', internalType: 'bytes4', type: 'bytes4' }],
        name: 'supportsInterface',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
        ],
        name: 'sweepToken',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'toActive', internalType: 'bool', type: 'bool' },
        ],
        name: 'switchFarmingStatus',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'symbol',
        outputs: [{ name: '', internalType: 'string', type: 'string' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'index', internalType: 'uint256', type: 'uint256' }],
        name: 'tokenByIndex',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'tokenFarmedIn',
        outputs: [{ name: 'farmingCenterAddress', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address' },
            { name: 'index', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'tokenOfOwnerByIndex',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'tokenURI',
        outputs: [{ name: '', internalType: 'string', type: 'string' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'totalSupply',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'transferFrom',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
        ],
        name: 'unwrapWNativeToken',
        outputs: [],
    },
    { stateMutability: 'payable', type: 'receive' },
] as const

export const algebraPositionManagerAddress = '0x7b3794f728780A61e0eB709b5bB849F50aad1E7f' as const

export const algebraPositionManagerConfig = {
    address: algebraPositionManagerAddress,
    abi: algebraPositionManagerABI,
} as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraQuoter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraQuoterABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_factory', internalType: 'address', type: 'address' },
            { name: '_WNativeToken', internalType: 'address', type: 'address' },
            { name: '_poolDeployer', internalType: 'address', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'WNativeToken',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'amount0Delta', internalType: 'int256', type: 'int256' },
            { name: 'amount1Delta', internalType: 'int256', type: 'int256' },
            { name: 'feeAmount', internalType: 'uint256', type: 'uint256' },
            { name: 'path', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'algebraSwapCallback',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'factory',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'poolDeployer',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'path', internalType: 'bytes', type: 'bytes' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'quoteExactInput',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'fees', internalType: 'uint16[]', type: 'uint16[]' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenIn', internalType: 'address', type: 'address' },
            { name: 'tokenOut', internalType: 'address', type: 'address' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
        ],
        name: 'quoteExactInputSingle',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'fee', internalType: 'uint16', type: 'uint16' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'path', internalType: 'bytes', type: 'bytes' },
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'quoteExactOutput',
        outputs: [
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'fees', internalType: 'uint16[]', type: 'uint16[]' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenIn', internalType: 'address', type: 'address' },
            { name: 'tokenOut', internalType: 'address', type: 'address' },
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
        ],
        name: 'quoteExactOutputSingle',
        outputs: [
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'fee', internalType: 'uint16', type: 'uint16' },
        ],
    },
] as const

export const algebraQuoterAddress = '0x6DC367969b2D856070dBC56f086890DF1bB70885' as const

export const algebraQuoterConfig = { address: algebraQuoterAddress, abi: algebraQuoterABI } as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgebraRouter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algebraRouterABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_factory', internalType: 'address', type: 'address' },
            { name: '_WNativeToken', internalType: 'address', type: 'address' },
            { name: '_poolDeployer', internalType: 'address', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'WNativeToken',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'amount0Delta', internalType: 'int256', type: 'int256' },
            { name: 'amount1Delta', internalType: 'int256', type: 'int256' },
            { name: '_data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'algebraSwapCallback',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct ISwapRouter.ExactInputParams',
                type: 'tuple',
                components: [
                    { name: 'path', internalType: 'bytes', type: 'bytes' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountOutMinimum', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'exactInput',
        outputs: [{ name: 'amountOut', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct ISwapRouter.ExactInputSingleParams',
                type: 'tuple',
                components: [
                    { name: 'tokenIn', internalType: 'address', type: 'address' },
                    { name: 'tokenOut', internalType: 'address', type: 'address' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountOutMinimum', internalType: 'uint256', type: 'uint256' },
                    { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
                ],
            },
        ],
        name: 'exactInputSingle',
        outputs: [{ name: 'amountOut', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct ISwapRouter.ExactInputSingleParams',
                type: 'tuple',
                components: [
                    { name: 'tokenIn', internalType: 'address', type: 'address' },
                    { name: 'tokenOut', internalType: 'address', type: 'address' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountOutMinimum', internalType: 'uint256', type: 'uint256' },
                    { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
                ],
            },
        ],
        name: 'exactInputSingleSupportingFeeOnTransferTokens',
        outputs: [{ name: 'amountOut', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct ISwapRouter.ExactOutputParams',
                type: 'tuple',
                components: [
                    { name: 'path', internalType: 'bytes', type: 'bytes' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountInMaximum', internalType: 'uint256', type: 'uint256' },
                ],
            },
        ],
        name: 'exactOutput',
        outputs: [{ name: 'amountIn', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct ISwapRouter.ExactOutputSingleParams',
                type: 'tuple',
                components: [
                    { name: 'tokenIn', internalType: 'address', type: 'address' },
                    { name: 'tokenOut', internalType: 'address', type: 'address' },
                    { name: 'recipient', internalType: 'address', type: 'address' },
                    { name: 'deadline', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
                    { name: 'amountInMaximum', internalType: 'uint256', type: 'uint256' },
                    { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
                ],
            },
        ],
        name: 'exactOutputSingle',
        outputs: [{ name: 'amountIn', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'factory',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [{ name: 'data', internalType: 'bytes[]', type: 'bytes[]' }],
        name: 'multicall',
        outputs: [{ name: 'results', internalType: 'bytes[]', type: 'bytes[]' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'poolDeployer',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [],
        name: 'refundNativeToken',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'value', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermit',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'nonce', internalType: 'uint256', type: 'uint256' },
            { name: 'expiry', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitAllowed',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'nonce', internalType: 'uint256', type: 'uint256' },
            { name: 'expiry', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitAllowedIfNecessary',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'value', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'selfPermitIfNecessary',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
        ],
        name: 'sweepToken',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'token', internalType: 'address', type: 'address' },
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'feeBips', internalType: 'uint256', type: 'uint256' },
            { name: 'feeRecipient', internalType: 'address', type: 'address' },
        ],
        name: 'sweepTokenWithFee',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
        ],
        name: 'unwrapWNativeToken',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [
            { name: 'amountMinimum', internalType: 'uint256', type: 'uint256' },
            { name: 'recipient', internalType: 'address', type: 'address' },
            { name: 'feeBips', internalType: 'uint256', type: 'uint256' },
            { name: 'feeRecipient', internalType: 'address', type: 'address' },
        ],
        name: 'unwrapWNativeTokenWithFee',
        outputs: [],
    },
    { stateMutability: 'payable', type: 'receive' },
] as const

export const algebraRouterAddress = '0x832933BA44658C50ae6152039Cd30A6f4C2432b1' as const

export const algebraRouterConfig = { address: algebraRouterAddress, abi: algebraRouterABI } as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AlgerbaQuoterV2
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const algerbaQuoterV2ABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_factory', internalType: 'address', type: 'address' },
            { name: '_WNativeToken', internalType: 'address', type: 'address' },
            { name: '_poolDeployer', internalType: 'address', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'WNativeToken',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'amount0Delta', internalType: 'int256', type: 'int256' },
            { name: 'amount1Delta', internalType: 'int256', type: 'int256' },
            { name: 'path', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'algebraSwapCallback',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'factory',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'poolDeployer',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'path', internalType: 'bytes', type: 'bytes' },
            { name: 'amountInRequired', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'quoteExactInput',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'sqrtPriceX96AfterList', internalType: 'uint160[]', type: 'uint160[]' },
            { name: 'initializedTicksCrossedList', internalType: 'uint32[]', type: 'uint32[]' },
            { name: 'gasEstimate', internalType: 'uint256', type: 'uint256' },
            { name: 'feeList', internalType: 'uint16[]', type: 'uint16[]' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct IQuoterV2.QuoteExactInputSingleParams',
                type: 'tuple',
                components: [
                    { name: 'tokenIn', internalType: 'address', type: 'address' },
                    { name: 'tokenOut', internalType: 'address', type: 'address' },
                    { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
                    { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
                ],
            },
        ],
        name: 'quoteExactInputSingle',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'sqrtPriceX96After', internalType: 'uint160', type: 'uint160' },
            { name: 'initializedTicksCrossed', internalType: 'uint32', type: 'uint32' },
            { name: 'gasEstimate', internalType: 'uint256', type: 'uint256' },
            { name: 'fee', internalType: 'uint16', type: 'uint16' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'path', internalType: 'bytes', type: 'bytes' },
            { name: 'amountOutRequired', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'quoteExactOutput',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'sqrtPriceX96AfterList', internalType: 'uint160[]', type: 'uint160[]' },
            { name: 'initializedTicksCrossedList', internalType: 'uint32[]', type: 'uint32[]' },
            { name: 'gasEstimate', internalType: 'uint256', type: 'uint256' },
            { name: 'feeList', internalType: 'uint16[]', type: 'uint16[]' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'params',
                internalType: 'struct IQuoterV2.QuoteExactOutputSingleParams',
                type: 'tuple',
                components: [
                    { name: 'tokenIn', internalType: 'address', type: 'address' },
                    { name: 'tokenOut', internalType: 'address', type: 'address' },
                    { name: 'amount', internalType: 'uint256', type: 'uint256' },
                    { name: 'limitSqrtPrice', internalType: 'uint160', type: 'uint160' },
                ],
            },
        ],
        name: 'quoteExactOutputSingle',
        outputs: [
            { name: 'amountOut', internalType: 'uint256', type: 'uint256' },
            { name: 'amountIn', internalType: 'uint256', type: 'uint256' },
            { name: 'sqrtPriceX96After', internalType: 'uint160', type: 'uint160' },
            { name: 'initializedTicksCrossed', internalType: 'uint32', type: 'uint32' },
            { name: 'gasEstimate', internalType: 'uint256', type: 'uint256' },
            { name: 'fee', internalType: 'uint16', type: 'uint16' },
        ],
    },
] as const

export const algerbaQuoterV2Address = '0x20dA24b5FaC067930Ced329A3457298172510Fe7' as const

export const algerbaQuoterV2Config = {
    address: algerbaQuoterV2Address,
    abi: algerbaQuoterV2ABI,
} as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FarmingCenter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const farmingCenterABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            {
                name: '_eternalFarming',
                internalType: 'contract IAlgebraEternalFarming',
                type: 'address',
            },
            {
                name: '_nonfungiblePositionManager',
                internalType: 'contract INonfungiblePositionManager',
                type: 'address',
            },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidityDelta', internalType: 'int256', type: 'int256' },
        ],
        name: 'applyLiquidityDelta',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'tokenId', internalType: 'uint256', type: 'uint256' }],
        name: 'burnPosition',
        outputs: [{ name: 'success', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'rewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'amountRequested', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'claimReward',
        outputs: [{ name: 'reward', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'collectRewards',
        outputs: [
            { name: 'reward', internalType: 'uint256', type: 'uint256' },
            { name: 'bonusReward', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
            { name: 'newVirtualPool', internalType: 'address', type: 'address' },
        ],
        name: 'connectVirtualPool',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidityDelta', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'decreaseLiquidity',
        outputs: [{ name: 'success', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
        name: 'deposits',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'enterFarming',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'eternalFarming',
        outputs: [{ name: '', internalType: 'contract IAlgebraEternalFarming', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            {
                name: 'key',
                internalType: 'struct IncentiveKey',
                type: 'tuple',
                components: [
                    {
                        name: 'rewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    {
                        name: 'bonusRewardToken',
                        internalType: 'contract IERC20Minimal',
                        type: 'address',
                    },
                    { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
                    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                ],
            },
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'exitFarming',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
        name: 'incentiveKeys',
        outputs: [
            { name: 'rewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
            { name: 'bonusRewardToken', internalType: 'contract IERC20Minimal', type: 'address' },
            { name: 'pool', internalType: 'contract IAlgebraPool', type: 'address' },
            { name: 'nonce', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tokenId', internalType: 'uint256', type: 'uint256' },
            { name: 'liquidityDelta', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'increaseLiquidity',
        outputs: [],
    },
    {
        stateMutability: 'payable',
        type: 'function',
        inputs: [{ name: 'data', internalType: 'bytes[]', type: 'bytes[]' }],
        name: 'multicall',
        outputs: [{ name: 'results', internalType: 'bytes[]', type: 'bytes[]' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'nonfungiblePositionManager',
        outputs: [
            { name: '', internalType: 'contract INonfungiblePositionManager', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', internalType: 'address', type: 'address' }],
        name: 'virtualPoolAddresses',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
] as const

export const farmingCenterAddress = '0xd2eD85385a2B884Bd77B5BBCE368C8A2cBdD3e27' as const

export const farmingCenterConfig = { address: farmingCenterAddress, abi: farmingCenterABI } as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// WrappedNative
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const wrappedNativeABI = [
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'name',
        outputs: [{ name: '', type: 'string' }],
    },
    {
        constant: false,
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'guy', type: 'address' },
            { name: 'wad', type: 'uint256' },
        ],
        name: 'approve',
        outputs: [{ name: '', type: 'bool' }],
    },
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'totalSupply',
        outputs: [{ name: '', type: 'uint256' }],
    },
    {
        constant: false,
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'src', type: 'address' },
            { name: 'dst', type: 'address' },
            { name: 'wad', type: 'uint256' },
        ],
        name: 'transferFrom',
        outputs: [{ name: '', type: 'bool' }],
    },
    {
        constant: false,
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'wad', type: 'uint256' }],
        name: 'withdraw',
        outputs: [],
    },
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'decimals',
        outputs: [{ name: '', type: 'uint8' }],
    },
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: '', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
    },
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'symbol',
        outputs: [{ name: '', type: 'string' }],
    },
    {
        constant: false,
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'dst', type: 'address' },
            { name: 'wad', type: 'uint256' },
        ],
        name: 'transfer',
        outputs: [{ name: '', type: 'bool' }],
    },
    {
        constant: false,
        payable: true,
        stateMutability: 'payable',
        type: 'function',
        inputs: [],
        name: 'deposit',
        outputs: [],
    },
    {
        constant: true,
        payable: false,
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: '', type: 'address' },
            { name: '', type: 'address' },
        ],
        name: 'allowance',
        outputs: [{ name: '', type: 'uint256' }],
    },
    { payable: true, stateMutability: 'payable', type: 'fallback' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'src', type: 'address', indexed: true },
            { name: 'guy', type: 'address', indexed: true },
            { name: 'wad', type: 'uint256', indexed: false },
        ],
        name: 'Approval',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'src', type: 'address', indexed: true },
            { name: 'dst', type: 'address', indexed: true },
            { name: 'wad', type: 'uint256', indexed: false },
        ],
        name: 'Transfer',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'dst', type: 'address', indexed: true },
            { name: 'wad', type: 'uint256', indexed: false },
        ],
        name: 'Deposit',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'src', type: 'address', indexed: true },
            { name: 'wad', type: 'uint256', indexed: false },
        ],
        name: 'Withdrawal',
    },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// gammaHypervisor
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const gammaHypervisorABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_pool', internalType: 'address', type: 'address' },
            { name: '_owner', internalType: 'address', type: 'address' },
            { name: 'name', internalType: 'string', type: 'string' },
            { name: 'symbol', internalType: 'string', type: 'string' },
        ],
    },
    { type: 'error', inputs: [], name: 'InvalidShortString' },
    {
        type: 'error',
        inputs: [{ name: 'str', internalType: 'string', type: 'string' }],
        name: 'StringTooLong',
    },
    { type: 'error', inputs: [], name: 'tickOutOfRange' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address', indexed: true },
            { name: 'spender', internalType: 'address', type: 'address', indexed: true },
            { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Approval',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
            { name: 'to', internalType: 'address', type: 'address', indexed: true },
            { name: 'shares', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Deposit',
    },
    { type: 'event', anonymous: false, inputs: [], name: 'EIP712DomainChanged' },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'tick', internalType: 'int24', type: 'int24', indexed: false },
            { name: 'totalAmount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'totalAmount1', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'feeAmount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'feeAmount1', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'totalSupply', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Rebalance',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [{ name: 'newFee', internalType: 'uint8', type: 'uint8', indexed: false }],
        name: 'SetFee',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'from', internalType: 'address', type: 'address', indexed: true },
            { name: 'to', internalType: 'address', type: 'address', indexed: true },
            { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Transfer',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'sender', internalType: 'address', type: 'address', indexed: true },
            { name: 'to', internalType: 'address', type: 'address', indexed: true },
            { name: 'shares', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'amount1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'Withdraw',
    },
    {
        type: 'event',
        anonymous: false,
        inputs: [
            { name: 'fee', internalType: 'uint8', type: 'uint8', indexed: false },
            { name: 'fees0', internalType: 'uint256', type: 'uint256', indexed: false },
            { name: 'fees1', internalType: 'uint256', type: 'uint256', indexed: false },
        ],
        name: 'ZeroBurn',
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'DOMAIN_SEPARATOR',
        outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'PRECISION',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tickLower', internalType: 'int24', type: 'int24' },
            { name: 'tickUpper', internalType: 'int24', type: 'int24' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
            { name: 'inMin', internalType: 'uint256[2]', type: 'uint256[2]' },
        ],
        name: 'addLiquidity',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
            { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
        name: 'algebraMintCallback',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address' },
            { name: 'spender', internalType: 'address', type: 'address' },
        ],
        name: 'allowance',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'amount', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'approve',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'baseLower',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'baseUpper',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'inMin', internalType: 'uint256[4]', type: 'uint256[4]' }],
        name: 'compound',
        outputs: [
            { name: 'baseToken0Owed', internalType: 'uint128', type: 'uint128' },
            { name: 'baseToken1Owed', internalType: 'uint128', type: 'uint128' },
            { name: 'limitToken0Owed', internalType: 'uint128', type: 'uint128' },
            { name: 'limitToken1Owed', internalType: 'uint128', type: 'uint128' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'currentTick',
        outputs: [{ name: 'tick', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'decimals',
        outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'subtractedValue', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'decreaseAllowance',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'deposit0', internalType: 'uint256', type: 'uint256' },
            { name: 'deposit1', internalType: 'uint256', type: 'uint256' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'inMin', internalType: 'uint256[4]', type: 'uint256[4]' },
        ],
        name: 'deposit',
        outputs: [{ name: 'shares', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'deposit0Max',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'deposit1Max',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'directDeposit',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'eip712Domain',
        outputs: [
            { name: 'fields', internalType: 'bytes1', type: 'bytes1' },
            { name: 'name', internalType: 'string', type: 'string' },
            { name: 'version', internalType: 'string', type: 'string' },
            { name: 'chainId', internalType: 'uint256', type: 'uint256' },
            { name: 'verifyingContract', internalType: 'address', type: 'address' },
            { name: 'salt', internalType: 'bytes32', type: 'bytes32' },
            { name: 'extensions', internalType: 'uint256[]', type: 'uint256[]' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'fee',
        outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'feeRecipient',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getBasePosition',
        outputs: [
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getLimitPosition',
        outputs: [
            { name: 'liquidity', internalType: 'uint128', type: 'uint128' },
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'getTotalAmounts',
        outputs: [
            { name: 'total0', internalType: 'uint256', type: 'uint256' },
            { name: 'total1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'addedValue', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'increaseAllowance',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'limitLower',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'limitUpper',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'maxTotalSupply',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'name',
        outputs: [{ name: '', internalType: 'string', type: 'string' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [{ name: 'owner', internalType: 'address', type: 'address' }],
        name: 'nonces',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'owner',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'owner', internalType: 'address', type: 'address' },
            { name: 'spender', internalType: 'address', type: 'address' },
            { name: 'value', internalType: 'uint256', type: 'uint256' },
            { name: 'deadline', internalType: 'uint256', type: 'uint256' },
            { name: 'v', internalType: 'uint8', type: 'uint8' },
            { name: 'r', internalType: 'bytes32', type: 'bytes32' },
            { name: 's', internalType: 'bytes32', type: 'bytes32' },
        ],
        name: 'permit',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'pool',
        outputs: [{ name: '', internalType: 'contract IAlgebraPool', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'tickLower', internalType: 'int24', type: 'int24' },
            { name: 'tickUpper', internalType: 'int24', type: 'int24' },
            { name: 'shares', internalType: 'uint128', type: 'uint128' },
            { name: 'amountMin', internalType: 'uint256[2]', type: 'uint256[2]' },
        ],
        name: 'pullLiquidity',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: '_baseLower', internalType: 'int24', type: 'int24' },
            { name: '_baseUpper', internalType: 'int24', type: 'int24' },
            { name: '_limitLower', internalType: 'int24', type: 'int24' },
            { name: '_limitUpper', internalType: 'int24', type: 'int24' },
            { name: '_feeRecipient', internalType: 'address', type: 'address' },
            { name: 'inMin', internalType: 'uint256[4]', type: 'uint256[4]' },
            { name: 'outMin', internalType: 'uint256[4]', type: 'uint256[4]' },
        ],
        name: 'rebalance',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'removeWhitelisted',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newFee', internalType: 'uint8', type: 'uint8' }],
        name: 'setFee',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newTickSpacing', internalType: 'int24', type: 'int24' }],
        name: 'setTickSpacing',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: '_address', internalType: 'address', type: 'address' }],
        name: 'setWhitelist',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'symbol',
        outputs: [{ name: '', internalType: 'string', type: 'string' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'tickSpacing',
        outputs: [{ name: '', internalType: 'int24', type: 'int24' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [],
        name: 'toggleDirectDeposit',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'token0',
        outputs: [{ name: '', internalType: 'contract IERC20', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'token1',
        outputs: [{ name: '', internalType: 'contract IERC20', type: 'address' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'totalSupply',
        outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'amount', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'transfer',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'amount', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'transferFrom',
        outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newOwner', internalType: 'address', type: 'address' }],
        name: 'transferOwnership',
        outputs: [],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'whitelistedAddress',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'shares', internalType: 'uint256', type: 'uint256' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'from', internalType: 'address', type: 'address' },
            { name: 'minAmounts', internalType: 'uint256[4]', type: 'uint256[4]' },
        ],
        name: 'withdraw',
        outputs: [
            { name: 'amount0', internalType: 'uint256', type: 'uint256' },
            { name: 'amount1', internalType: 'uint256', type: 'uint256' },
        ],
    },
] as const

export const gammaHypervisorAddress = '0x0000000000000000000000000000000000000000' as const

export const gammaHypervisorConfig = {
    address: gammaHypervisorAddress,
    abi: gammaHypervisorABI,
} as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// gammaUniProxy
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const gammaUniProxyABI = [
    {
        stateMutability: 'nonpayable',
        type: 'constructor',
        inputs: [
            { name: '_clearance', internalType: 'address', type: 'address' },
            { name: '_owner', internalType: 'address', type: 'address' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'clearance',
        outputs: [{ name: '', internalType: 'contract IClearing', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [
            { name: 'deposit0', internalType: 'uint256', type: 'uint256' },
            { name: 'deposit1', internalType: 'uint256', type: 'uint256' },
            { name: 'to', internalType: 'address', type: 'address' },
            { name: 'pos', internalType: 'address', type: 'address' },
            { name: 'minIn', internalType: 'uint256[4]', type: 'uint256[4]' },
        ],
        name: 'deposit',
        outputs: [{ name: 'shares', internalType: 'uint256', type: 'uint256' }],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [
            { name: 'pos', internalType: 'address', type: 'address' },
            { name: 'token', internalType: 'address', type: 'address' },
            { name: '_deposit', internalType: 'uint256', type: 'uint256' },
        ],
        name: 'getDepositAmount',
        outputs: [
            { name: 'amountStart', internalType: 'uint256', type: 'uint256' },
            { name: 'amountEnd', internalType: 'uint256', type: 'uint256' },
        ],
    },
    {
        stateMutability: 'view',
        type: 'function',
        inputs: [],
        name: 'owner',
        outputs: [{ name: '', internalType: 'address', type: 'address' }],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newClearance', internalType: 'address', type: 'address' }],
        name: 'transferClearance',
        outputs: [],
    },
    {
        stateMutability: 'nonpayable',
        type: 'function',
        inputs: [{ name: 'newOwner', internalType: 'address', type: 'address' }],
        name: 'transferOwnership',
        outputs: [],
    },
] as const

export const gammaUniProxyAddress = '0x8a9570ec97534277Ade6e46d100939FbCE4968f0' as const

export const gammaUniProxyConfig = { address: gammaUniProxyAddress, abi: gammaUniProxyABI } as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Core
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function getAlgebraBasePlugin(config: Omit<GetContractArgs, 'abi'>) {
    return getContract({ abi: algebraBasePluginABI, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function readAlgebraBasePlugin<
    TAbi extends readonly unknown[] = typeof algebraBasePluginABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return readContract({ abi: algebraBasePluginABI, ...config } as unknown as ReadContractConfig<
        TAbi,
        TFunctionName
    >)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function writeAlgebraBasePlugin<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof algebraBasePluginABI, TFunctionName>, 'abi'>
        | Omit<WriteContractUnpreparedArgs<typeof algebraBasePluginABI, TFunctionName>, 'abi'>,
) {
    return writeContract({ abi: algebraBasePluginABI, ...config } as unknown as WriteContractArgs<
        typeof algebraBasePluginABI,
        TFunctionName
    >)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function prepareWriteAlgebraBasePlugin<
    TAbi extends readonly unknown[] = typeof algebraBasePluginABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return prepareWriteContract({
        abi: algebraBasePluginABI,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function getAlgebraEternalFarming(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function readAlgebraEternalFarming<
    TAbi extends readonly unknown[] = typeof algebraEternalFarmingABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function writeAlgebraEternalFarming<TFunctionName extends string>(
    config:
        | Omit<
              WriteContractPreparedArgs<typeof algebraEternalFarmingABI, TFunctionName>,
              'abi' | 'address'
          >
        | Omit<
              WriteContractUnpreparedArgs<typeof algebraEternalFarmingABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof algebraEternalFarmingABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function prepareWriteAlgebraEternalFarming<
    TAbi extends readonly unknown[] = typeof algebraEternalFarmingABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function getAlgebraFactory(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: algebraFactoryABI, address: algebraFactoryAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function readAlgebraFactory<
    TAbi extends readonly unknown[] = typeof algebraFactoryABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function writeAlgebraFactory<TFunctionName extends string>(
    config:
        | Omit<
              WriteContractPreparedArgs<typeof algebraFactoryABI, TFunctionName>,
              'abi' | 'address'
          >
        | Omit<
              WriteContractUnpreparedArgs<typeof algebraFactoryABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof algebraFactoryABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function prepareWriteAlgebraFactory<
    TAbi extends readonly unknown[] = typeof algebraFactoryABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function getAlgebraPool(config: Omit<GetContractArgs, 'abi'>) {
    return getContract({ abi: algebraPoolABI, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function readAlgebraPool<
    TAbi extends readonly unknown[] = typeof algebraPoolABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return readContract({ abi: algebraPoolABI, ...config } as unknown as ReadContractConfig<
        TAbi,
        TFunctionName
    >)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function writeAlgebraPool<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof algebraPoolABI, TFunctionName>, 'abi'>
        | Omit<WriteContractUnpreparedArgs<typeof algebraPoolABI, TFunctionName>, 'abi'>,
) {
    return writeContract({ abi: algebraPoolABI, ...config } as unknown as WriteContractArgs<
        typeof algebraPoolABI,
        TFunctionName
    >)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function prepareWriteAlgebraPool<
    TAbi extends readonly unknown[] = typeof algebraPoolABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return prepareWriteContract({
        abi: algebraPoolABI,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function getAlgebraPositionManager(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function readAlgebraPositionManager<
    TAbi extends readonly unknown[] = typeof algebraPositionManagerABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function writeAlgebraPositionManager<TFunctionName extends string>(
    config:
        | Omit<
              WriteContractPreparedArgs<typeof algebraPositionManagerABI, TFunctionName>,
              'abi' | 'address'
          >
        | Omit<
              WriteContractUnpreparedArgs<typeof algebraPositionManagerABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof algebraPositionManagerABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function prepareWriteAlgebraPositionManager<
    TAbi extends readonly unknown[] = typeof algebraPositionManagerABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function getAlgebraQuoter(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: algebraQuoterABI, address: algebraQuoterAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function readAlgebraQuoter<
    TAbi extends readonly unknown[] = typeof algebraQuoterABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function writeAlgebraQuoter<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof algebraQuoterABI, TFunctionName>, 'abi' | 'address'>
        | Omit<
              WriteContractUnpreparedArgs<typeof algebraQuoterABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof algebraQuoterABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function prepareWriteAlgebraQuoter<
    TAbi extends readonly unknown[] = typeof algebraQuoterABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function getAlgebraRouter(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: algebraRouterABI, address: algebraRouterAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function readAlgebraRouter<
    TAbi extends readonly unknown[] = typeof algebraRouterABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function writeAlgebraRouter<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof algebraRouterABI, TFunctionName>, 'abi' | 'address'>
        | Omit<
              WriteContractUnpreparedArgs<typeof algebraRouterABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof algebraRouterABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function prepareWriteAlgebraRouter<
    TAbi extends readonly unknown[] = typeof algebraRouterABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function getAlgerbaQuoterV2(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: algerbaQuoterV2ABI, address: algerbaQuoterV2Address, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function readAlgerbaQuoterV2<
    TAbi extends readonly unknown[] = typeof algerbaQuoterV2ABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function writeAlgerbaQuoterV2<TFunctionName extends string>(
    config:
        | Omit<
              WriteContractPreparedArgs<typeof algerbaQuoterV2ABI, TFunctionName>,
              'abi' | 'address'
          >
        | Omit<
              WriteContractUnpreparedArgs<typeof algerbaQuoterV2ABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as unknown as WriteContractArgs<typeof algerbaQuoterV2ABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function prepareWriteAlgerbaQuoterV2<
    TAbi extends readonly unknown[] = typeof algerbaQuoterV2ABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function getFarmingCenter(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: farmingCenterABI, address: farmingCenterAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function readFarmingCenter<
    TAbi extends readonly unknown[] = typeof farmingCenterABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function writeFarmingCenter<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof farmingCenterABI, TFunctionName>, 'abi' | 'address'>
        | Omit<
              WriteContractUnpreparedArgs<typeof farmingCenterABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof farmingCenterABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function prepareWriteFarmingCenter<
    TAbi extends readonly unknown[] = typeof farmingCenterABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function getWrappedNative(config: Omit<GetContractArgs, 'abi'>) {
    return getContract({ abi: wrappedNativeABI, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function readWrappedNative<
    TAbi extends readonly unknown[] = typeof wrappedNativeABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return readContract({ abi: wrappedNativeABI, ...config } as unknown as ReadContractConfig<
        TAbi,
        TFunctionName
    >)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function writeWrappedNative<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof wrappedNativeABI, TFunctionName>, 'abi'>
        | Omit<WriteContractUnpreparedArgs<typeof wrappedNativeABI, TFunctionName>, 'abi'>,
) {
    return writeContract({ abi: wrappedNativeABI, ...config } as unknown as WriteContractArgs<
        typeof wrappedNativeABI,
        TFunctionName
    >)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function prepareWriteWrappedNative<
    TAbi extends readonly unknown[] = typeof wrappedNativeABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi'>) {
    return prepareWriteContract({
        abi: wrappedNativeABI,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function getGammaHypervisor(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: gammaHypervisorABI, address: gammaHypervisorAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function readGammaHypervisor<
    TAbi extends readonly unknown[] = typeof gammaHypervisorABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function writeGammaHypervisor<TFunctionName extends string>(
    config:
        | Omit<
              WriteContractPreparedArgs<typeof gammaHypervisorABI, TFunctionName>,
              'abi' | 'address'
          >
        | Omit<
              WriteContractUnpreparedArgs<typeof gammaHypervisorABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof gammaHypervisorABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function prepareWriteGammaHypervisor<
    TAbi extends readonly unknown[] = typeof gammaHypervisorABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link getContract}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function getGammaUniProxy(config: Omit<GetContractArgs, 'abi' | 'address'>) {
    return getContract({ abi: gammaUniProxyABI, address: gammaUniProxyAddress, ...config })
}

/**
 * Wraps __{@link readContract}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function readGammaUniProxy<
    TAbi extends readonly unknown[] = typeof gammaUniProxyABI,
    TFunctionName extends string = string,
>(config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return readContract({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as unknown as ReadContractConfig<TAbi, TFunctionName>)
}

/**
 * Wraps __{@link writeContract}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function writeGammaUniProxy<TFunctionName extends string>(
    config:
        | Omit<WriteContractPreparedArgs<typeof gammaUniProxyABI, TFunctionName>, 'abi' | 'address'>
        | Omit<
              WriteContractUnpreparedArgs<typeof gammaUniProxyABI, TFunctionName>,
              'abi' | 'address'
          >,
) {
    return writeContract({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as unknown as WriteContractArgs<typeof gammaUniProxyABI, TFunctionName>)
}

/**
 * Wraps __{@link prepareWriteContract}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function prepareWriteGammaUniProxy<
    TAbi extends readonly unknown[] = typeof gammaUniProxyABI,
    TFunctionName extends string = string,
>(config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi' | 'address'>) {
    return prepareWriteContract({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// React
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function useAlgebraBasePluginRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi'
    > = {} as any,
) {
    return useContractRead({ abi: algebraBasePluginABI, ...config } as UseContractReadConfig<
        typeof algebraBasePluginABI,
        TFunctionName,
        TSelectData
    >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"ALGEBRA_BASE_PLUGIN_MANAGER"`.
 */
export function useAlgebraBasePluginAlgebraBasePluginManager<
    TFunctionName extends 'ALGEBRA_BASE_PLUGIN_MANAGER',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'ALGEBRA_BASE_PLUGIN_MANAGER',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"defaultPluginConfig"`.
 */
export function useAlgebraBasePluginDefaultPluginConfig<
    TFunctionName extends 'defaultPluginConfig',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'defaultPluginConfig',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"feeConfig"`.
 */
export function useAlgebraBasePluginFeeConfig<
    TFunctionName extends 'feeConfig',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'feeConfig',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"getCurrentFee"`.
 */
export function useAlgebraBasePluginGetCurrentFee<
    TFunctionName extends 'getCurrentFee',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'getCurrentFee',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"getSingleTimepoint"`.
 */
export function useAlgebraBasePluginGetSingleTimepoint<
    TFunctionName extends 'getSingleTimepoint',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'getSingleTimepoint',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"getTimepoints"`.
 */
export function useAlgebraBasePluginGetTimepoints<
    TFunctionName extends 'getTimepoints',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'getTimepoints',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"incentive"`.
 */
export function useAlgebraBasePluginIncentive<
    TFunctionName extends 'incentive',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'incentive',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"isIncentiveConnected"`.
 */
export function useAlgebraBasePluginIsIncentiveConnected<
    TFunctionName extends 'isIncentiveConnected',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'isIncentiveConnected',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"isInitialized"`.
 */
export function useAlgebraBasePluginIsInitialized<
    TFunctionName extends 'isInitialized',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'isInitialized',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"lastTimepointTimestamp"`.
 */
export function useAlgebraBasePluginLastTimepointTimestamp<
    TFunctionName extends 'lastTimepointTimestamp',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'lastTimepointTimestamp',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"limitOrderPlugin"`.
 */
export function useAlgebraBasePluginLimitOrderPlugin<
    TFunctionName extends 'limitOrderPlugin',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'limitOrderPlugin',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"pool"`.
 */
export function useAlgebraBasePluginPool<
    TFunctionName extends 'pool',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'pool',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"timepointIndex"`.
 */
export function useAlgebraBasePluginTimepointIndex<
    TFunctionName extends 'timepointIndex',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'timepointIndex',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"timepoints"`.
 */
export function useAlgebraBasePluginTimepoints<
    TFunctionName extends 'timepoints',
    TSelectData = ReadContractResult<typeof algebraBasePluginABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraBasePluginABI,
        functionName: 'timepoints',
        ...config,
    } as UseContractReadConfig<typeof algebraBasePluginABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function useAlgebraBasePluginWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraBasePluginABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraBasePluginABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, TFunctionName, TMode>({
        abi: algebraBasePluginABI,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterFlash"`.
 */
export function useAlgebraBasePluginAfterFlash<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'afterFlash'
              >['request']['abi'],
              'afterFlash',
              TMode
          > & { functionName?: 'afterFlash' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'afterFlash', TMode> & {
              abi?: never
              functionName?: 'afterFlash'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'afterFlash', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'afterFlash',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterInitialize"`.
 */
export function useAlgebraBasePluginAfterInitialize<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'afterInitialize'
              >['request']['abi'],
              'afterInitialize',
              TMode
          > & { functionName?: 'afterInitialize' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'afterInitialize', TMode> & {
              abi?: never
              functionName?: 'afterInitialize'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'afterInitialize', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'afterInitialize',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterModifyPosition"`.
 */
export function useAlgebraBasePluginAfterModifyPosition<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'afterModifyPosition'
              >['request']['abi'],
              'afterModifyPosition',
              TMode
          > & { functionName?: 'afterModifyPosition' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'afterModifyPosition', TMode> & {
              abi?: never
              functionName?: 'afterModifyPosition'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'afterModifyPosition', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'afterModifyPosition',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterSwap"`.
 */
export function useAlgebraBasePluginAfterSwap<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'afterSwap'
              >['request']['abi'],
              'afterSwap',
              TMode
          > & { functionName?: 'afterSwap' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'afterSwap', TMode> & {
              abi?: never
              functionName?: 'afterSwap'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'afterSwap', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'afterSwap',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeFlash"`.
 */
export function useAlgebraBasePluginBeforeFlash<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'beforeFlash'
              >['request']['abi'],
              'beforeFlash',
              TMode
          > & { functionName?: 'beforeFlash' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'beforeFlash', TMode> & {
              abi?: never
              functionName?: 'beforeFlash'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'beforeFlash', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'beforeFlash',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeInitialize"`.
 */
export function useAlgebraBasePluginBeforeInitialize<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'beforeInitialize'
              >['request']['abi'],
              'beforeInitialize',
              TMode
          > & { functionName?: 'beforeInitialize' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'beforeInitialize', TMode> & {
              abi?: never
              functionName?: 'beforeInitialize'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'beforeInitialize', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'beforeInitialize',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeModifyPosition"`.
 */
export function useAlgebraBasePluginBeforeModifyPosition<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'beforeModifyPosition'
              >['request']['abi'],
              'beforeModifyPosition',
              TMode
          > & { functionName?: 'beforeModifyPosition' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'beforeModifyPosition', TMode> & {
              abi?: never
              functionName?: 'beforeModifyPosition'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'beforeModifyPosition', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'beforeModifyPosition',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeSwap"`.
 */
export function useAlgebraBasePluginBeforeSwap<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'beforeSwap'
              >['request']['abi'],
              'beforeSwap',
              TMode
          > & { functionName?: 'beforeSwap' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'beforeSwap', TMode> & {
              abi?: never
              functionName?: 'beforeSwap'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'beforeSwap', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'beforeSwap',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"changeFeeConfiguration"`.
 */
export function useAlgebraBasePluginChangeFeeConfiguration<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'changeFeeConfiguration'
              >['request']['abi'],
              'changeFeeConfiguration',
              TMode
          > & { functionName?: 'changeFeeConfiguration' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'changeFeeConfiguration', TMode> & {
              abi?: never
              functionName?: 'changeFeeConfiguration'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'changeFeeConfiguration', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'changeFeeConfiguration',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"initialize"`.
 */
export function useAlgebraBasePluginInitialize<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'initialize'
              >['request']['abi'],
              'initialize',
              TMode
          > & { functionName?: 'initialize' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'initialize', TMode> & {
              abi?: never
              functionName?: 'initialize'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'initialize', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'initialize',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"prepayTimepointsStorageSlots"`.
 */
export function useAlgebraBasePluginPrepayTimepointsStorageSlots<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'prepayTimepointsStorageSlots'
              >['request']['abi'],
              'prepayTimepointsStorageSlots',
              TMode
          > & { functionName?: 'prepayTimepointsStorageSlots' }
        : UseContractWriteConfig<
              typeof algebraBasePluginABI,
              'prepayTimepointsStorageSlots',
              TMode
          > & {
              abi?: never
              functionName?: 'prepayTimepointsStorageSlots'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'prepayTimepointsStorageSlots', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'prepayTimepointsStorageSlots',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"setIncentive"`.
 */
export function useAlgebraBasePluginSetIncentive<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'setIncentive'
              >['request']['abi'],
              'setIncentive',
              TMode
          > & { functionName?: 'setIncentive' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'setIncentive', TMode> & {
              abi?: never
              functionName?: 'setIncentive'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'setIncentive', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'setIncentive',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"setLimitOrderPlugin"`.
 */
export function useAlgebraBasePluginSetLimitOrderPlugin<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraBasePluginABI,
                  'setLimitOrderPlugin'
              >['request']['abi'],
              'setLimitOrderPlugin',
              TMode
          > & { functionName?: 'setLimitOrderPlugin' }
        : UseContractWriteConfig<typeof algebraBasePluginABI, 'setLimitOrderPlugin', TMode> & {
              abi?: never
              functionName?: 'setLimitOrderPlugin'
          } = {} as any,
) {
    return useContractWrite<typeof algebraBasePluginABI, 'setLimitOrderPlugin', TMode>({
        abi: algebraBasePluginABI,
        functionName: 'setLimitOrderPlugin',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__.
 */
export function usePrepareAlgebraBasePluginWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, TFunctionName>,
        'abi'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterFlash"`.
 */
export function usePrepareAlgebraBasePluginAfterFlash(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterFlash'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'afterFlash',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterFlash'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterInitialize"`.
 */
export function usePrepareAlgebraBasePluginAfterInitialize(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterInitialize'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'afterInitialize',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterInitialize'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterModifyPosition"`.
 */
export function usePrepareAlgebraBasePluginAfterModifyPosition(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterModifyPosition'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'afterModifyPosition',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterModifyPosition'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"afterSwap"`.
 */
export function usePrepareAlgebraBasePluginAfterSwap(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterSwap'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'afterSwap',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'afterSwap'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeFlash"`.
 */
export function usePrepareAlgebraBasePluginBeforeFlash(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeFlash'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'beforeFlash',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeFlash'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeInitialize"`.
 */
export function usePrepareAlgebraBasePluginBeforeInitialize(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeInitialize'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'beforeInitialize',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeInitialize'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeModifyPosition"`.
 */
export function usePrepareAlgebraBasePluginBeforeModifyPosition(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeModifyPosition'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'beforeModifyPosition',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeModifyPosition'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"beforeSwap"`.
 */
export function usePrepareAlgebraBasePluginBeforeSwap(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeSwap'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'beforeSwap',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'beforeSwap'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"changeFeeConfiguration"`.
 */
export function usePrepareAlgebraBasePluginChangeFeeConfiguration(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'changeFeeConfiguration'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'changeFeeConfiguration',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'changeFeeConfiguration'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"initialize"`.
 */
export function usePrepareAlgebraBasePluginInitialize(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'initialize'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'initialize',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'initialize'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"prepayTimepointsStorageSlots"`.
 */
export function usePrepareAlgebraBasePluginPrepayTimepointsStorageSlots(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'prepayTimepointsStorageSlots'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'prepayTimepointsStorageSlots',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'prepayTimepointsStorageSlots'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"setIncentive"`.
 */
export function usePrepareAlgebraBasePluginSetIncentive(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'setIncentive'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'setIncentive',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'setIncentive'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraBasePluginABI}__ and `functionName` set to `"setLimitOrderPlugin"`.
 */
export function usePrepareAlgebraBasePluginSetLimitOrderPlugin(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'setLimitOrderPlugin'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraBasePluginABI,
        functionName: 'setLimitOrderPlugin',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraBasePluginABI, 'setLimitOrderPlugin'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function useAlgebraEternalFarmingRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"FARMINGS_ADMINISTRATOR_ROLE"`.
 */
export function useAlgebraEternalFarmingFarmingsAdministratorRole<
    TFunctionName extends 'FARMINGS_ADMINISTRATOR_ROLE',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'FARMINGS_ADMINISTRATOR_ROLE',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"INCENTIVE_MAKER_ROLE"`.
 */
export function useAlgebraEternalFarmingIncentiveMakerRole<
    TFunctionName extends 'INCENTIVE_MAKER_ROLE',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'INCENTIVE_MAKER_ROLE',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"farmingCenter"`.
 */
export function useAlgebraEternalFarmingFarmingCenter<
    TFunctionName extends 'farmingCenter',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'farmingCenter',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"farms"`.
 */
export function useAlgebraEternalFarmingFarms<
    TFunctionName extends 'farms',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'farms',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"getRewardInfo"`.
 */
export function useAlgebraEternalFarmingGetRewardInfo<
    TFunctionName extends 'getRewardInfo',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'getRewardInfo',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"incentives"`.
 */
export function useAlgebraEternalFarmingIncentives<
    TFunctionName extends 'incentives',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'incentives',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"isEmergencyWithdrawActivated"`.
 */
export function useAlgebraEternalFarmingIsEmergencyWithdrawActivated<
    TFunctionName extends 'isEmergencyWithdrawActivated',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'isEmergencyWithdrawActivated',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"isIncentiveDeactivated"`.
 */
export function useAlgebraEternalFarmingIsIncentiveDeactivated<
    TFunctionName extends 'isIncentiveDeactivated',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'isIncentiveDeactivated',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"nonfungiblePositionManager"`.
 */
export function useAlgebraEternalFarmingNonfungiblePositionManager<
    TFunctionName extends 'nonfungiblePositionManager',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'nonfungiblePositionManager',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"numOfIncentives"`.
 */
export function useAlgebraEternalFarmingNumOfIncentives<
    TFunctionName extends 'numOfIncentives',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'numOfIncentives',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"rewards"`.
 */
export function useAlgebraEternalFarmingRewards<
    TFunctionName extends 'rewards',
    TSelectData = ReadContractResult<typeof algebraEternalFarmingABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'rewards',
        ...config,
    } as UseContractReadConfig<typeof algebraEternalFarmingABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function useAlgebraEternalFarmingWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraEternalFarmingABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, TFunctionName, TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"addRewards"`.
 */
export function useAlgebraEternalFarmingAddRewards<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'addRewards'
              >['request']['abi'],
              'addRewards',
              TMode
          > & { functionName?: 'addRewards' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'addRewards', TMode> & {
              abi?: never
              functionName?: 'addRewards'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'addRewards', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'addRewards',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"claimReward"`.
 */
export function useAlgebraEternalFarmingClaimReward<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'claimReward'
              >['request']['abi'],
              'claimReward',
              TMode
          > & { functionName?: 'claimReward' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'claimReward', TMode> & {
              abi?: never
              functionName?: 'claimReward'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'claimReward', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'claimReward',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"claimRewardFrom"`.
 */
export function useAlgebraEternalFarmingClaimRewardFrom<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'claimRewardFrom'
              >['request']['abi'],
              'claimRewardFrom',
              TMode
          > & { functionName?: 'claimRewardFrom' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'claimRewardFrom', TMode> & {
              abi?: never
              functionName?: 'claimRewardFrom'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'claimRewardFrom', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'claimRewardFrom',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"collectRewards"`.
 */
export function useAlgebraEternalFarmingCollectRewards<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'collectRewards'
              >['request']['abi'],
              'collectRewards',
              TMode
          > & { functionName?: 'collectRewards' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'collectRewards', TMode> & {
              abi?: never
              functionName?: 'collectRewards'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'collectRewards', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'collectRewards',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"createEternalFarming"`.
 */
export function useAlgebraEternalFarmingCreateEternalFarming<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'createEternalFarming'
              >['request']['abi'],
              'createEternalFarming',
              TMode
          > & { functionName?: 'createEternalFarming' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'createEternalFarming', TMode> & {
              abi?: never
              functionName?: 'createEternalFarming'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'createEternalFarming', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'createEternalFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"deactivateIncentive"`.
 */
export function useAlgebraEternalFarmingDeactivateIncentive<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'deactivateIncentive'
              >['request']['abi'],
              'deactivateIncentive',
              TMode
          > & { functionName?: 'deactivateIncentive' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'deactivateIncentive', TMode> & {
              abi?: never
              functionName?: 'deactivateIncentive'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'deactivateIncentive', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'deactivateIncentive',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"decreaseRewardsAmount"`.
 */
export function useAlgebraEternalFarmingDecreaseRewardsAmount<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'decreaseRewardsAmount'
              >['request']['abi'],
              'decreaseRewardsAmount',
              TMode
          > & { functionName?: 'decreaseRewardsAmount' }
        : UseContractWriteConfig<
              typeof algebraEternalFarmingABI,
              'decreaseRewardsAmount',
              TMode
          > & {
              abi?: never
              functionName?: 'decreaseRewardsAmount'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'decreaseRewardsAmount', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'decreaseRewardsAmount',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"enterFarming"`.
 */
export function useAlgebraEternalFarmingEnterFarming<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'enterFarming'
              >['request']['abi'],
              'enterFarming',
              TMode
          > & { functionName?: 'enterFarming' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'enterFarming', TMode> & {
              abi?: never
              functionName?: 'enterFarming'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'enterFarming', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'enterFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"exitFarming"`.
 */
export function useAlgebraEternalFarmingExitFarming<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'exitFarming'
              >['request']['abi'],
              'exitFarming',
              TMode
          > & { functionName?: 'exitFarming' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'exitFarming', TMode> & {
              abi?: never
              functionName?: 'exitFarming'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'exitFarming', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'exitFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setEmergencyWithdrawStatus"`.
 */
export function useAlgebraEternalFarmingSetEmergencyWithdrawStatus<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'setEmergencyWithdrawStatus'
              >['request']['abi'],
              'setEmergencyWithdrawStatus',
              TMode
          > & { functionName?: 'setEmergencyWithdrawStatus' }
        : UseContractWriteConfig<
              typeof algebraEternalFarmingABI,
              'setEmergencyWithdrawStatus',
              TMode
          > & {
              abi?: never
              functionName?: 'setEmergencyWithdrawStatus'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'setEmergencyWithdrawStatus', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setEmergencyWithdrawStatus',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setFarmingCenterAddress"`.
 */
export function useAlgebraEternalFarmingSetFarmingCenterAddress<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'setFarmingCenterAddress'
              >['request']['abi'],
              'setFarmingCenterAddress',
              TMode
          > & { functionName?: 'setFarmingCenterAddress' }
        : UseContractWriteConfig<
              typeof algebraEternalFarmingABI,
              'setFarmingCenterAddress',
              TMode
          > & {
              abi?: never
              functionName?: 'setFarmingCenterAddress'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'setFarmingCenterAddress', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setFarmingCenterAddress',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setRates"`.
 */
export function useAlgebraEternalFarmingSetRates<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraEternalFarmingABI,
                  'setRates'
              >['request']['abi'],
              'setRates',
              TMode
          > & { functionName?: 'setRates' }
        : UseContractWriteConfig<typeof algebraEternalFarmingABI, 'setRates', TMode> & {
              abi?: never
              functionName?: 'setRates'
          } = {} as any,
) {
    return useContractWrite<typeof algebraEternalFarmingABI, 'setRates', TMode>({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setRates',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__.
 */
export function usePrepareAlgebraEternalFarmingWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"addRewards"`.
 */
export function usePrepareAlgebraEternalFarmingAddRewards(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'addRewards'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'addRewards',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'addRewards'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"claimReward"`.
 */
export function usePrepareAlgebraEternalFarmingClaimReward(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'claimReward'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'claimReward',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'claimReward'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"claimRewardFrom"`.
 */
export function usePrepareAlgebraEternalFarmingClaimRewardFrom(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'claimRewardFrom'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'claimRewardFrom',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'claimRewardFrom'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"collectRewards"`.
 */
export function usePrepareAlgebraEternalFarmingCollectRewards(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'collectRewards'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'collectRewards',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'collectRewards'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"createEternalFarming"`.
 */
export function usePrepareAlgebraEternalFarmingCreateEternalFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'createEternalFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'createEternalFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'createEternalFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"deactivateIncentive"`.
 */
export function usePrepareAlgebraEternalFarmingDeactivateIncentive(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'deactivateIncentive'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'deactivateIncentive',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'deactivateIncentive'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"decreaseRewardsAmount"`.
 */
export function usePrepareAlgebraEternalFarmingDecreaseRewardsAmount(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'decreaseRewardsAmount'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'decreaseRewardsAmount',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'decreaseRewardsAmount'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"enterFarming"`.
 */
export function usePrepareAlgebraEternalFarmingEnterFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'enterFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'enterFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'enterFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"exitFarming"`.
 */
export function usePrepareAlgebraEternalFarmingExitFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'exitFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'exitFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'exitFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setEmergencyWithdrawStatus"`.
 */
export function usePrepareAlgebraEternalFarmingSetEmergencyWithdrawStatus(
    config: Omit<
        UsePrepareContractWriteConfig<
            typeof algebraEternalFarmingABI,
            'setEmergencyWithdrawStatus'
        >,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setEmergencyWithdrawStatus',
        ...config,
    } as UsePrepareContractWriteConfig<
        typeof algebraEternalFarmingABI,
        'setEmergencyWithdrawStatus'
    >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setFarmingCenterAddress"`.
 */
export function usePrepareAlgebraEternalFarmingSetFarmingCenterAddress(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'setFarmingCenterAddress'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setFarmingCenterAddress',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'setFarmingCenterAddress'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraEternalFarmingABI}__ and `functionName` set to `"setRates"`.
 */
export function usePrepareAlgebraEternalFarmingSetRates(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'setRates'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraEternalFarmingABI,
        address: algebraEternalFarmingAddress,
        functionName: 'setRates',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraEternalFarmingABI, 'setRates'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function useAlgebraFactoryRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"DEFAULT_ADMIN_ROLE"`.
 */
export function useAlgebraFactoryDefaultAdminRole<
    TFunctionName extends 'DEFAULT_ADMIN_ROLE',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'DEFAULT_ADMIN_ROLE',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"baseFeeConfiguration"`.
 */
export function useAlgebraFactoryBaseFeeConfiguration<
    TFunctionName extends 'baseFeeConfiguration',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'baseFeeConfiguration',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"communityVault"`.
 */
export function useAlgebraFactoryCommunityVault<
    TFunctionName extends 'communityVault',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'communityVault',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"defaultCommunityFee"`.
 */
export function useAlgebraFactoryDefaultCommunityFee<
    TFunctionName extends 'defaultCommunityFee',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'defaultCommunityFee',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"farmingAddress"`.
 */
export function useAlgebraFactoryFarmingAddress<
    TFunctionName extends 'farmingAddress',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'farmingAddress',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"getRoleAdmin"`.
 */
export function useAlgebraFactoryGetRoleAdmin<
    TFunctionName extends 'getRoleAdmin',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'getRoleAdmin',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"getRoleMember"`.
 */
export function useAlgebraFactoryGetRoleMember<
    TFunctionName extends 'getRoleMember',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'getRoleMember',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"getRoleMemberCount"`.
 */
export function useAlgebraFactoryGetRoleMemberCount<
    TFunctionName extends 'getRoleMemberCount',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'getRoleMemberCount',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"hasRole"`.
 */
export function useAlgebraFactoryHasRole<
    TFunctionName extends 'hasRole',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'hasRole',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"hasRoleOrOwner"`.
 */
export function useAlgebraFactoryHasRoleOrOwner<
    TFunctionName extends 'hasRoleOrOwner',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'hasRoleOrOwner',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"owner"`.
 */
export function useAlgebraFactoryOwner<
    TFunctionName extends 'owner',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'owner',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"pendingOwner"`.
 */
export function useAlgebraFactoryPendingOwner<
    TFunctionName extends 'pendingOwner',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'pendingOwner',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"poolByPair"`.
 */
export function useAlgebraFactoryPoolByPair<
    TFunctionName extends 'poolByPair',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'poolByPair',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"poolDeployer"`.
 */
export function useAlgebraFactoryPoolDeployer<
    TFunctionName extends 'poolDeployer',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'poolDeployer',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"renounceOwnershipStartTimestamp"`.
 */
export function useAlgebraFactoryRenounceOwnershipStartTimestamp<
    TFunctionName extends 'renounceOwnershipStartTimestamp',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'renounceOwnershipStartTimestamp',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"supportsInterface"`.
 */
export function useAlgebraFactorySupportsInterface<
    TFunctionName extends 'supportsInterface',
    TSelectData = ReadContractResult<typeof algebraFactoryABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'supportsInterface',
        ...config,
    } as UseContractReadConfig<typeof algebraFactoryABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function useAlgebraFactoryWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraFactoryABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraFactoryABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, TFunctionName, TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"acceptOwnership"`.
 */
export function useAlgebraFactoryAcceptOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'acceptOwnership'
              >['request']['abi'],
              'acceptOwnership',
              TMode
          > & { functionName?: 'acceptOwnership' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'acceptOwnership', TMode> & {
              abi?: never
              functionName?: 'acceptOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'acceptOwnership', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'acceptOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"createPool"`.
 */
export function useAlgebraFactoryCreatePool<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraFactoryABI, 'createPool'>['request']['abi'],
              'createPool',
              TMode
          > & { functionName?: 'createPool' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'createPool', TMode> & {
              abi?: never
              functionName?: 'createPool'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'createPool', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'createPool',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"grantRole"`.
 */
export function useAlgebraFactoryGrantRole<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraFactoryABI, 'grantRole'>['request']['abi'],
              'grantRole',
              TMode
          > & { functionName?: 'grantRole' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'grantRole', TMode> & {
              abi?: never
              functionName?: 'grantRole'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'grantRole', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'grantRole',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function useAlgebraFactoryRenounceOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'renounceOwnership'
              >['request']['abi'],
              'renounceOwnership',
              TMode
          > & { functionName?: 'renounceOwnership' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'renounceOwnership', TMode> & {
              abi?: never
              functionName?: 'renounceOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'renounceOwnership', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'renounceOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"renounceRole"`.
 */
export function useAlgebraFactoryRenounceRole<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'renounceRole'
              >['request']['abi'],
              'renounceRole',
              TMode
          > & { functionName?: 'renounceRole' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'renounceRole', TMode> & {
              abi?: never
              functionName?: 'renounceRole'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'renounceRole', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'renounceRole',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"revokeRole"`.
 */
export function useAlgebraFactoryRevokeRole<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraFactoryABI, 'revokeRole'>['request']['abi'],
              'revokeRole',
              TMode
          > & { functionName?: 'revokeRole' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'revokeRole', TMode> & {
              abi?: never
              functionName?: 'revokeRole'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'revokeRole', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'revokeRole',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setBaseFeeConfiguration"`.
 */
export function useAlgebraFactorySetBaseFeeConfiguration<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'setBaseFeeConfiguration'
              >['request']['abi'],
              'setBaseFeeConfiguration',
              TMode
          > & { functionName?: 'setBaseFeeConfiguration' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'setBaseFeeConfiguration', TMode> & {
              abi?: never
              functionName?: 'setBaseFeeConfiguration'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'setBaseFeeConfiguration', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setBaseFeeConfiguration',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setDefaultCommunityFee"`.
 */
export function useAlgebraFactorySetDefaultCommunityFee<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'setDefaultCommunityFee'
              >['request']['abi'],
              'setDefaultCommunityFee',
              TMode
          > & { functionName?: 'setDefaultCommunityFee' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'setDefaultCommunityFee', TMode> & {
              abi?: never
              functionName?: 'setDefaultCommunityFee'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'setDefaultCommunityFee', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setDefaultCommunityFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setFarmingAddress"`.
 */
export function useAlgebraFactorySetFarmingAddress<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'setFarmingAddress'
              >['request']['abi'],
              'setFarmingAddress',
              TMode
          > & { functionName?: 'setFarmingAddress' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'setFarmingAddress', TMode> & {
              abi?: never
              functionName?: 'setFarmingAddress'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'setFarmingAddress', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setFarmingAddress',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"startRenounceOwnership"`.
 */
export function useAlgebraFactoryStartRenounceOwnership<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'startRenounceOwnership'
              >['request']['abi'],
              'startRenounceOwnership',
              TMode
          > & { functionName?: 'startRenounceOwnership' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'startRenounceOwnership', TMode> & {
              abi?: never
              functionName?: 'startRenounceOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'startRenounceOwnership', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'startRenounceOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"stopRenounceOwnership"`.
 */
export function useAlgebraFactoryStopRenounceOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'stopRenounceOwnership'
              >['request']['abi'],
              'stopRenounceOwnership',
              TMode
          > & { functionName?: 'stopRenounceOwnership' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'stopRenounceOwnership', TMode> & {
              abi?: never
              functionName?: 'stopRenounceOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'stopRenounceOwnership', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'stopRenounceOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function useAlgebraFactoryTransferOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraFactoryABI,
                  'transferOwnership'
              >['request']['abi'],
              'transferOwnership',
              TMode
          > & { functionName?: 'transferOwnership' }
        : UseContractWriteConfig<typeof algebraFactoryABI, 'transferOwnership', TMode> & {
              abi?: never
              functionName?: 'transferOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof algebraFactoryABI, 'transferOwnership', TMode>({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'transferOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__.
 */
export function usePrepareAlgebraFactoryWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"acceptOwnership"`.
 */
export function usePrepareAlgebraFactoryAcceptOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'acceptOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'acceptOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'acceptOwnership'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"createPool"`.
 */
export function usePrepareAlgebraFactoryCreatePool(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'createPool'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'createPool',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'createPool'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"grantRole"`.
 */
export function usePrepareAlgebraFactoryGrantRole(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'grantRole'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'grantRole',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'grantRole'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function usePrepareAlgebraFactoryRenounceOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'renounceOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'renounceOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'renounceOwnership'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"renounceRole"`.
 */
export function usePrepareAlgebraFactoryRenounceRole(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'renounceRole'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'renounceRole',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'renounceRole'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"revokeRole"`.
 */
export function usePrepareAlgebraFactoryRevokeRole(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'revokeRole'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'revokeRole',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'revokeRole'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setBaseFeeConfiguration"`.
 */
export function usePrepareAlgebraFactorySetBaseFeeConfiguration(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setBaseFeeConfiguration'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setBaseFeeConfiguration',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setBaseFeeConfiguration'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setDefaultCommunityFee"`.
 */
export function usePrepareAlgebraFactorySetDefaultCommunityFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setDefaultCommunityFee'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setDefaultCommunityFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setDefaultCommunityFee'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"setFarmingAddress"`.
 */
export function usePrepareAlgebraFactorySetFarmingAddress(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setFarmingAddress'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'setFarmingAddress',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'setFarmingAddress'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"startRenounceOwnership"`.
 */
export function usePrepareAlgebraFactoryStartRenounceOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'startRenounceOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'startRenounceOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'startRenounceOwnership'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"stopRenounceOwnership"`.
 */
export function usePrepareAlgebraFactoryStopRenounceOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'stopRenounceOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'stopRenounceOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'stopRenounceOwnership'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraFactoryABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function usePrepareAlgebraFactoryTransferOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'transferOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraFactoryABI,
        address: algebraFactoryAddress,
        functionName: 'transferOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraFactoryABI, 'transferOwnership'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function useAlgebraPoolRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi'
    > = {} as any,
) {
    return useContractRead({ abi: algebraPoolABI, ...config } as UseContractReadConfig<
        typeof algebraPoolABI,
        TFunctionName,
        TSelectData
    >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"communityFeeLastTimestamp"`.
 */
export function useAlgebraPoolCommunityFeeLastTimestamp<
    TFunctionName extends 'communityFeeLastTimestamp',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'communityFeeLastTimestamp',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"communityVault"`.
 */
export function useAlgebraPoolCommunityVault<
    TFunctionName extends 'communityVault',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'communityVault',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"factory"`.
 */
export function useAlgebraPoolFactory<
    TFunctionName extends 'factory',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'factory',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"fee"`.
 */
export function useAlgebraPoolFee<
    TFunctionName extends 'fee',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'fee',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"getCommunityFeePending"`.
 */
export function useAlgebraPoolGetCommunityFeePending<
    TFunctionName extends 'getCommunityFeePending',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'getCommunityFeePending',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"getReserves"`.
 */
export function useAlgebraPoolGetReserves<
    TFunctionName extends 'getReserves',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'getReserves',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"globalState"`.
 */
export function useAlgebraPoolGlobalState<
    TFunctionName extends 'globalState',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'globalState',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"liquidity"`.
 */
export function useAlgebraPoolLiquidity<
    TFunctionName extends 'liquidity',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'liquidity',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"maxLiquidityPerTick"`.
 */
export function useAlgebraPoolMaxLiquidityPerTick<
    TFunctionName extends 'maxLiquidityPerTick',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'maxLiquidityPerTick',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"nextTickGlobal"`.
 */
export function useAlgebraPoolNextTickGlobal<
    TFunctionName extends 'nextTickGlobal',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'nextTickGlobal',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"plugin"`.
 */
export function useAlgebraPoolPlugin<
    TFunctionName extends 'plugin',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'plugin',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"positions"`.
 */
export function useAlgebraPoolPositions<
    TFunctionName extends 'positions',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'positions',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"prevTickGlobal"`.
 */
export function useAlgebraPoolPrevTickGlobal<
    TFunctionName extends 'prevTickGlobal',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'prevTickGlobal',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"tickSpacing"`.
 */
export function useAlgebraPoolTickSpacing<
    TFunctionName extends 'tickSpacing',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'tickSpacing',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"tickTable"`.
 */
export function useAlgebraPoolTickTable<
    TFunctionName extends 'tickTable',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'tickTable',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"ticks"`.
 */
export function useAlgebraPoolTicks<
    TFunctionName extends 'ticks',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'ticks',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"token0"`.
 */
export function useAlgebraPoolToken0<
    TFunctionName extends 'token0',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'token0',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"token1"`.
 */
export function useAlgebraPoolToken1<
    TFunctionName extends 'token1',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'token1',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"totalFeeGrowth0Token"`.
 */
export function useAlgebraPoolTotalFeeGrowth0Token<
    TFunctionName extends 'totalFeeGrowth0Token',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'totalFeeGrowth0Token',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"totalFeeGrowth1Token"`.
 */
export function useAlgebraPoolTotalFeeGrowth1Token<
    TFunctionName extends 'totalFeeGrowth1Token',
    TSelectData = ReadContractResult<typeof algebraPoolABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPoolABI,
        functionName: 'totalFeeGrowth1Token',
        ...config,
    } as UseContractReadConfig<typeof algebraPoolABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function useAlgebraPoolWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraPoolABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, TFunctionName, TMode>({
        abi: algebraPoolABI,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"burn"`.
 */
export function useAlgebraPoolBurn<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'burn'>['request']['abi'],
              'burn',
              TMode
          > & { functionName?: 'burn' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'burn', TMode> & {
              abi?: never
              functionName?: 'burn'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'burn', TMode>({
        abi: algebraPoolABI,
        functionName: 'burn',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"collect"`.
 */
export function useAlgebraPoolCollect<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'collect'>['request']['abi'],
              'collect',
              TMode
          > & { functionName?: 'collect' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'collect', TMode> & {
              abi?: never
              functionName?: 'collect'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'collect', TMode>({
        abi: algebraPoolABI,
        functionName: 'collect',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"flash"`.
 */
export function useAlgebraPoolFlash<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'flash'>['request']['abi'],
              'flash',
              TMode
          > & { functionName?: 'flash' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'flash', TMode> & {
              abi?: never
              functionName?: 'flash'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'flash', TMode>({
        abi: algebraPoolABI,
        functionName: 'flash',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"initialize"`.
 */
export function useAlgebraPoolInitialize<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'initialize'>['request']['abi'],
              'initialize',
              TMode
          > & { functionName?: 'initialize' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'initialize', TMode> & {
              abi?: never
              functionName?: 'initialize'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'initialize', TMode>({
        abi: algebraPoolABI,
        functionName: 'initialize',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"mint"`.
 */
export function useAlgebraPoolMint<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'mint'>['request']['abi'],
              'mint',
              TMode
          > & { functionName?: 'mint' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'mint', TMode> & {
              abi?: never
              functionName?: 'mint'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'mint', TMode>({
        abi: algebraPoolABI,
        functionName: 'mint',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setCommunityFee"`.
 */
export function useAlgebraPoolSetCommunityFee<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPoolABI,
                  'setCommunityFee'
              >['request']['abi'],
              'setCommunityFee',
              TMode
          > & { functionName?: 'setCommunityFee' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'setCommunityFee', TMode> & {
              abi?: never
              functionName?: 'setCommunityFee'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'setCommunityFee', TMode>({
        abi: algebraPoolABI,
        functionName: 'setCommunityFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setFee"`.
 */
export function useAlgebraPoolSetFee<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'setFee'>['request']['abi'],
              'setFee',
              TMode
          > & { functionName?: 'setFee' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'setFee', TMode> & {
              abi?: never
              functionName?: 'setFee'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'setFee', TMode>({
        abi: algebraPoolABI,
        functionName: 'setFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setPlugin"`.
 */
export function useAlgebraPoolSetPlugin<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'setPlugin'>['request']['abi'],
              'setPlugin',
              TMode
          > & { functionName?: 'setPlugin' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'setPlugin', TMode> & {
              abi?: never
              functionName?: 'setPlugin'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'setPlugin', TMode>({
        abi: algebraPoolABI,
        functionName: 'setPlugin',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setPluginConfig"`.
 */
export function useAlgebraPoolSetPluginConfig<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPoolABI,
                  'setPluginConfig'
              >['request']['abi'],
              'setPluginConfig',
              TMode
          > & { functionName?: 'setPluginConfig' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'setPluginConfig', TMode> & {
              abi?: never
              functionName?: 'setPluginConfig'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'setPluginConfig', TMode>({
        abi: algebraPoolABI,
        functionName: 'setPluginConfig',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setTickSpacing"`.
 */
export function useAlgebraPoolSetTickSpacing<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'setTickSpacing'>['request']['abi'],
              'setTickSpacing',
              TMode
          > & { functionName?: 'setTickSpacing' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'setTickSpacing', TMode> & {
              abi?: never
              functionName?: 'setTickSpacing'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'setTickSpacing', TMode>({
        abi: algebraPoolABI,
        functionName: 'setTickSpacing',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"swap"`.
 */
export function useAlgebraPoolSwap<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraPoolABI, 'swap'>['request']['abi'],
              'swap',
              TMode
          > & { functionName?: 'swap' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'swap', TMode> & {
              abi?: never
              functionName?: 'swap'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'swap', TMode>({
        abi: algebraPoolABI,
        functionName: 'swap',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"swapWithPaymentInAdvance"`.
 */
export function useAlgebraPoolSwapWithPaymentInAdvance<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPoolABI,
                  'swapWithPaymentInAdvance'
              >['request']['abi'],
              'swapWithPaymentInAdvance',
              TMode
          > & { functionName?: 'swapWithPaymentInAdvance' }
        : UseContractWriteConfig<typeof algebraPoolABI, 'swapWithPaymentInAdvance', TMode> & {
              abi?: never
              functionName?: 'swapWithPaymentInAdvance'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPoolABI, 'swapWithPaymentInAdvance', TMode>({
        abi: algebraPoolABI,
        functionName: 'swapWithPaymentInAdvance',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__.
 */
export function usePrepareAlgebraPoolWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, TFunctionName>,
        'abi'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"burn"`.
 */
export function usePrepareAlgebraPoolBurn(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'burn'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'burn',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'burn'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"collect"`.
 */
export function usePrepareAlgebraPoolCollect(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'collect'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'collect',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'collect'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"flash"`.
 */
export function usePrepareAlgebraPoolFlash(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'flash'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'flash',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'flash'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"initialize"`.
 */
export function usePrepareAlgebraPoolInitialize(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'initialize'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'initialize',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'initialize'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"mint"`.
 */
export function usePrepareAlgebraPoolMint(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'mint'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'mint',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'mint'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setCommunityFee"`.
 */
export function usePrepareAlgebraPoolSetCommunityFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setCommunityFee'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'setCommunityFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setCommunityFee'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setFee"`.
 */
export function usePrepareAlgebraPoolSetFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setFee'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'setFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setFee'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setPlugin"`.
 */
export function usePrepareAlgebraPoolSetPlugin(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setPlugin'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'setPlugin',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setPlugin'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setPluginConfig"`.
 */
export function usePrepareAlgebraPoolSetPluginConfig(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setPluginConfig'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'setPluginConfig',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setPluginConfig'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"setTickSpacing"`.
 */
export function usePrepareAlgebraPoolSetTickSpacing(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setTickSpacing'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'setTickSpacing',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'setTickSpacing'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"swap"`.
 */
export function usePrepareAlgebraPoolSwap(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'swap'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'swap',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'swap'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPoolABI}__ and `functionName` set to `"swapWithPaymentInAdvance"`.
 */
export function usePrepareAlgebraPoolSwapWithPaymentInAdvance(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPoolABI, 'swapWithPaymentInAdvance'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPoolABI,
        functionName: 'swapWithPaymentInAdvance',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPoolABI, 'swapWithPaymentInAdvance'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function useAlgebraPositionManagerRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"DOMAIN_SEPARATOR"`.
 */
export function useAlgebraPositionManagerDomainSeparator<
    TFunctionName extends 'DOMAIN_SEPARATOR',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'DOMAIN_SEPARATOR',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE"`.
 */
export function useAlgebraPositionManagerNonfungiblePositionManagerAdministratorRole<
    TFunctionName extends 'NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"PERMIT_TYPEHASH"`.
 */
export function useAlgebraPositionManagerPermitTypehash<
    TFunctionName extends 'PERMIT_TYPEHASH',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'PERMIT_TYPEHASH',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"WNativeToken"`.
 */
export function useAlgebraPositionManagerWNativeToken<
    TFunctionName extends 'WNativeToken',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'WNativeToken',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useAlgebraPositionManagerBalanceOf<
    TFunctionName extends 'balanceOf',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'balanceOf',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"factory"`.
 */
export function useAlgebraPositionManagerFactory<
    TFunctionName extends 'factory',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'factory',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"farmingApprovals"`.
 */
export function useAlgebraPositionManagerFarmingApprovals<
    TFunctionName extends 'farmingApprovals',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'farmingApprovals',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"farmingCenter"`.
 */
export function useAlgebraPositionManagerFarmingCenter<
    TFunctionName extends 'farmingCenter',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'farmingCenter',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"getApproved"`.
 */
export function useAlgebraPositionManagerGetApproved<
    TFunctionName extends 'getApproved',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'getApproved',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"isApprovedForAll"`.
 */
export function useAlgebraPositionManagerIsApprovedForAll<
    TFunctionName extends 'isApprovedForAll',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'isApprovedForAll',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"isApprovedOrOwner"`.
 */
export function useAlgebraPositionManagerIsApprovedOrOwner<
    TFunctionName extends 'isApprovedOrOwner',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'isApprovedOrOwner',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"name"`.
 */
export function useAlgebraPositionManagerName<
    TFunctionName extends 'name',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'name',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"ownerOf"`.
 */
export function useAlgebraPositionManagerOwnerOf<
    TFunctionName extends 'ownerOf',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'ownerOf',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"poolDeployer"`.
 */
export function useAlgebraPositionManagerPoolDeployer<
    TFunctionName extends 'poolDeployer',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'poolDeployer',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"positions"`.
 */
export function useAlgebraPositionManagerPositions<
    TFunctionName extends 'positions',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'positions',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"supportsInterface"`.
 */
export function useAlgebraPositionManagerSupportsInterface<
    TFunctionName extends 'supportsInterface',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'supportsInterface',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"symbol"`.
 */
export function useAlgebraPositionManagerSymbol<
    TFunctionName extends 'symbol',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'symbol',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"tokenByIndex"`.
 */
export function useAlgebraPositionManagerTokenByIndex<
    TFunctionName extends 'tokenByIndex',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'tokenByIndex',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"tokenFarmedIn"`.
 */
export function useAlgebraPositionManagerTokenFarmedIn<
    TFunctionName extends 'tokenFarmedIn',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'tokenFarmedIn',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"tokenOfOwnerByIndex"`.
 */
export function useAlgebraPositionManagerTokenOfOwnerByIndex<
    TFunctionName extends 'tokenOfOwnerByIndex',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'tokenOfOwnerByIndex',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"tokenURI"`.
 */
export function useAlgebraPositionManagerTokenUri<
    TFunctionName extends 'tokenURI',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'tokenURI',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useAlgebraPositionManagerTotalSupply<
    TFunctionName extends 'totalSupply',
    TSelectData = ReadContractResult<typeof algebraPositionManagerABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'totalSupply',
        ...config,
    } as UseContractReadConfig<typeof algebraPositionManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function useAlgebraPositionManagerWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  string
              >['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraPositionManagerABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, TFunctionName, TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"algebraMintCallback"`.
 */
export function useAlgebraPositionManagerAlgebraMintCallback<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'algebraMintCallback'
              >['request']['abi'],
              'algebraMintCallback',
              TMode
          > & { functionName?: 'algebraMintCallback' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'algebraMintCallback', TMode> & {
              abi?: never
              functionName?: 'algebraMintCallback'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'algebraMintCallback', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'algebraMintCallback',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"approve"`.
 */
export function useAlgebraPositionManagerApprove<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'approve'
              >['request']['abi'],
              'approve',
              TMode
          > & { functionName?: 'approve' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'approve', TMode> & {
              abi?: never
              functionName?: 'approve'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'approve', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'approve',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"approveForFarming"`.
 */
export function useAlgebraPositionManagerApproveForFarming<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'approveForFarming'
              >['request']['abi'],
              'approveForFarming',
              TMode
          > & { functionName?: 'approveForFarming' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'approveForFarming', TMode> & {
              abi?: never
              functionName?: 'approveForFarming'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'approveForFarming', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'approveForFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"burn"`.
 */
export function useAlgebraPositionManagerBurn<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'burn'
              >['request']['abi'],
              'burn',
              TMode
          > & { functionName?: 'burn' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'burn', TMode> & {
              abi?: never
              functionName?: 'burn'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'burn', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'burn',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"collect"`.
 */
export function useAlgebraPositionManagerCollect<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'collect'
              >['request']['abi'],
              'collect',
              TMode
          > & { functionName?: 'collect' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'collect', TMode> & {
              abi?: never
              functionName?: 'collect'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'collect', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'collect',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"createAndInitializePoolIfNecessary"`.
 */
export function useAlgebraPositionManagerCreateAndInitializePoolIfNecessary<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'createAndInitializePoolIfNecessary'
              >['request']['abi'],
              'createAndInitializePoolIfNecessary',
              TMode
          > & { functionName?: 'createAndInitializePoolIfNecessary' }
        : UseContractWriteConfig<
              typeof algebraPositionManagerABI,
              'createAndInitializePoolIfNecessary',
              TMode
          > & {
              abi?: never
              functionName?: 'createAndInitializePoolIfNecessary'
          } = {} as any,
) {
    return useContractWrite<
        typeof algebraPositionManagerABI,
        'createAndInitializePoolIfNecessary',
        TMode
    >({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'createAndInitializePoolIfNecessary',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"decreaseLiquidity"`.
 */
export function useAlgebraPositionManagerDecreaseLiquidity<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'decreaseLiquidity'
              >['request']['abi'],
              'decreaseLiquidity',
              TMode
          > & { functionName?: 'decreaseLiquidity' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'decreaseLiquidity', TMode> & {
              abi?: never
              functionName?: 'decreaseLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'decreaseLiquidity', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'decreaseLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"increaseLiquidity"`.
 */
export function useAlgebraPositionManagerIncreaseLiquidity<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'increaseLiquidity'
              >['request']['abi'],
              'increaseLiquidity',
              TMode
          > & { functionName?: 'increaseLiquidity' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'increaseLiquidity', TMode> & {
              abi?: never
              functionName?: 'increaseLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'increaseLiquidity', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'increaseLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"mint"`.
 */
export function useAlgebraPositionManagerMint<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'mint'
              >['request']['abi'],
              'mint',
              TMode
          > & { functionName?: 'mint' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'mint', TMode> & {
              abi?: never
              functionName?: 'mint'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'mint', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'mint',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"multicall"`.
 */
export function useAlgebraPositionManagerMulticall<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'multicall'
              >['request']['abi'],
              'multicall',
              TMode
          > & { functionName?: 'multicall' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'multicall', TMode> & {
              abi?: never
              functionName?: 'multicall'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'multicall', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'multicall',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"permit"`.
 */
export function useAlgebraPositionManagerPermit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'permit'
              >['request']['abi'],
              'permit',
              TMode
          > & { functionName?: 'permit' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'permit', TMode> & {
              abi?: never
              functionName?: 'permit'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'permit', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'permit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"refundNativeToken"`.
 */
export function useAlgebraPositionManagerRefundNativeToken<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'refundNativeToken'
              >['request']['abi'],
              'refundNativeToken',
              TMode
          > & { functionName?: 'refundNativeToken' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'refundNativeToken', TMode> & {
              abi?: never
              functionName?: 'refundNativeToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'refundNativeToken', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'refundNativeToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"safeTransferFrom"`.
 */
export function useAlgebraPositionManagerSafeTransferFrom<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'safeTransferFrom'
              >['request']['abi'],
              'safeTransferFrom',
              TMode
          > & { functionName?: 'safeTransferFrom' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'safeTransferFrom', TMode> & {
              abi?: never
              functionName?: 'safeTransferFrom'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'safeTransferFrom', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'safeTransferFrom',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermit"`.
 */
export function useAlgebraPositionManagerSelfPermit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'selfPermit'
              >['request']['abi'],
              'selfPermit',
              TMode
          > & { functionName?: 'selfPermit' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermit', TMode> & {
              abi?: never
              functionName?: 'selfPermit'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'selfPermit', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitAllowed"`.
 */
export function useAlgebraPositionManagerSelfPermitAllowed<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'selfPermitAllowed'
              >['request']['abi'],
              'selfPermitAllowed',
              TMode
          > & { functionName?: 'selfPermitAllowed' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermitAllowed', TMode> & {
              abi?: never
              functionName?: 'selfPermitAllowed'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'selfPermitAllowed', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitAllowed',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitAllowedIfNecessary"`.
 */
export function useAlgebraPositionManagerSelfPermitAllowedIfNecessary<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'selfPermitAllowedIfNecessary'
              >['request']['abi'],
              'selfPermitAllowedIfNecessary',
              TMode
          > & { functionName?: 'selfPermitAllowedIfNecessary' }
        : UseContractWriteConfig<
              typeof algebraPositionManagerABI,
              'selfPermitAllowedIfNecessary',
              TMode
          > & {
              abi?: never
              functionName?: 'selfPermitAllowedIfNecessary'
          } = {} as any,
) {
    return useContractWrite<
        typeof algebraPositionManagerABI,
        'selfPermitAllowedIfNecessary',
        TMode
    >({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitAllowedIfNecessary',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitIfNecessary"`.
 */
export function useAlgebraPositionManagerSelfPermitIfNecessary<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'selfPermitIfNecessary'
              >['request']['abi'],
              'selfPermitIfNecessary',
              TMode
          > & { functionName?: 'selfPermitIfNecessary' }
        : UseContractWriteConfig<
              typeof algebraPositionManagerABI,
              'selfPermitIfNecessary',
              TMode
          > & {
              abi?: never
              functionName?: 'selfPermitIfNecessary'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'selfPermitIfNecessary', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitIfNecessary',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"setApprovalForAll"`.
 */
export function useAlgebraPositionManagerSetApprovalForAll<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'setApprovalForAll'
              >['request']['abi'],
              'setApprovalForAll',
              TMode
          > & { functionName?: 'setApprovalForAll' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'setApprovalForAll', TMode> & {
              abi?: never
              functionName?: 'setApprovalForAll'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'setApprovalForAll', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'setApprovalForAll',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"setFarmingCenter"`.
 */
export function useAlgebraPositionManagerSetFarmingCenter<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'setFarmingCenter'
              >['request']['abi'],
              'setFarmingCenter',
              TMode
          > & { functionName?: 'setFarmingCenter' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'setFarmingCenter', TMode> & {
              abi?: never
              functionName?: 'setFarmingCenter'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'setFarmingCenter', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'setFarmingCenter',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"sweepToken"`.
 */
export function useAlgebraPositionManagerSweepToken<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'sweepToken'
              >['request']['abi'],
              'sweepToken',
              TMode
          > & { functionName?: 'sweepToken' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'sweepToken', TMode> & {
              abi?: never
              functionName?: 'sweepToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'sweepToken', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'sweepToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"switchFarmingStatus"`.
 */
export function useAlgebraPositionManagerSwitchFarmingStatus<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'switchFarmingStatus'
              >['request']['abi'],
              'switchFarmingStatus',
              TMode
          > & { functionName?: 'switchFarmingStatus' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'switchFarmingStatus', TMode> & {
              abi?: never
              functionName?: 'switchFarmingStatus'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'switchFarmingStatus', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'switchFarmingStatus',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useAlgebraPositionManagerTransferFrom<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'transferFrom'
              >['request']['abi'],
              'transferFrom',
              TMode
          > & { functionName?: 'transferFrom' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'transferFrom', TMode> & {
              abi?: never
              functionName?: 'transferFrom'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'transferFrom', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'transferFrom',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"unwrapWNativeToken"`.
 */
export function useAlgebraPositionManagerUnwrapWNativeToken<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraPositionManagerABI,
                  'unwrapWNativeToken'
              >['request']['abi'],
              'unwrapWNativeToken',
              TMode
          > & { functionName?: 'unwrapWNativeToken' }
        : UseContractWriteConfig<typeof algebraPositionManagerABI, 'unwrapWNativeToken', TMode> & {
              abi?: never
              functionName?: 'unwrapWNativeToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraPositionManagerABI, 'unwrapWNativeToken', TMode>({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'unwrapWNativeToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__.
 */
export function usePrepareAlgebraPositionManagerWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"algebraMintCallback"`.
 */
export function usePrepareAlgebraPositionManagerAlgebraMintCallback(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'algebraMintCallback'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'algebraMintCallback',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'algebraMintCallback'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareAlgebraPositionManagerApprove(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'approve'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'approve',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'approve'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"approveForFarming"`.
 */
export function usePrepareAlgebraPositionManagerApproveForFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'approveForFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'approveForFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'approveForFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"burn"`.
 */
export function usePrepareAlgebraPositionManagerBurn(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'burn'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'burn',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'burn'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"collect"`.
 */
export function usePrepareAlgebraPositionManagerCollect(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'collect'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'collect',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'collect'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"createAndInitializePoolIfNecessary"`.
 */
export function usePrepareAlgebraPositionManagerCreateAndInitializePoolIfNecessary(
    config: Omit<
        UsePrepareContractWriteConfig<
            typeof algebraPositionManagerABI,
            'createAndInitializePoolIfNecessary'
        >,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'createAndInitializePoolIfNecessary',
        ...config,
    } as UsePrepareContractWriteConfig<
        typeof algebraPositionManagerABI,
        'createAndInitializePoolIfNecessary'
    >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"decreaseLiquidity"`.
 */
export function usePrepareAlgebraPositionManagerDecreaseLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'decreaseLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'decreaseLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'decreaseLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"increaseLiquidity"`.
 */
export function usePrepareAlgebraPositionManagerIncreaseLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'increaseLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'increaseLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'increaseLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"mint"`.
 */
export function usePrepareAlgebraPositionManagerMint(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'mint'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'mint',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'mint'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"multicall"`.
 */
export function usePrepareAlgebraPositionManagerMulticall(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'multicall'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'multicall',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'multicall'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"permit"`.
 */
export function usePrepareAlgebraPositionManagerPermit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'permit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'permit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'permit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"refundNativeToken"`.
 */
export function usePrepareAlgebraPositionManagerRefundNativeToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'refundNativeToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'refundNativeToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'refundNativeToken'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"safeTransferFrom"`.
 */
export function usePrepareAlgebraPositionManagerSafeTransferFrom(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'safeTransferFrom'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'safeTransferFrom',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'safeTransferFrom'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermit"`.
 */
export function usePrepareAlgebraPositionManagerSelfPermit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitAllowed"`.
 */
export function usePrepareAlgebraPositionManagerSelfPermitAllowed(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermitAllowed'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitAllowed',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermitAllowed'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitAllowedIfNecessary"`.
 */
export function usePrepareAlgebraPositionManagerSelfPermitAllowedIfNecessary(
    config: Omit<
        UsePrepareContractWriteConfig<
            typeof algebraPositionManagerABI,
            'selfPermitAllowedIfNecessary'
        >,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitAllowedIfNecessary',
        ...config,
    } as UsePrepareContractWriteConfig<
        typeof algebraPositionManagerABI,
        'selfPermitAllowedIfNecessary'
    >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"selfPermitIfNecessary"`.
 */
export function usePrepareAlgebraPositionManagerSelfPermitIfNecessary(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermitIfNecessary'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'selfPermitIfNecessary',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'selfPermitIfNecessary'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"setApprovalForAll"`.
 */
export function usePrepareAlgebraPositionManagerSetApprovalForAll(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'setApprovalForAll'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'setApprovalForAll',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'setApprovalForAll'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"setFarmingCenter"`.
 */
export function usePrepareAlgebraPositionManagerSetFarmingCenter(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'setFarmingCenter'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'setFarmingCenter',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'setFarmingCenter'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"sweepToken"`.
 */
export function usePrepareAlgebraPositionManagerSweepToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'sweepToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'sweepToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'sweepToken'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"switchFarmingStatus"`.
 */
export function usePrepareAlgebraPositionManagerSwitchFarmingStatus(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'switchFarmingStatus'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'switchFarmingStatus',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'switchFarmingStatus'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareAlgebraPositionManagerTransferFrom(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'transferFrom'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'transferFrom',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'transferFrom'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraPositionManagerABI}__ and `functionName` set to `"unwrapWNativeToken"`.
 */
export function usePrepareAlgebraPositionManagerUnwrapWNativeToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'unwrapWNativeToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraPositionManagerABI,
        address: algebraPositionManagerAddress,
        functionName: 'unwrapWNativeToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraPositionManagerABI, 'unwrapWNativeToken'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function useAlgebraQuoterRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraQuoterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"WNativeToken"`.
 */
export function useAlgebraQuoterWNativeToken<
    TFunctionName extends 'WNativeToken',
    TSelectData = ReadContractResult<typeof algebraQuoterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'WNativeToken',
        ...config,
    } as UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"algebraSwapCallback"`.
 */
export function useAlgebraQuoterAlgebraSwapCallback<
    TFunctionName extends 'algebraSwapCallback',
    TSelectData = ReadContractResult<typeof algebraQuoterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'algebraSwapCallback',
        ...config,
    } as UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"factory"`.
 */
export function useAlgebraQuoterFactory<
    TFunctionName extends 'factory',
    TSelectData = ReadContractResult<typeof algebraQuoterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'factory',
        ...config,
    } as UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"poolDeployer"`.
 */
export function useAlgebraQuoterPoolDeployer<
    TFunctionName extends 'poolDeployer',
    TSelectData = ReadContractResult<typeof algebraQuoterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'poolDeployer',
        ...config,
    } as UseContractReadConfig<typeof algebraQuoterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function useAlgebraQuoterWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraQuoterABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraQuoterABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraQuoterABI, TFunctionName, TMode>({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactInput"`.
 */
export function useAlgebraQuoterQuoteExactInput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraQuoterABI,
                  'quoteExactInput'
              >['request']['abi'],
              'quoteExactInput',
              TMode
          > & { functionName?: 'quoteExactInput' }
        : UseContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInput', TMode> & {
              abi?: never
              functionName?: 'quoteExactInput'
          } = {} as any,
) {
    return useContractWrite<typeof algebraQuoterABI, 'quoteExactInput', TMode>({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactInput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactInputSingle"`.
 */
export function useAlgebraQuoterQuoteExactInputSingle<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraQuoterABI,
                  'quoteExactInputSingle'
              >['request']['abi'],
              'quoteExactInputSingle',
              TMode
          > & { functionName?: 'quoteExactInputSingle' }
        : UseContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInputSingle', TMode> & {
              abi?: never
              functionName?: 'quoteExactInputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algebraQuoterABI, 'quoteExactInputSingle', TMode>({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactInputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactOutput"`.
 */
export function useAlgebraQuoterQuoteExactOutput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraQuoterABI,
                  'quoteExactOutput'
              >['request']['abi'],
              'quoteExactOutput',
              TMode
          > & { functionName?: 'quoteExactOutput' }
        : UseContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutput', TMode> & {
              abi?: never
              functionName?: 'quoteExactOutput'
          } = {} as any,
) {
    return useContractWrite<typeof algebraQuoterABI, 'quoteExactOutput', TMode>({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactOutput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactOutputSingle"`.
 */
export function useAlgebraQuoterQuoteExactOutputSingle<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraQuoterABI,
                  'quoteExactOutputSingle'
              >['request']['abi'],
              'quoteExactOutputSingle',
              TMode
          > & { functionName?: 'quoteExactOutputSingle' }
        : UseContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutputSingle', TMode> & {
              abi?: never
              functionName?: 'quoteExactOutputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algebraQuoterABI, 'quoteExactOutputSingle', TMode>({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactOutputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__.
 */
export function usePrepareAlgebraQuoterWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraQuoterABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraQuoterABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactInput"`.
 */
export function usePrepareAlgebraQuoterQuoteExactInput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactInput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactInputSingle"`.
 */
export function usePrepareAlgebraQuoterQuoteExactInputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactInputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactInputSingle'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactOutput"`.
 */
export function usePrepareAlgebraQuoterQuoteExactOutput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactOutput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraQuoterABI}__ and `functionName` set to `"quoteExactOutputSingle"`.
 */
export function usePrepareAlgebraQuoterQuoteExactOutputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraQuoterABI,
        address: algebraQuoterAddress,
        functionName: 'quoteExactOutputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraQuoterABI, 'quoteExactOutputSingle'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function useAlgebraRouterRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algebraRouterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"WNativeToken"`.
 */
export function useAlgebraRouterWNativeToken<
    TFunctionName extends 'WNativeToken',
    TSelectData = ReadContractResult<typeof algebraRouterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'WNativeToken',
        ...config,
    } as UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"factory"`.
 */
export function useAlgebraRouterFactory<
    TFunctionName extends 'factory',
    TSelectData = ReadContractResult<typeof algebraRouterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'factory',
        ...config,
    } as UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"poolDeployer"`.
 */
export function useAlgebraRouterPoolDeployer<
    TFunctionName extends 'poolDeployer',
    TSelectData = ReadContractResult<typeof algebraRouterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'poolDeployer',
        ...config,
    } as UseContractReadConfig<typeof algebraRouterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function useAlgebraRouterWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algebraRouterABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, TFunctionName, TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"algebraSwapCallback"`.
 */
export function useAlgebraRouterAlgebraSwapCallback<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'algebraSwapCallback'
              >['request']['abi'],
              'algebraSwapCallback',
              TMode
          > & { functionName?: 'algebraSwapCallback' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'algebraSwapCallback', TMode> & {
              abi?: never
              functionName?: 'algebraSwapCallback'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'algebraSwapCallback', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'algebraSwapCallback',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInput"`.
 */
export function useAlgebraRouterExactInput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, 'exactInput'>['request']['abi'],
              'exactInput',
              TMode
          > & { functionName?: 'exactInput' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'exactInput', TMode> & {
              abi?: never
              functionName?: 'exactInput'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'exactInput', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInputSingle"`.
 */
export function useAlgebraRouterExactInputSingle<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'exactInputSingle'
              >['request']['abi'],
              'exactInputSingle',
              TMode
          > & { functionName?: 'exactInputSingle' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'exactInputSingle', TMode> & {
              abi?: never
              functionName?: 'exactInputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'exactInputSingle', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInputSingleSupportingFeeOnTransferTokens"`.
 */
export function useAlgebraRouterExactInputSingleSupportingFeeOnTransferTokens<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'exactInputSingleSupportingFeeOnTransferTokens'
              >['request']['abi'],
              'exactInputSingleSupportingFeeOnTransferTokens',
              TMode
          > & { functionName?: 'exactInputSingleSupportingFeeOnTransferTokens' }
        : UseContractWriteConfig<
              typeof algebraRouterABI,
              'exactInputSingleSupportingFeeOnTransferTokens',
              TMode
          > & {
              abi?: never
              functionName?: 'exactInputSingleSupportingFeeOnTransferTokens'
          } = {} as any,
) {
    return useContractWrite<
        typeof algebraRouterABI,
        'exactInputSingleSupportingFeeOnTransferTokens',
        TMode
    >({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInputSingleSupportingFeeOnTransferTokens',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactOutput"`.
 */
export function useAlgebraRouterExactOutput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, 'exactOutput'>['request']['abi'],
              'exactOutput',
              TMode
          > & { functionName?: 'exactOutput' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'exactOutput', TMode> & {
              abi?: never
              functionName?: 'exactOutput'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'exactOutput', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactOutput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactOutputSingle"`.
 */
export function useAlgebraRouterExactOutputSingle<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'exactOutputSingle'
              >['request']['abi'],
              'exactOutputSingle',
              TMode
          > & { functionName?: 'exactOutputSingle' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'exactOutputSingle', TMode> & {
              abi?: never
              functionName?: 'exactOutputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'exactOutputSingle', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactOutputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"multicall"`.
 */
export function useAlgebraRouterMulticall<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, 'multicall'>['request']['abi'],
              'multicall',
              TMode
          > & { functionName?: 'multicall' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'multicall', TMode> & {
              abi?: never
              functionName?: 'multicall'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'multicall', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'multicall',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"refundNativeToken"`.
 */
export function useAlgebraRouterRefundNativeToken<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'refundNativeToken'
              >['request']['abi'],
              'refundNativeToken',
              TMode
          > & { functionName?: 'refundNativeToken' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'refundNativeToken', TMode> & {
              abi?: never
              functionName?: 'refundNativeToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'refundNativeToken', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'refundNativeToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermit"`.
 */
export function useAlgebraRouterSelfPermit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, 'selfPermit'>['request']['abi'],
              'selfPermit',
              TMode
          > & { functionName?: 'selfPermit' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'selfPermit', TMode> & {
              abi?: never
              functionName?: 'selfPermit'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'selfPermit', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitAllowed"`.
 */
export function useAlgebraRouterSelfPermitAllowed<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'selfPermitAllowed'
              >['request']['abi'],
              'selfPermitAllowed',
              TMode
          > & { functionName?: 'selfPermitAllowed' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowed', TMode> & {
              abi?: never
              functionName?: 'selfPermitAllowed'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'selfPermitAllowed', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitAllowed',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitAllowedIfNecessary"`.
 */
export function useAlgebraRouterSelfPermitAllowedIfNecessary<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'selfPermitAllowedIfNecessary'
              >['request']['abi'],
              'selfPermitAllowedIfNecessary',
              TMode
          > & { functionName?: 'selfPermitAllowedIfNecessary' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowedIfNecessary', TMode> & {
              abi?: never
              functionName?: 'selfPermitAllowedIfNecessary'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'selfPermitAllowedIfNecessary', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitAllowedIfNecessary',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitIfNecessary"`.
 */
export function useAlgebraRouterSelfPermitIfNecessary<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'selfPermitIfNecessary'
              >['request']['abi'],
              'selfPermitIfNecessary',
              TMode
          > & { functionName?: 'selfPermitIfNecessary' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'selfPermitIfNecessary', TMode> & {
              abi?: never
              functionName?: 'selfPermitIfNecessary'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'selfPermitIfNecessary', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitIfNecessary',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"sweepToken"`.
 */
export function useAlgebraRouterSweepToken<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algebraRouterABI, 'sweepToken'>['request']['abi'],
              'sweepToken',
              TMode
          > & { functionName?: 'sweepToken' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'sweepToken', TMode> & {
              abi?: never
              functionName?: 'sweepToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'sweepToken', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'sweepToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"sweepTokenWithFee"`.
 */
export function useAlgebraRouterSweepTokenWithFee<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'sweepTokenWithFee'
              >['request']['abi'],
              'sweepTokenWithFee',
              TMode
          > & { functionName?: 'sweepTokenWithFee' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'sweepTokenWithFee', TMode> & {
              abi?: never
              functionName?: 'sweepTokenWithFee'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'sweepTokenWithFee', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'sweepTokenWithFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"unwrapWNativeToken"`.
 */
export function useAlgebraRouterUnwrapWNativeToken<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'unwrapWNativeToken'
              >['request']['abi'],
              'unwrapWNativeToken',
              TMode
          > & { functionName?: 'unwrapWNativeToken' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeToken', TMode> & {
              abi?: never
              functionName?: 'unwrapWNativeToken'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'unwrapWNativeToken', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'unwrapWNativeToken',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"unwrapWNativeTokenWithFee"`.
 */
export function useAlgebraRouterUnwrapWNativeTokenWithFee<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algebraRouterABI,
                  'unwrapWNativeTokenWithFee'
              >['request']['abi'],
              'unwrapWNativeTokenWithFee',
              TMode
          > & { functionName?: 'unwrapWNativeTokenWithFee' }
        : UseContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeTokenWithFee', TMode> & {
              abi?: never
              functionName?: 'unwrapWNativeTokenWithFee'
          } = {} as any,
) {
    return useContractWrite<typeof algebraRouterABI, 'unwrapWNativeTokenWithFee', TMode>({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'unwrapWNativeTokenWithFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__.
 */
export function usePrepareAlgebraRouterWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"algebraSwapCallback"`.
 */
export function usePrepareAlgebraRouterAlgebraSwapCallback(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'algebraSwapCallback'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'algebraSwapCallback',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'algebraSwapCallback'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInput"`.
 */
export function usePrepareAlgebraRouterExactInput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactInput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactInput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInputSingle"`.
 */
export function usePrepareAlgebraRouterExactInputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactInputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactInputSingle'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactInputSingleSupportingFeeOnTransferTokens"`.
 */
export function usePrepareAlgebraRouterExactInputSingleSupportingFeeOnTransferTokens(
    config: Omit<
        UsePrepareContractWriteConfig<
            typeof algebraRouterABI,
            'exactInputSingleSupportingFeeOnTransferTokens'
        >,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactInputSingleSupportingFeeOnTransferTokens',
        ...config,
    } as UsePrepareContractWriteConfig<
        typeof algebraRouterABI,
        'exactInputSingleSupportingFeeOnTransferTokens'
    >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactOutput"`.
 */
export function usePrepareAlgebraRouterExactOutput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactOutput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactOutput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactOutput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"exactOutputSingle"`.
 */
export function usePrepareAlgebraRouterExactOutputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactOutputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'exactOutputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'exactOutputSingle'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"multicall"`.
 */
export function usePrepareAlgebraRouterMulticall(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'multicall'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'multicall',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'multicall'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"refundNativeToken"`.
 */
export function usePrepareAlgebraRouterRefundNativeToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'refundNativeToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'refundNativeToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'refundNativeToken'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermit"`.
 */
export function usePrepareAlgebraRouterSelfPermit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitAllowed"`.
 */
export function usePrepareAlgebraRouterSelfPermitAllowed(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowed'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitAllowed',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowed'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitAllowedIfNecessary"`.
 */
export function usePrepareAlgebraRouterSelfPermitAllowedIfNecessary(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowedIfNecessary'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitAllowedIfNecessary',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitAllowedIfNecessary'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"selfPermitIfNecessary"`.
 */
export function usePrepareAlgebraRouterSelfPermitIfNecessary(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitIfNecessary'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'selfPermitIfNecessary',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'selfPermitIfNecessary'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"sweepToken"`.
 */
export function usePrepareAlgebraRouterSweepToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'sweepToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'sweepToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'sweepToken'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"sweepTokenWithFee"`.
 */
export function usePrepareAlgebraRouterSweepTokenWithFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'sweepTokenWithFee'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'sweepTokenWithFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'sweepTokenWithFee'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"unwrapWNativeToken"`.
 */
export function usePrepareAlgebraRouterUnwrapWNativeToken(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeToken'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'unwrapWNativeToken',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeToken'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algebraRouterABI}__ and `functionName` set to `"unwrapWNativeTokenWithFee"`.
 */
export function usePrepareAlgebraRouterUnwrapWNativeTokenWithFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeTokenWithFee'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algebraRouterABI,
        address: algebraRouterAddress,
        functionName: 'unwrapWNativeTokenWithFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algebraRouterABI, 'unwrapWNativeTokenWithFee'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function useAlgerbaQuoterV2Read<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof algerbaQuoterV2ABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"WNativeToken"`.
 */
export function useAlgerbaQuoterV2WNativeToken<
    TFunctionName extends 'WNativeToken',
    TSelectData = ReadContractResult<typeof algerbaQuoterV2ABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'WNativeToken',
        ...config,
    } as UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"algebraSwapCallback"`.
 */
export function useAlgerbaQuoterV2AlgebraSwapCallback<
    TFunctionName extends 'algebraSwapCallback',
    TSelectData = ReadContractResult<typeof algerbaQuoterV2ABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'algebraSwapCallback',
        ...config,
    } as UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"factory"`.
 */
export function useAlgerbaQuoterV2Factory<
    TFunctionName extends 'factory',
    TSelectData = ReadContractResult<typeof algerbaQuoterV2ABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'factory',
        ...config,
    } as UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"poolDeployer"`.
 */
export function useAlgerbaQuoterV2PoolDeployer<
    TFunctionName extends 'poolDeployer',
    TSelectData = ReadContractResult<typeof algerbaQuoterV2ABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'poolDeployer',
        ...config,
    } as UseContractReadConfig<typeof algerbaQuoterV2ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function useAlgerbaQuoterV2Write<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof algerbaQuoterV2ABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof algerbaQuoterV2ABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof algerbaQuoterV2ABI, TFunctionName, TMode>({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactInput"`.
 */
export function useAlgerbaQuoterV2QuoteExactInput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algerbaQuoterV2ABI,
                  'quoteExactInput'
              >['request']['abi'],
              'quoteExactInput',
              TMode
          > & { functionName?: 'quoteExactInput' }
        : UseContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInput', TMode> & {
              abi?: never
              functionName?: 'quoteExactInput'
          } = {} as any,
) {
    return useContractWrite<typeof algerbaQuoterV2ABI, 'quoteExactInput', TMode>({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactInput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactInputSingle"`.
 */
export function useAlgerbaQuoterV2QuoteExactInputSingle<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algerbaQuoterV2ABI,
                  'quoteExactInputSingle'
              >['request']['abi'],
              'quoteExactInputSingle',
              TMode
          > & { functionName?: 'quoteExactInputSingle' }
        : UseContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInputSingle', TMode> & {
              abi?: never
              functionName?: 'quoteExactInputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algerbaQuoterV2ABI, 'quoteExactInputSingle', TMode>({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactInputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactOutput"`.
 */
export function useAlgerbaQuoterV2QuoteExactOutput<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algerbaQuoterV2ABI,
                  'quoteExactOutput'
              >['request']['abi'],
              'quoteExactOutput',
              TMode
          > & { functionName?: 'quoteExactOutput' }
        : UseContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutput', TMode> & {
              abi?: never
              functionName?: 'quoteExactOutput'
          } = {} as any,
) {
    return useContractWrite<typeof algerbaQuoterV2ABI, 'quoteExactOutput', TMode>({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactOutput',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactOutputSingle"`.
 */
export function useAlgerbaQuoterV2QuoteExactOutputSingle<
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof algerbaQuoterV2ABI,
                  'quoteExactOutputSingle'
              >['request']['abi'],
              'quoteExactOutputSingle',
              TMode
          > & { functionName?: 'quoteExactOutputSingle' }
        : UseContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutputSingle', TMode> & {
              abi?: never
              functionName?: 'quoteExactOutputSingle'
          } = {} as any,
) {
    return useContractWrite<typeof algerbaQuoterV2ABI, 'quoteExactOutputSingle', TMode>({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactOutputSingle',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__.
 */
export function usePrepareAlgerbaQuoterV2Write<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        ...config,
    } as UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactInput"`.
 */
export function usePrepareAlgerbaQuoterV2QuoteExactInput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactInput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactInputSingle"`.
 */
export function usePrepareAlgerbaQuoterV2QuoteExactInputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactInputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactInputSingle'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactOutput"`.
 */
export function usePrepareAlgerbaQuoterV2QuoteExactOutput(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutput'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactOutput',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutput'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link algerbaQuoterV2ABI}__ and `functionName` set to `"quoteExactOutputSingle"`.
 */
export function usePrepareAlgerbaQuoterV2QuoteExactOutputSingle(
    config: Omit<
        UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutputSingle'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: algerbaQuoterV2ABI,
        address: algerbaQuoterV2Address,
        functionName: 'quoteExactOutputSingle',
        ...config,
    } as UsePrepareContractWriteConfig<typeof algerbaQuoterV2ABI, 'quoteExactOutputSingle'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function useFarmingCenterRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"deposits"`.
 */
export function useFarmingCenterDeposits<
    TFunctionName extends 'deposits',
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'deposits',
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"eternalFarming"`.
 */
export function useFarmingCenterEternalFarming<
    TFunctionName extends 'eternalFarming',
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'eternalFarming',
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"incentiveKeys"`.
 */
export function useFarmingCenterIncentiveKeys<
    TFunctionName extends 'incentiveKeys',
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'incentiveKeys',
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"nonfungiblePositionManager"`.
 */
export function useFarmingCenterNonfungiblePositionManager<
    TFunctionName extends 'nonfungiblePositionManager',
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'nonfungiblePositionManager',
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"virtualPoolAddresses"`.
 */
export function useFarmingCenterVirtualPoolAddresses<
    TFunctionName extends 'virtualPoolAddresses',
    TSelectData = ReadContractResult<typeof farmingCenterABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'virtualPoolAddresses',
        ...config,
    } as UseContractReadConfig<typeof farmingCenterABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function useFarmingCenterWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof farmingCenterABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, TFunctionName, TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"applyLiquidityDelta"`.
 */
export function useFarmingCenterApplyLiquidityDelta<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof farmingCenterABI,
                  'applyLiquidityDelta'
              >['request']['abi'],
              'applyLiquidityDelta',
              TMode
          > & { functionName?: 'applyLiquidityDelta' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'applyLiquidityDelta', TMode> & {
              abi?: never
              functionName?: 'applyLiquidityDelta'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'applyLiquidityDelta', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'applyLiquidityDelta',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"burnPosition"`.
 */
export function useFarmingCenterBurnPosition<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, 'burnPosition'>['request']['abi'],
              'burnPosition',
              TMode
          > & { functionName?: 'burnPosition' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'burnPosition', TMode> & {
              abi?: never
              functionName?: 'burnPosition'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'burnPosition', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'burnPosition',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"claimReward"`.
 */
export function useFarmingCenterClaimReward<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, 'claimReward'>['request']['abi'],
              'claimReward',
              TMode
          > & { functionName?: 'claimReward' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'claimReward', TMode> & {
              abi?: never
              functionName?: 'claimReward'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'claimReward', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'claimReward',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"collectRewards"`.
 */
export function useFarmingCenterCollectRewards<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof farmingCenterABI,
                  'collectRewards'
              >['request']['abi'],
              'collectRewards',
              TMode
          > & { functionName?: 'collectRewards' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'collectRewards', TMode> & {
              abi?: never
              functionName?: 'collectRewards'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'collectRewards', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'collectRewards',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"connectVirtualPool"`.
 */
export function useFarmingCenterConnectVirtualPool<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof farmingCenterABI,
                  'connectVirtualPool'
              >['request']['abi'],
              'connectVirtualPool',
              TMode
          > & { functionName?: 'connectVirtualPool' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'connectVirtualPool', TMode> & {
              abi?: never
              functionName?: 'connectVirtualPool'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'connectVirtualPool', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'connectVirtualPool',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"decreaseLiquidity"`.
 */
export function useFarmingCenterDecreaseLiquidity<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof farmingCenterABI,
                  'decreaseLiquidity'
              >['request']['abi'],
              'decreaseLiquidity',
              TMode
          > & { functionName?: 'decreaseLiquidity' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'decreaseLiquidity', TMode> & {
              abi?: never
              functionName?: 'decreaseLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'decreaseLiquidity', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'decreaseLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"enterFarming"`.
 */
export function useFarmingCenterEnterFarming<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, 'enterFarming'>['request']['abi'],
              'enterFarming',
              TMode
          > & { functionName?: 'enterFarming' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'enterFarming', TMode> & {
              abi?: never
              functionName?: 'enterFarming'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'enterFarming', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'enterFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"exitFarming"`.
 */
export function useFarmingCenterExitFarming<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, 'exitFarming'>['request']['abi'],
              'exitFarming',
              TMode
          > & { functionName?: 'exitFarming' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'exitFarming', TMode> & {
              abi?: never
              functionName?: 'exitFarming'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'exitFarming', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'exitFarming',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"increaseLiquidity"`.
 */
export function useFarmingCenterIncreaseLiquidity<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof farmingCenterABI,
                  'increaseLiquidity'
              >['request']['abi'],
              'increaseLiquidity',
              TMode
          > & { functionName?: 'increaseLiquidity' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'increaseLiquidity', TMode> & {
              abi?: never
              functionName?: 'increaseLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'increaseLiquidity', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'increaseLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"multicall"`.
 */
export function useFarmingCenterMulticall<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof farmingCenterABI, 'multicall'>['request']['abi'],
              'multicall',
              TMode
          > & { functionName?: 'multicall' }
        : UseContractWriteConfig<typeof farmingCenterABI, 'multicall', TMode> & {
              abi?: never
              functionName?: 'multicall'
          } = {} as any,
) {
    return useContractWrite<typeof farmingCenterABI, 'multicall', TMode>({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'multicall',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__.
 */
export function usePrepareFarmingCenterWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"applyLiquidityDelta"`.
 */
export function usePrepareFarmingCenterApplyLiquidityDelta(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'applyLiquidityDelta'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'applyLiquidityDelta',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'applyLiquidityDelta'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"burnPosition"`.
 */
export function usePrepareFarmingCenterBurnPosition(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'burnPosition'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'burnPosition',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'burnPosition'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"claimReward"`.
 */
export function usePrepareFarmingCenterClaimReward(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'claimReward'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'claimReward',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'claimReward'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"collectRewards"`.
 */
export function usePrepareFarmingCenterCollectRewards(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'collectRewards'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'collectRewards',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'collectRewards'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"connectVirtualPool"`.
 */
export function usePrepareFarmingCenterConnectVirtualPool(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'connectVirtualPool'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'connectVirtualPool',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'connectVirtualPool'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"decreaseLiquidity"`.
 */
export function usePrepareFarmingCenterDecreaseLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'decreaseLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'decreaseLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'decreaseLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"enterFarming"`.
 */
export function usePrepareFarmingCenterEnterFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'enterFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'enterFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'enterFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"exitFarming"`.
 */
export function usePrepareFarmingCenterExitFarming(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'exitFarming'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'exitFarming',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'exitFarming'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"increaseLiquidity"`.
 */
export function usePrepareFarmingCenterIncreaseLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'increaseLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'increaseLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'increaseLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link farmingCenterABI}__ and `functionName` set to `"multicall"`.
 */
export function usePrepareFarmingCenterMulticall(
    config: Omit<
        UsePrepareContractWriteConfig<typeof farmingCenterABI, 'multicall'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: farmingCenterABI,
        address: farmingCenterAddress,
        functionName: 'multicall',
        ...config,
    } as UsePrepareContractWriteConfig<typeof farmingCenterABI, 'multicall'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function useWrappedNativeRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi'
    > = {} as any,
) {
    return useContractRead({ abi: wrappedNativeABI, ...config } as UseContractReadConfig<
        typeof wrappedNativeABI,
        TFunctionName,
        TSelectData
    >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"name"`.
 */
export function useWrappedNativeName<
    TFunctionName extends 'name',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'name',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useWrappedNativeTotalSupply<
    TFunctionName extends 'totalSupply',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'totalSupply',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"decimals"`.
 */
export function useWrappedNativeDecimals<
    TFunctionName extends 'decimals',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'decimals',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useWrappedNativeBalanceOf<
    TFunctionName extends 'balanceOf',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'balanceOf',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"symbol"`.
 */
export function useWrappedNativeSymbol<
    TFunctionName extends 'symbol',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'symbol',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"allowance"`.
 */
export function useWrappedNativeAllowance<
    TFunctionName extends 'allowance',
    TSelectData = ReadContractResult<typeof wrappedNativeABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: wrappedNativeABI,
        functionName: 'allowance',
        ...config,
    } as UseContractReadConfig<typeof wrappedNativeABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function useWrappedNativeWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof wrappedNativeABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, TFunctionName, TMode>({
        abi: wrappedNativeABI,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"approve"`.
 */
export function useWrappedNativeApprove<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, 'approve'>['request']['abi'],
              'approve',
              TMode
          > & { functionName?: 'approve' }
        : UseContractWriteConfig<typeof wrappedNativeABI, 'approve', TMode> & {
              abi?: never
              functionName?: 'approve'
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, 'approve', TMode>({
        abi: wrappedNativeABI,
        functionName: 'approve',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useWrappedNativeTransferFrom<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, 'transferFrom'>['request']['abi'],
              'transferFrom',
              TMode
          > & { functionName?: 'transferFrom' }
        : UseContractWriteConfig<typeof wrappedNativeABI, 'transferFrom', TMode> & {
              abi?: never
              functionName?: 'transferFrom'
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, 'transferFrom', TMode>({
        abi: wrappedNativeABI,
        functionName: 'transferFrom',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"withdraw"`.
 */
export function useWrappedNativeWithdraw<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, 'withdraw'>['request']['abi'],
              'withdraw',
              TMode
          > & { functionName?: 'withdraw' }
        : UseContractWriteConfig<typeof wrappedNativeABI, 'withdraw', TMode> & {
              abi?: never
              functionName?: 'withdraw'
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, 'withdraw', TMode>({
        abi: wrappedNativeABI,
        functionName: 'withdraw',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"transfer"`.
 */
export function useWrappedNativeTransfer<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, 'transfer'>['request']['abi'],
              'transfer',
              TMode
          > & { functionName?: 'transfer' }
        : UseContractWriteConfig<typeof wrappedNativeABI, 'transfer', TMode> & {
              abi?: never
              functionName?: 'transfer'
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, 'transfer', TMode>({
        abi: wrappedNativeABI,
        functionName: 'transfer',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"deposit"`.
 */
export function useWrappedNativeDeposit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof wrappedNativeABI, 'deposit'>['request']['abi'],
              'deposit',
              TMode
          > & { functionName?: 'deposit' }
        : UseContractWriteConfig<typeof wrappedNativeABI, 'deposit', TMode> & {
              abi?: never
              functionName?: 'deposit'
          } = {} as any,
) {
    return useContractWrite<typeof wrappedNativeABI, 'deposit', TMode>({
        abi: wrappedNativeABI,
        functionName: 'deposit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__.
 */
export function usePrepareWrappedNativeWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, TFunctionName>,
        'abi'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareWrappedNativeApprove(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'approve'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        functionName: 'approve',
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'approve'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareWrappedNativeTransferFrom(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'transferFrom'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        functionName: 'transferFrom',
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'transferFrom'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"withdraw"`.
 */
export function usePrepareWrappedNativeWithdraw(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'withdraw'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        functionName: 'withdraw',
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'withdraw'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareWrappedNativeTransfer(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'transfer'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        functionName: 'transfer',
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'transfer'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link wrappedNativeABI}__ and `functionName` set to `"deposit"`.
 */
export function usePrepareWrappedNativeDeposit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'deposit'>,
        'abi' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: wrappedNativeABI,
        functionName: 'deposit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof wrappedNativeABI, 'deposit'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function useGammaHypervisorRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"DOMAIN_SEPARATOR"`.
 */
export function useGammaHypervisorDomainSeparator<
    TFunctionName extends 'DOMAIN_SEPARATOR',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'DOMAIN_SEPARATOR',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"PRECISION"`.
 */
export function useGammaHypervisorPrecision<
    TFunctionName extends 'PRECISION',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'PRECISION',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"allowance"`.
 */
export function useGammaHypervisorAllowance<
    TFunctionName extends 'allowance',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'allowance',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useGammaHypervisorBalanceOf<
    TFunctionName extends 'balanceOf',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'balanceOf',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"baseLower"`.
 */
export function useGammaHypervisorBaseLower<
    TFunctionName extends 'baseLower',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'baseLower',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"baseUpper"`.
 */
export function useGammaHypervisorBaseUpper<
    TFunctionName extends 'baseUpper',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'baseUpper',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"currentTick"`.
 */
export function useGammaHypervisorCurrentTick<
    TFunctionName extends 'currentTick',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'currentTick',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"decimals"`.
 */
export function useGammaHypervisorDecimals<
    TFunctionName extends 'decimals',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'decimals',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"deposit0Max"`.
 */
export function useGammaHypervisorDeposit0Max<
    TFunctionName extends 'deposit0Max',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'deposit0Max',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"deposit1Max"`.
 */
export function useGammaHypervisorDeposit1Max<
    TFunctionName extends 'deposit1Max',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'deposit1Max',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"directDeposit"`.
 */
export function useGammaHypervisorDirectDeposit<
    TFunctionName extends 'directDeposit',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'directDeposit',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"eip712Domain"`.
 */
export function useGammaHypervisorEip712Domain<
    TFunctionName extends 'eip712Domain',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'eip712Domain',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"fee"`.
 */
export function useGammaHypervisorFee<
    TFunctionName extends 'fee',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'fee',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"feeRecipient"`.
 */
export function useGammaHypervisorFeeRecipient<
    TFunctionName extends 'feeRecipient',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'feeRecipient',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"getBasePosition"`.
 */
export function useGammaHypervisorGetBasePosition<
    TFunctionName extends 'getBasePosition',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'getBasePosition',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"getLimitPosition"`.
 */
export function useGammaHypervisorGetLimitPosition<
    TFunctionName extends 'getLimitPosition',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'getLimitPosition',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"getTotalAmounts"`.
 */
export function useGammaHypervisorGetTotalAmounts<
    TFunctionName extends 'getTotalAmounts',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'getTotalAmounts',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"limitLower"`.
 */
export function useGammaHypervisorLimitLower<
    TFunctionName extends 'limitLower',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'limitLower',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"limitUpper"`.
 */
export function useGammaHypervisorLimitUpper<
    TFunctionName extends 'limitUpper',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'limitUpper',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"maxTotalSupply"`.
 */
export function useGammaHypervisorMaxTotalSupply<
    TFunctionName extends 'maxTotalSupply',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'maxTotalSupply',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"name"`.
 */
export function useGammaHypervisorName<
    TFunctionName extends 'name',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'name',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"nonces"`.
 */
export function useGammaHypervisorNonces<
    TFunctionName extends 'nonces',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'nonces',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"owner"`.
 */
export function useGammaHypervisorOwner<
    TFunctionName extends 'owner',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'owner',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"pool"`.
 */
export function useGammaHypervisorPool<
    TFunctionName extends 'pool',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'pool',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"symbol"`.
 */
export function useGammaHypervisorSymbol<
    TFunctionName extends 'symbol',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'symbol',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"tickSpacing"`.
 */
export function useGammaHypervisorTickSpacing<
    TFunctionName extends 'tickSpacing',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'tickSpacing',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"token0"`.
 */
export function useGammaHypervisorToken0<
    TFunctionName extends 'token0',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'token0',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"token1"`.
 */
export function useGammaHypervisorToken1<
    TFunctionName extends 'token1',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'token1',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useGammaHypervisorTotalSupply<
    TFunctionName extends 'totalSupply',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'totalSupply',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"whitelistedAddress"`.
 */
export function useGammaHypervisorWhitelistedAddress<
    TFunctionName extends 'whitelistedAddress',
    TSelectData = ReadContractResult<typeof gammaHypervisorABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'whitelistedAddress',
        ...config,
    } as UseContractReadConfig<typeof gammaHypervisorABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function useGammaHypervisorWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof gammaHypervisorABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, TFunctionName, TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"addLiquidity"`.
 */
export function useGammaHypervisorAddLiquidity<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'addLiquidity'
              >['request']['abi'],
              'addLiquidity',
              TMode
          > & { functionName?: 'addLiquidity' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'addLiquidity', TMode> & {
              abi?: never
              functionName?: 'addLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'addLiquidity', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'addLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"algebraMintCallback"`.
 */
export function useGammaHypervisorAlgebraMintCallback<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'algebraMintCallback'
              >['request']['abi'],
              'algebraMintCallback',
              TMode
          > & { functionName?: 'algebraMintCallback' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'algebraMintCallback', TMode> & {
              abi?: never
              functionName?: 'algebraMintCallback'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'algebraMintCallback', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'algebraMintCallback',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"approve"`.
 */
export function useGammaHypervisorApprove<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'approve'>['request']['abi'],
              'approve',
              TMode
          > & { functionName?: 'approve' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'approve', TMode> & {
              abi?: never
              functionName?: 'approve'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'approve', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'approve',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"compound"`.
 */
export function useGammaHypervisorCompound<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'compound'>['request']['abi'],
              'compound',
              TMode
          > & { functionName?: 'compound' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'compound', TMode> & {
              abi?: never
              functionName?: 'compound'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'compound', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'compound',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function useGammaHypervisorDecreaseAllowance<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'decreaseAllowance'
              >['request']['abi'],
              'decreaseAllowance',
              TMode
          > & { functionName?: 'decreaseAllowance' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'decreaseAllowance', TMode> & {
              abi?: never
              functionName?: 'decreaseAllowance'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'decreaseAllowance', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'decreaseAllowance',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"deposit"`.
 */
export function useGammaHypervisorDeposit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'deposit'>['request']['abi'],
              'deposit',
              TMode
          > & { functionName?: 'deposit' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'deposit', TMode> & {
              abi?: never
              functionName?: 'deposit'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'deposit', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'deposit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function useGammaHypervisorIncreaseAllowance<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'increaseAllowance'
              >['request']['abi'],
              'increaseAllowance',
              TMode
          > & { functionName?: 'increaseAllowance' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'increaseAllowance', TMode> & {
              abi?: never
              functionName?: 'increaseAllowance'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'increaseAllowance', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'increaseAllowance',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"permit"`.
 */
export function useGammaHypervisorPermit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'permit'>['request']['abi'],
              'permit',
              TMode
          > & { functionName?: 'permit' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'permit', TMode> & {
              abi?: never
              functionName?: 'permit'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'permit', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'permit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"pullLiquidity"`.
 */
export function useGammaHypervisorPullLiquidity<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'pullLiquidity'
              >['request']['abi'],
              'pullLiquidity',
              TMode
          > & { functionName?: 'pullLiquidity' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'pullLiquidity', TMode> & {
              abi?: never
              functionName?: 'pullLiquidity'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'pullLiquidity', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'pullLiquidity',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"rebalance"`.
 */
export function useGammaHypervisorRebalance<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'rebalance'>['request']['abi'],
              'rebalance',
              TMode
          > & { functionName?: 'rebalance' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'rebalance', TMode> & {
              abi?: never
              functionName?: 'rebalance'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'rebalance', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'rebalance',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"removeWhitelisted"`.
 */
export function useGammaHypervisorRemoveWhitelisted<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'removeWhitelisted'
              >['request']['abi'],
              'removeWhitelisted',
              TMode
          > & { functionName?: 'removeWhitelisted' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'removeWhitelisted', TMode> & {
              abi?: never
              functionName?: 'removeWhitelisted'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'removeWhitelisted', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'removeWhitelisted',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setFee"`.
 */
export function useGammaHypervisorSetFee<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'setFee'>['request']['abi'],
              'setFee',
              TMode
          > & { functionName?: 'setFee' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'setFee', TMode> & {
              abi?: never
              functionName?: 'setFee'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'setFee', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setFee',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setTickSpacing"`.
 */
export function useGammaHypervisorSetTickSpacing<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'setTickSpacing'
              >['request']['abi'],
              'setTickSpacing',
              TMode
          > & { functionName?: 'setTickSpacing' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'setTickSpacing', TMode> & {
              abi?: never
              functionName?: 'setTickSpacing'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'setTickSpacing', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setTickSpacing',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setWhitelist"`.
 */
export function useGammaHypervisorSetWhitelist<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'setWhitelist'
              >['request']['abi'],
              'setWhitelist',
              TMode
          > & { functionName?: 'setWhitelist' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'setWhitelist', TMode> & {
              abi?: never
              functionName?: 'setWhitelist'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'setWhitelist', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setWhitelist',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"toggleDirectDeposit"`.
 */
export function useGammaHypervisorToggleDirectDeposit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'toggleDirectDeposit'
              >['request']['abi'],
              'toggleDirectDeposit',
              TMode
          > & { functionName?: 'toggleDirectDeposit' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'toggleDirectDeposit', TMode> & {
              abi?: never
              functionName?: 'toggleDirectDeposit'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'toggleDirectDeposit', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'toggleDirectDeposit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transfer"`.
 */
export function useGammaHypervisorTransfer<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'transfer'>['request']['abi'],
              'transfer',
              TMode
          > & { functionName?: 'transfer' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'transfer', TMode> & {
              abi?: never
              functionName?: 'transfer'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'transfer', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transfer',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useGammaHypervisorTransferFrom<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'transferFrom'
              >['request']['abi'],
              'transferFrom',
              TMode
          > & { functionName?: 'transferFrom' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'transferFrom', TMode> & {
              abi?: never
              functionName?: 'transferFrom'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'transferFrom', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transferFrom',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function useGammaHypervisorTransferOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaHypervisorABI,
                  'transferOwnership'
              >['request']['abi'],
              'transferOwnership',
              TMode
          > & { functionName?: 'transferOwnership' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'transferOwnership', TMode> & {
              abi?: never
              functionName?: 'transferOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'transferOwnership', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transferOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"withdraw"`.
 */
export function useGammaHypervisorWithdraw<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaHypervisorABI, 'withdraw'>['request']['abi'],
              'withdraw',
              TMode
          > & { functionName?: 'withdraw' }
        : UseContractWriteConfig<typeof gammaHypervisorABI, 'withdraw', TMode> & {
              abi?: never
              functionName?: 'withdraw'
          } = {} as any,
) {
    return useContractWrite<typeof gammaHypervisorABI, 'withdraw', TMode>({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'withdraw',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__.
 */
export function usePrepareGammaHypervisorWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"addLiquidity"`.
 */
export function usePrepareGammaHypervisorAddLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'addLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'addLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'addLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"algebraMintCallback"`.
 */
export function usePrepareGammaHypervisorAlgebraMintCallback(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'algebraMintCallback'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'algebraMintCallback',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'algebraMintCallback'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareGammaHypervisorApprove(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'approve'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'approve',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'approve'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"compound"`.
 */
export function usePrepareGammaHypervisorCompound(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'compound'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'compound',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'compound'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function usePrepareGammaHypervisorDecreaseAllowance(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'decreaseAllowance'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'decreaseAllowance',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'decreaseAllowance'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"deposit"`.
 */
export function usePrepareGammaHypervisorDeposit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'deposit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'deposit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'deposit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function usePrepareGammaHypervisorIncreaseAllowance(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'increaseAllowance'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'increaseAllowance',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'increaseAllowance'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"permit"`.
 */
export function usePrepareGammaHypervisorPermit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'permit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'permit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'permit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"pullLiquidity"`.
 */
export function usePrepareGammaHypervisorPullLiquidity(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'pullLiquidity'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'pullLiquidity',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'pullLiquidity'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"rebalance"`.
 */
export function usePrepareGammaHypervisorRebalance(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'rebalance'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'rebalance',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'rebalance'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"removeWhitelisted"`.
 */
export function usePrepareGammaHypervisorRemoveWhitelisted(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'removeWhitelisted'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'removeWhitelisted',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'removeWhitelisted'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setFee"`.
 */
export function usePrepareGammaHypervisorSetFee(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setFee'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setFee',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setFee'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setTickSpacing"`.
 */
export function usePrepareGammaHypervisorSetTickSpacing(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setTickSpacing'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setTickSpacing',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setTickSpacing'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"setWhitelist"`.
 */
export function usePrepareGammaHypervisorSetWhitelist(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setWhitelist'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'setWhitelist',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'setWhitelist'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"toggleDirectDeposit"`.
 */
export function usePrepareGammaHypervisorToggleDirectDeposit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'toggleDirectDeposit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'toggleDirectDeposit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'toggleDirectDeposit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareGammaHypervisorTransfer(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transfer'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transfer',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transfer'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareGammaHypervisorTransferFrom(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transferFrom'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transferFrom',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transferFrom'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function usePrepareGammaHypervisorTransferOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transferOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'transferOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'transferOwnership'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaHypervisorABI}__ and `functionName` set to `"withdraw"`.
 */
export function usePrepareGammaHypervisorWithdraw(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'withdraw'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaHypervisorABI,
        address: gammaHypervisorAddress,
        functionName: 'withdraw',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaHypervisorABI, 'withdraw'>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function useGammaUniProxyRead<
    TFunctionName extends string,
    TSelectData = ReadContractResult<typeof gammaUniProxyABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>,
        'abi' | 'address'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"clearance"`.
 */
export function useGammaUniProxyClearance<
    TFunctionName extends 'clearance',
    TSelectData = ReadContractResult<typeof gammaUniProxyABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'clearance',
        ...config,
    } as UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"getDepositAmount"`.
 */
export function useGammaUniProxyGetDepositAmount<
    TFunctionName extends 'getDepositAmount',
    TSelectData = ReadContractResult<typeof gammaUniProxyABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'getDepositAmount',
        ...config,
    } as UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"owner"`.
 */
export function useGammaUniProxyOwner<
    TFunctionName extends 'owner',
    TSelectData = ReadContractResult<typeof gammaUniProxyABI, TFunctionName>,
>(
    config: Omit<
        UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return useContractRead({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'owner',
        ...config,
    } as UseContractReadConfig<typeof gammaUniProxyABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function useGammaUniProxyWrite<
    TFunctionName extends string,
    TMode extends WriteContractMode = undefined,
>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaUniProxyABI, string>['request']['abi'],
              TFunctionName,
              TMode
          >
        : UseContractWriteConfig<typeof gammaUniProxyABI, TFunctionName, TMode> & {
              abi?: never
          } = {} as any,
) {
    return useContractWrite<typeof gammaUniProxyABI, TFunctionName, TMode>({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"deposit"`.
 */
export function useGammaUniProxyDeposit<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<typeof gammaUniProxyABI, 'deposit'>['request']['abi'],
              'deposit',
              TMode
          > & { functionName?: 'deposit' }
        : UseContractWriteConfig<typeof gammaUniProxyABI, 'deposit', TMode> & {
              abi?: never
              functionName?: 'deposit'
          } = {} as any,
) {
    return useContractWrite<typeof gammaUniProxyABI, 'deposit', TMode>({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'deposit',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"transferClearance"`.
 */
export function useGammaUniProxyTransferClearance<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaUniProxyABI,
                  'transferClearance'
              >['request']['abi'],
              'transferClearance',
              TMode
          > & { functionName?: 'transferClearance' }
        : UseContractWriteConfig<typeof gammaUniProxyABI, 'transferClearance', TMode> & {
              abi?: never
              functionName?: 'transferClearance'
          } = {} as any,
) {
    return useContractWrite<typeof gammaUniProxyABI, 'transferClearance', TMode>({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'transferClearance',
        ...config,
    } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function useGammaUniProxyTransferOwnership<TMode extends WriteContractMode = undefined>(
    config: TMode extends 'prepared'
        ? UseContractWriteConfig<
              PrepareWriteContractResult<
                  typeof gammaUniProxyABI,
                  'transferOwnership'
              >['request']['abi'],
              'transferOwnership',
              TMode
          > & { functionName?: 'transferOwnership' }
        : UseContractWriteConfig<typeof gammaUniProxyABI, 'transferOwnership', TMode> & {
              abi?: never
              functionName?: 'transferOwnership'
          } = {} as any,
) {
    return useContractWrite<typeof gammaUniProxyABI, 'transferOwnership', TMode>({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'transferOwnership',
        ...config,
    } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__.
 */
export function usePrepareGammaUniProxyWrite<TFunctionName extends string>(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaUniProxyABI, TFunctionName>,
        'abi' | 'address'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaUniProxyABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"deposit"`.
 */
export function usePrepareGammaUniProxyDeposit(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'deposit'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'deposit',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'deposit'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"transferClearance"`.
 */
export function usePrepareGammaUniProxyTransferClearance(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'transferClearance'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'transferClearance',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'transferClearance'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link gammaUniProxyABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function usePrepareGammaUniProxyTransferOwnership(
    config: Omit<
        UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'transferOwnership'>,
        'abi' | 'address' | 'functionName'
    > = {} as any,
) {
    return usePrepareContractWrite({
        abi: gammaUniProxyABI,
        address: gammaUniProxyAddress,
        functionName: 'transferOwnership',
        ...config,
    } as UsePrepareContractWriteConfig<typeof gammaUniProxyABI, 'transferOwnership'>)
}



================================================
File: src/main.tsx
================================================
import "./styles/index.scss";
import React from "react";
import ReactDOM from "react-dom/client";
import { createBrowserRouter, Navigate, RouterProvider } from "react-router-dom";
import App from "./App.tsx";
import SwapPage from "@/pages/Swap";
import Page404 from "@/pages/Page404";
import PoolsPage from "@/pages/Pools";
import PoolPage from "@/pages/Pool";
import NewPositionPage from "@/pages/NewPosition";
import CreatePoolPage from "@/pages/CreatePool/index.tsx";
import { ApolloProvider } from "@apollo/client";
import { infoClient } from "@/graphql/clients";

const router = createBrowserRouter([
    {
        path: "/",
        element: <Navigate replace to={"/swap"} />,
        errorElement: <Page404 />,
    },
    {
        path: "/swap",
        element: (
            <App>
                <SwapPage />
            </App>
        ),
    },
    {
        path: "/pools",
        element: (
            <App>
                <PoolsPage />
            </App>
        ),
    },
    {
        path: "/pools/create",
        element: (
            <App>
                <CreatePoolPage />
            </App>
        ),
    },
    {
        path: "/pool/:pool",
        element: (
            <App>
                <PoolPage />
            </App>
        ),
    },
    {
        path: "/pool/:pool/new-position",
        element: (
            <App>
                <NewPositionPage />
            </App>
        ),
    },
]);

ReactDOM.createRoot(document.getElementById("root")!).render(
    <React.StrictMode>
        <ApolloProvider client={infoClient}>
            <RouterProvider router={router} />
        </ApolloProvider>
    </React.StrictMode>,
);



================================================
File: src/twin.d.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import "twin.macro";
import styledImport, { CSSProp, css as cssImport } from "styled-components";

declare module "twin.macro" {
    // The styled and css imports
    const styled: typeof styledImport;
    const css: typeof cssImport;
}

declare module "react" {
    // The css prop
    interface HTMLAttributes<T> extends DOMAttributes<T> {
        css?: CSSProp;
        tw?: string;
    }
    // The inline svg css prop
    interface SVGProps<T> extends SVGProps<SVGSVGElement> {
        css?: CSSProp;
        tw?: string;
    }
}

// The 'as' prop on styled components
declare global {
    // namespace JSX {
    //     interface IntrinsicAttributes<T> extends DOMAttributes<T> {
    //         as?: string | Element;
    //     }
    // }
}



================================================
File: src/vite-env.d.ts
================================================
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_ENVIRONMENT: Environment;

    readonly VITE_RPC_URL_PROD: string;
    readonly VITE_RPC_URL_DEV: string;

    readonly VITE_INFO_GRAPH_PROD: string;
    readonly VITE_INFO_GRAPH_DEV: string;

    readonly VITE_BLOCKS_GRAPH_PROD: string;
    readonly VITE_BLOCKS_GRAPH_DEV: string;

    readonly VITE_FARMING_GRAPH_PROD: string;
    readonly VITE_FARMING_GRAPH_DEV: string;

    readonly VITE_LIMIT_ORDERS_GRAPH_PROD: string;
    readonly VITE_LIMIT_ORDERS_GRAPH_DEV: string;

    readonly VITE_BACKEND_URL_PROD: string;
    readonly VITE_BACKEND_URL_DEV: string;

    readonly VITE_WALLETCONNECT_PROJECT_ID: string;
    readonly VITE_AD_POPUP_ENABLED: boolean;
}

interface ImportMeta {
    readonly env: ImportMetaEnv;
}



================================================
File: src/abis/IceCreamSwapRouter.ts
================================================
export const IceCreamSwapRouter = [
    {
        inputs: [
            { name: "_factoryV2", internalType: "address", type: "address" },
            { name: "_deployer", internalType: "address", type: "address" },
            { name: "_factoryV3", internalType: "address", type: "address" },
            { name: "_positionManager", internalType: "address", type: "address" },
            { name: "_stableFactory", internalType: "address", type: "address" },
            { name: "_stableInfo", internalType: "address", type: "address" },
            { name: "_WETH9", internalType: "address", type: "address" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [
            {
                indexed: true,
                name: "previousOwner",
                internalType: "address",
                type: "address",
            },
            {
                indexed: true,
                name: "newOwner",
                internalType: "address",
                type: "address",
            },
        ],
        name: "OwnershipTransferred",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [
            {
                indexed: true,
                name: "factory",
                internalType: "address",
                type: "address",
            },
            {
                indexed: true,
                name: "info",
                internalType: "address",
                type: "address",
            },
        ],
        name: "SetStableSwap",
        anonymous: false,
        type: "event",
    },
    { stateMutability: "nonpayable", type: "fallback" },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "WETH9",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "token", internalType: "address", type: "address" }],
        name: "approveMax",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "token", internalType: "address", type: "address" }],
        name: "approveMaxMinusOne",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "token", internalType: "address", type: "address" }],
        name: "approveZeroThenMax",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "token", internalType: "address", type: "address" }],
        name: "approveZeroThenMaxMinusOne",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "result", internalType: "bytes", type: "bytes" }],
        inputs: [{ name: "data", internalType: "bytes", type: "bytes" }],
        name: "callPositionManager",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "paths", internalType: "bytes[]", type: "bytes[]" },
            { name: "amounts", internalType: "uint128[]", type: "uint128[]" },
            {
                name: "maximumTickDivergence",
                internalType: "uint24",
                type: "uint24",
            },
            { name: "secondsAgo", internalType: "uint32", type: "uint32" },
        ],
        name: "checkOracleSlippage",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "path", internalType: "bytes", type: "bytes" },
            {
                name: "maximumTickDivergence",
                internalType: "uint24",
                type: "uint24",
            },
            { name: "secondsAgo", internalType: "uint32", type: "uint32" },
        ],
        name: "checkOracleSlippage",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "deployer",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }],
        inputs: [
            {
                components: [
                    { name: "path", internalType: "bytes", type: "bytes" },
                    { name: "recipient", internalType: "address", type: "address" },
                    { name: "amountIn", internalType: "uint256", type: "uint256" },
                    {
                        name: "amountOutMinimum",
                        internalType: "uint256",
                        type: "uint256",
                    },
                ],
                name: "params",
                internalType: "struct IV3SwapRouter.ExactInputParams",
                type: "tuple",
            },
        ],
        name: "exactInput",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }],
        inputs: [
            {
                components: [
                    { name: "pool", internalType: "address", type: "address" },
                    { name: "tokenIn", internalType: "address", type: "address" },
                    { name: "tokenOut", internalType: "address", type: "address" },
                    { name: "recipient", internalType: "address", type: "address" },
                    { name: "amountIn", internalType: "uint256", type: "uint256" },
                    {
                        name: "amountOutMinimum",
                        internalType: "uint256",
                        type: "uint256",
                    },
                    {
                        name: "sqrtPriceLimitX96",
                        internalType: "uint160",
                        type: "uint160",
                    },
                ],
                name: "params",
                internalType: "struct IV3SwapRouter.ExactInputSingleParams",
                type: "tuple",
            },
        ],
        name: "exactInputSingle",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "", internalType: "address[]", type: "address[]" },
            { name: "", internalType: "uint256[]", type: "uint256[]" },
            { name: "", internalType: "uint256", type: "uint256" },
            { name: "", internalType: "uint256", type: "uint256" },
            { name: "", internalType: "address", type: "address" },
        ],
        name: "exactInputStableSwap",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }],
        inputs: [
            {
                components: [
                    { name: "path", internalType: "bytes", type: "bytes" },
                    { name: "recipient", internalType: "address", type: "address" },
                    { name: "amountOut", internalType: "uint256", type: "uint256" },
                    {
                        name: "amountInMaximum",
                        internalType: "uint256",
                        type: "uint256",
                    },
                ],
                name: "params",
                internalType: "struct IV3SwapRouter.ExactOutputParams",
                type: "tuple",
            },
        ],
        name: "exactOutput",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }],
        inputs: [
            {
                components: [
                    { name: "pool", internalType: "address", type: "address" },
                    { name: "tokenIn", internalType: "address", type: "address" },
                    { name: "tokenOut", internalType: "address", type: "address" },
                    { name: "recipient", internalType: "address", type: "address" },
                    { name: "amountOut", internalType: "uint256", type: "uint256" },
                    {
                        name: "amountInMaximum",
                        internalType: "uint256",
                        type: "uint256",
                    },
                    {
                        name: "sqrtPriceLimitX96",
                        internalType: "uint160",
                        type: "uint160",
                    },
                ],
                name: "params",
                internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
                type: "tuple",
            },
        ],
        name: "exactOutputSingle",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "", internalType: "address[]", type: "address[]" },
            { name: "", internalType: "uint256[]", type: "uint256[]" },
            { name: "", internalType: "uint256", type: "uint256" },
            { name: "", internalType: "uint256", type: "uint256" },
            { name: "", internalType: "address", type: "address" },
        ],
        name: "exactOutputStableSwap",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "factory",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "factoryV2",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            {
                name: "",
                internalType: "enum IApproveAndCall.ApprovalType",
                type: "uint8",
            },
        ],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "amount", internalType: "uint256", type: "uint256" },
        ],
        name: "getApprovalType",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "result", internalType: "bytes", type: "bytes" }],
        inputs: [
            {
                components: [
                    { name: "token0", internalType: "address", type: "address" },
                    { name: "token1", internalType: "address", type: "address" },
                    { name: "tokenId", internalType: "uint256", type: "uint256" },
                    {
                        name: "amount0Min",
                        internalType: "uint256",
                        type: "uint256",
                    },
                    { name: "amount1Min", internalType: "uint256", type: "uint256" },
                ],
                name: "params",
                internalType: "struct IApproveAndCall.IncreaseLiquidityParams",
                type: "tuple",
            },
        ],
        name: "increaseLiquidity",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "result", internalType: "bytes", type: "bytes" }],
        inputs: [
            {
                components: [
                    { name: "token0", internalType: "address", type: "address" },
                    { name: "token1", internalType: "address", type: "address" },
                    { name: "fee", internalType: "uint24", type: "uint24" },
                    { name: "tickLower", internalType: "int24", type: "int24" },
                    { name: "tickUpper", internalType: "int24", type: "int24" },
                    {
                        name: "amount0Min",
                        internalType: "uint256",
                        type: "uint256",
                    },
                    {
                        name: "amount1Min",
                        internalType: "uint256",
                        type: "uint256",
                    },
                    { name: "recipient", internalType: "address", type: "address" },
                ],
                name: "params",
                internalType: "struct IApproveAndCall.MintParams",
                type: "tuple",
            },
        ],
        name: "mint",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bytes[]", type: "bytes[]" }],
        inputs: [
            { name: "previousBlockhash", internalType: "bytes32", type: "bytes32" },
            { name: "data", internalType: "bytes[]", type: "bytes[]" },
        ],
        name: "multicall",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bytes[]", type: "bytes[]" }],
        inputs: [
            { name: "deadline", internalType: "uint256", type: "uint256" },
            { name: "data", internalType: "bytes[]", type: "bytes[]" },
        ],
        name: "multicall",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "results", internalType: "bytes[]", type: "bytes[]" }],
        inputs: [{ name: "data", internalType: "bytes[]", type: "bytes[]" }],
        name: "multicall",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "owner",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "positionManager",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "value", internalType: "uint256", type: "uint256" },
        ],
        name: "pull",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [],
        name: "refundETH",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [],
        name: "renounceOwnership",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "value", internalType: "uint256", type: "uint256" },
            { name: "deadline", internalType: "uint256", type: "uint256" },
            { name: "v", internalType: "uint8", type: "uint8" },
            { name: "r", internalType: "bytes32", type: "bytes32" },
            { name: "s", internalType: "bytes32", type: "bytes32" },
        ],
        name: "selfPermit",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "nonce", internalType: "uint256", type: "uint256" },
            { name: "expiry", internalType: "uint256", type: "uint256" },
            { name: "v", internalType: "uint8", type: "uint8" },
            { name: "r", internalType: "bytes32", type: "bytes32" },
            { name: "s", internalType: "bytes32", type: "bytes32" },
        ],
        name: "selfPermitAllowed",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "nonce", internalType: "uint256", type: "uint256" },
            { name: "expiry", internalType: "uint256", type: "uint256" },
            { name: "v", internalType: "uint8", type: "uint8" },
            { name: "r", internalType: "bytes32", type: "bytes32" },
            { name: "s", internalType: "bytes32", type: "bytes32" },
        ],
        name: "selfPermitAllowedIfNecessary",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "value", internalType: "uint256", type: "uint256" },
            { name: "deadline", internalType: "uint256", type: "uint256" },
            { name: "v", internalType: "uint8", type: "uint8" },
            { name: "r", internalType: "bytes32", type: "bytes32" },
            { name: "s", internalType: "bytes32", type: "bytes32" },
        ],
        name: "selfPermitIfNecessary",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "", internalType: "address", type: "address" },
            { name: "", internalType: "address", type: "address" },
        ],
        name: "setStableSwap",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "stableSwapFactory",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "stableSwapInfo",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "amountIn", internalType: "uint256", type: "uint256" },
            { name: "amountOutMin", internalType: "uint256", type: "uint256" },
            { name: "path", internalType: "address[]", type: "address[]" },
            { name: "to", internalType: "address", type: "address" },
        ],
        name: "swapExactTokensForTokens",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "amountIn", internalType: "uint256", type: "uint256" },
            { name: "amountOutMin", internalType: "uint256", type: "uint256" },
            { name: "pools", internalType: "address[]", type: "address[]" },
            { name: "tokenIn", internalType: "address", type: "address" },
            { name: "tokenOut", internalType: "address", type: "address" },
            { name: "to", internalType: "address", type: "address" },
        ],
        name: "swapExactTokensForTokensExternal",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "amountOut", internalType: "uint256", type: "uint256" },
            { name: "amountInMax", internalType: "uint256", type: "uint256" },
            { name: "path", internalType: "address[]", type: "address[]" },
            { name: "to", internalType: "address", type: "address" },
        ],
        name: "swapTokensForExactTokens",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "recipient", internalType: "address", type: "address" },
        ],
        name: "sweepToken",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
        ],
        name: "sweepToken",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "feeBips", internalType: "uint256", type: "uint256" },
            { name: "feeRecipient", internalType: "address", type: "address" },
        ],
        name: "sweepTokenWithFee",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "token", internalType: "address", type: "address" },
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "recipient", internalType: "address", type: "address" },
            { name: "feeBips", internalType: "uint256", type: "uint256" },
            { name: "feeRecipient", internalType: "address", type: "address" },
        ],
        name: "sweepTokenWithFee",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newOwner", internalType: "address", type: "address" }],
        name: "transferOwnership",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "recipient", internalType: "address", type: "address" },
        ],
        name: "unwrapWETH9",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "recipient", internalType: "address", type: "address" },
            { name: "feeBips", internalType: "uint256", type: "uint256" },
            { name: "feeRecipient", internalType: "address", type: "address" },
        ],
        name: "unwrapWETH9WithFee",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "amountMinimum", internalType: "uint256", type: "uint256" },
            { name: "feeBips", internalType: "uint256", type: "uint256" },
            { name: "feeRecipient", internalType: "address", type: "address" },
        ],
        name: "unwrapWETH9WithFee",
        stateMutability: "payable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "value", internalType: "uint256", type: "uint256" }],
        name: "wrapETH",
        stateMutability: "payable",
        type: "function",
    },
    { stateMutability: "payable", type: "receive" },
] as const;



================================================
File: src/abis/algebraFactory.ts
================================================
export const algebraFactoryABI = [
    {
        inputs: [
            {
                internalType: 'address',
                name: '_poolDeployer',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'newDefaultCommunityFee',
                type: 'uint8',
            },
        ],
        name: 'DefaultCommunityFee',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'newFarmingAddress',
                type: 'address',
            },
        ],
        name: 'FarmingAddress',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint16',
                name: 'alpha1',
                type: 'uint16',
            },
            {
                indexed: false,
                internalType: 'uint16',
                name: 'alpha2',
                type: 'uint16',
            },
            {
                indexed: false,
                internalType: 'uint32',
                name: 'beta1',
                type: 'uint32',
            },
            {
                indexed: false,
                internalType: 'uint32',
                name: 'beta2',
                type: 'uint32',
            },
            {
                indexed: false,
                internalType: 'uint16',
                name: 'gamma1',
                type: 'uint16',
            },
            {
                indexed: false,
                internalType: 'uint16',
                name: 'gamma2',
                type: 'uint16',
            },
            {
                indexed: false,
                internalType: 'uint16',
                name: 'baseFee',
                type: 'uint16',
            },
        ],
        name: 'FeeConfiguration',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'previousOwner',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'newOwner',
                type: 'address',
            },
        ],
        name: 'OwnershipTransferStarted',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'previousOwner',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'newOwner',
                type: 'address',
            },
        ],
        name: 'OwnershipTransferred',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'token0',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'token1',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'pool',
                type: 'address',
            },
        ],
        name: 'Pool',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'previousAdminRole',
                type: 'bytes32',
            },
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'newAdminRole',
                type: 'bytes32',
            },
        ],
        name: 'RoleAdminChanged',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
        ],
        name: 'RoleGranted',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
        ],
        name: 'RoleRevoked',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'timestamp',
                type: 'uint256',
            },
        ],
        name: 'renounceOwnershipFinished',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'timestamp',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'finishTimestamp',
                type: 'uint256',
            },
        ],
        name: 'renounceOwnershipStarted',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'timestamp',
                type: 'uint256',
            },
        ],
        name: 'renounceOwnershipStopped',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DEFAULT_ADMIN_ROLE',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'acceptOwnership',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'baseFeeConfiguration',
        outputs: [
            {
                internalType: 'uint16',
                name: 'alpha1',
                type: 'uint16',
            },
            {
                internalType: 'uint16',
                name: 'alpha2',
                type: 'uint16',
            },
            {
                internalType: 'uint32',
                name: 'beta1',
                type: 'uint32',
            },
            {
                internalType: 'uint32',
                name: 'beta2',
                type: 'uint32',
            },
            {
                internalType: 'uint16',
                name: 'gamma1',
                type: 'uint16',
            },
            {
                internalType: 'uint16',
                name: 'gamma2',
                type: 'uint16',
            },
            {
                internalType: 'uint16',
                name: 'baseFee',
                type: 'uint16',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'communityVault',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'tokenA',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'tokenB',
                type: 'address',
            },
        ],
        name: 'createPool',
        outputs: [
            {
                internalType: 'address',
                name: 'pool',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'defaultCommunityFee',
        outputs: [
            {
                internalType: 'uint8',
                name: '',
                type: 'uint8',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'farmingAddress',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
        ],
        name: 'getRoleAdmin',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'uint256',
                name: 'index',
                type: 'uint256',
            },
        ],
        name: 'getRoleMember',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
        ],
        name: 'getRoleMemberCount',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'grantRole',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'hasRole',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'hasRoleOrOwner',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'owner',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'pendingOwner',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'poolByPair',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'poolDeployer',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'renounceOwnership',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'renounceOwnershipStartTimestamp',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'renounceRole',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'role',
                type: 'bytes32',
            },
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'revokeRole',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'uint16',
                        name: 'alpha1',
                        type: 'uint16',
                    },
                    {
                        internalType: 'uint16',
                        name: 'alpha2',
                        type: 'uint16',
                    },
                    {
                        internalType: 'uint32',
                        name: 'beta1',
                        type: 'uint32',
                    },
                    {
                        internalType: 'uint32',
                        name: 'beta2',
                        type: 'uint32',
                    },
                    {
                        internalType: 'uint16',
                        name: 'gamma1',
                        type: 'uint16',
                    },
                    {
                        internalType: 'uint16',
                        name: 'gamma2',
                        type: 'uint16',
                    },
                    {
                        internalType: 'uint16',
                        name: 'baseFee',
                        type: 'uint16',
                    },
                ],
                internalType: 'struct IAlgebraFeeConfiguration.Configuration',
                name: '_config',
                type: 'tuple',
            },
        ],
        name: 'setBaseFeeConfiguration',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint8',
                name: 'newDefaultCommunityFee',
                type: 'uint8',
            },
        ],
        name: 'setDefaultCommunityFee',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newFarmingAddress',
                type: 'address',
            },
        ],
        name: 'setFarmingAddress',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'startRenounceOwnership',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'stopRenounceOwnership',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes4',
                name: 'interfaceId',
                type: 'bytes4',
            },
        ],
        name: 'supportsInterface',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newOwner',
                type: 'address',
            },
        ],
        name: 'transferOwnership',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
] as const;



================================================
File: src/abis/algebraPool.ts
================================================
export const algebraPoolABI = [
    {
        "inputs": [],
        "name": "alreadyInitialized",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "arithmeticError",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "bottomTickLowerThanMIN",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "dynamicFeeActive",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "dynamicFeeDisabled",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "flashInsufficientPaid0",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "flashInsufficientPaid1",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "insufficientInputAmount",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "invalidAmountRequired",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "bytes4",
                "name": "selector",
                "type": "bytes4"
            }
        ],
        "name": "invalidHookResponse",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "invalidLimitSqrtPrice",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "invalidNewCommunityFee",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "invalidNewTickSpacing",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "liquidityAdd",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "liquidityOverflow",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "liquiditySub",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "locked",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "notAllowed",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "notInitialized",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "onlyFarming",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "pluginIsNotConnected",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "priceOutOfRange",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "tickInvalidLinks",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "tickIsNotInitialized",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "tickIsNotSpaced",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "tickOutOfRange",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "topTickAboveMAX",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "topTickLowerOrEqBottomTick",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "transferFailed",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "zeroAmountRequired",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "zeroLiquidityActual",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "zeroLiquidityDesired",
        "type": "error"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "liquidityAmount",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "name": "Burn",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "amount0",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "amount1",
                "type": "uint128"
            }
        ],
        "name": "Collect",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint16",
                "name": "communityFeeNew",
                "type": "uint16"
            }
        ],
        "name": "CommunityFee",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "name": "Fee",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "sender",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "paid0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "paid1",
                "type": "uint256"
            }
        ],
        "name": "Flash",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint160",
                "name": "price",
                "type": "uint160"
            },
            {
                "indexed": false,
                "internalType": "int24",
                "name": "tick",
                "type": "int24"
            }
        ],
        "name": "Initialize",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "sender",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "indexed": true,
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "liquidityAmount",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "name": "Mint",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "newPluginAddress",
                "type": "address"
            }
        ],
        "name": "Plugin",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint8",
                "name": "newPluginConfig",
                "type": "uint8"
            }
        ],
        "name": "PluginConfig",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "sender",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "int256",
                "name": "amount0",
                "type": "int256"
            },
            {
                "indexed": false,
                "internalType": "int256",
                "name": "amount1",
                "type": "int256"
            },
            {
                "indexed": false,
                "internalType": "uint160",
                "name": "price",
                "type": "uint160"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "int24",
                "name": "tick",
                "type": "int24"
            }
        ],
        "name": "Swap",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "int24",
                "name": "newTickSpacing",
                "type": "int24"
            }
        ],
        "name": "TickSpacing",
        "type": "event"
    },
    {
        "inputs": [
            {
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "internalType": "uint128",
                "name": "amount",
                "type": "uint128"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "burn",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "internalType": "uint128",
                "name": "amount0Requested",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "amount1Requested",
                "type": "uint128"
            }
        ],
        "name": "collect",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "amount0",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "amount1",
                "type": "uint128"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "communityFeeLastTimestamp",
        "outputs": [
            {
                "internalType": "uint32",
                "name": "",
                "type": "uint32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "communityVault",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "factory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "fee",
        "outputs": [
            {
                "internalType": "uint16",
                "name": "currentFee",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "flash",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getCommunityFeePending",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "globalState",
        "outputs": [
            {
                "internalType": "uint160",
                "name": "price",
                "type": "uint160"
            },
            {
                "internalType": "int24",
                "name": "tick",
                "type": "int24"
            },
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            },
            {
                "internalType": "uint8",
                "name": "pluginConfig",
                "type": "uint8"
            },
            {
                "internalType": "uint16",
                "name": "communityFee",
                "type": "uint16"
            },
            {
                "internalType": "bool",
                "name": "unlocked",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint160",
                "name": "initialPrice",
                "type": "uint160"
            }
        ],
        "name": "initialize",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "liquidity",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "maxLiquidityPerTick",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "",
                "type": "uint128"
            }
        ],
        "stateMutability": "pure",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "leftoversRecipient",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "int24",
                "name": "bottomTick",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "topTick",
                "type": "int24"
            },
            {
                "internalType": "uint128",
                "name": "liquidityDesired",
                "type": "uint128"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "mint",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            },
            {
                "internalType": "uint128",
                "name": "liquidityActual",
                "type": "uint128"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "nextTickGlobal",
        "outputs": [
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "plugin",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "name": "positions",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "liquidity",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "innerFeeGrowth0Token",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "innerFeeGrowth1Token",
                "type": "uint256"
            },
            {
                "internalType": "uint128",
                "name": "fees0",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "fees1",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "prevTickGlobal",
        "outputs": [
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint16",
                "name": "newCommunityFee",
                "type": "uint16"
            }
        ],
        "name": "setCommunityFee",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint16",
                "name": "newFee",
                "type": "uint16"
            }
        ],
        "name": "setFee",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "newPluginAddress",
                "type": "address"
            }
        ],
        "name": "setPlugin",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint8",
                "name": "newConfig",
                "type": "uint8"
            }
        ],
        "name": "setPluginConfig",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int24",
                "name": "newTickSpacing",
                "type": "int24"
            }
        ],
        "name": "setTickSpacing",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "zeroToOne",
                "type": "bool"
            },
            {
                "internalType": "int256",
                "name": "amountRequired",
                "type": "int256"
            },
            {
                "internalType": "uint160",
                "name": "limitSqrtPrice",
                "type": "uint160"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "swap",
        "outputs": [
            {
                "internalType": "int256",
                "name": "amount0",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "amount1",
                "type": "int256"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "leftoversRecipient",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "zeroToOne",
                "type": "bool"
            },
            {
                "internalType": "int256",
                "name": "amountToSell",
                "type": "int256"
            },
            {
                "internalType": "uint160",
                "name": "limitSqrtPrice",
                "type": "uint160"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "swapWithPaymentInAdvance",
        "outputs": [
            {
                "internalType": "int256",
                "name": "amount0",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "amount1",
                "type": "int256"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "tickSpacing",
        "outputs": [
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int16",
                "name": "",
                "type": "int16"
            }
        ],
        "name": "tickTable",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            }
        ],
        "name": "ticks",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "liquidityTotal",
                "type": "uint256"
            },
            {
                "internalType": "int128",
                "name": "liquidityDelta",
                "type": "int128"
            },
            {
                "internalType": "int24",
                "name": "prevTick",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "nextTick",
                "type": "int24"
            },
            {
                "internalType": "uint256",
                "name": "outerFeeGrowth0Token",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "outerFeeGrowth1Token",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalFeeGrowth0Token",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalFeeGrowth1Token",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
] as const



================================================
File: src/abis/algebraPoolDeployer.ts
================================================
export const algebraPoolDeployerABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_communityVault",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "plugin",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token0",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token1",
                "type": "address"
            }
        ],
        "name": "deploy",
        "outputs": [
            {
                "internalType": "address",
                "name": "pool",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getDeployParameters",
        "outputs": [
            {
                "internalType": "address",
                "name": "_plugin",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_communityVault",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_token0",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_token1",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
] as const


================================================
File: src/abis/algebraPositionManager.ts
================================================
export const algebraPositionManagerABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_WNativeToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_tokenDescriptor_",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_poolDeployer",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "tickOutOfRange",
        "type": "error"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "approved",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "Approval",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "bool",
                "name": "approved",
                "type": "bool"
            }
        ],
        "name": "ApprovalForAll",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "name": "Collect",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "name": "DecreaseLiquidity",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "farmingCenterAddress",
                "type": "address"
            }
        ],
        "name": "FarmingCenter",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "FarmingFailed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "liquidityDesired",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint128",
                "name": "actualLiquidity",
                "type": "uint128"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "pool",
                "type": "address"
            }
        ],
        "name": "IncreaseLiquidity",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "Transfer",
        "type": "event"
    },
    {
        "inputs": [],
        "name": "DOMAIN_SEPARATOR",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "PERMIT_TYPEHASH",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "WNativeToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amount0Owed",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1Owed",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "algebraMintCallback",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "approve",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "approve",
                "type": "bool"
            },
            {
                "internalType": "address",
                "name": "farmingAddress",
                "type": "address"
            }
        ],
        "name": "approveForFarming",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "burn",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint128",
                        "name": "amount0Max",
                        "type": "uint128"
                    },
                    {
                        "internalType": "uint128",
                        "name": "amount1Max",
                        "type": "uint128"
                    }
                ],
                "internalType": "struct INonfungiblePositionManager.CollectParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "collect",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token0",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token1",
                "type": "address"
            },
            {
                "internalType": "uint160",
                "name": "sqrtPriceX96",
                "type": "uint160"
            }
        ],
        "name": "createAndInitializePoolIfNecessary",
        "outputs": [
            {
                "internalType": "address",
                "name": "pool",
                "type": "address"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint128",
                        "name": "liquidity",
                        "type": "uint128"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount0Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount1Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct INonfungiblePositionManager.DecreaseLiquidityParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "decreaseLiquidity",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "factory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "farmingApprovals",
        "outputs": [
            {
                "internalType": "address",
                "name": "farmingCenterAddress",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "farmingCenter",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "getApproved",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount0Desired",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount1Desired",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount0Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount1Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct INonfungiblePositionManager.IncreaseLiquidityParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "increaseLiquidity",
        "outputs": [
            {
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            }
        ],
        "name": "isApprovedForAll",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "spender",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "isApprovedOrOwner",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "token0",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "token1",
                        "type": "address"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickLower",
                        "type": "int24"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickUpper",
                        "type": "int24"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount0Desired",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount1Desired",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount0Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount1Min",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct INonfungiblePositionManager.MintParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "mint",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "internalType": "uint256",
                "name": "amount0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount1",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes[]",
                "name": "data",
                "type": "bytes[]"
            }
        ],
        "name": "multicall",
        "outputs": [
            {
                "internalType": "bytes[]",
                "name": "results",
                "type": "bytes[]"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "name",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "ownerOf",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "spender",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "permit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "poolDeployer",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "positions",
        "outputs": [
            {
                "internalType": "uint88",
                "name": "nonce",
                "type": "uint88"
            },
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token0",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token1",
                "type": "address"
            },
            {
                "internalType": "int24",
                "name": "tickLower",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "tickUpper",
                "type": "int24"
            },
            {
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "internalType": "uint256",
                "name": "feeGrowthInside0LastX128",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "feeGrowthInside1LastX128",
                "type": "uint256"
            },
            {
                "internalType": "uint128",
                "name": "tokensOwed0",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "tokensOwed1",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "refundNativeToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "value",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "nonce",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "expiry",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitAllowed",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "nonce",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "expiry",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitAllowedIfNecessary",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "value",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitIfNecessary",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "approved",
                "type": "bool"
            }
        ],
        "name": "setApprovalForAll",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "newFarmingCenter",
                "type": "address"
            }
        ],
        "name": "setFarmingCenter",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes4",
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "name": "supportsInterface",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "sweepToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "toActive",
                "type": "bool"
            }
        ],
        "name": "switchFarmingStatus",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "tokenByIndex",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "tokenFarmedIn",
        "outputs": [
            {
                "internalType": "address",
                "name": "farmingCenterAddress",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "tokenOfOwnerByIndex",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "tokenURI",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "transferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "unwrapWNativeToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "stateMutability": "payable",
        "type": "receive"
    }
] as const


================================================
File: src/abis/algebraQuoter.ts
================================================
export const algebraQuoterABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_WNativeToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_poolDeployer",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "WNativeToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int256",
                "name": "amount0Delta",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "amount1Delta",
                "type": "int256"
            },
            {
                "internalType": "uint256",
                "name": "feeAmount",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            }
        ],
        "name": "algebraSwapCallback",
        "outputs": [],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "factory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "poolDeployer",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "name": "quoteExactInput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint16[]",
                "name": "fees",
                "type": "uint16[]"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenIn",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenOut",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint160",
                "name": "limitSqrtPrice",
                "type": "uint160"
            }
        ],
        "name": "quoteExactInputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            }
        ],
        "name": "quoteExactOutput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint16[]",
                "name": "fees",
                "type": "uint16[]"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "tokenIn",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "tokenOut",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint160",
                "name": "limitSqrtPrice",
                "type": "uint160"
            }
        ],
        "name": "quoteExactOutputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    }
] as const



================================================
File: src/abis/algebraQuoterV2.ts
================================================
export const algebraQuoterV2ABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_WNativeToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_poolDeployer",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "WNativeToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int256",
                "name": "amount0Delta",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "amount1Delta",
                "type": "int256"
            },
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            }
        ],
        "name": "algebraSwapCallback",
        "outputs": [],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "factory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "poolDeployer",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "amountInRequired",
                "type": "uint256"
            }
        ],
        "name": "quoteExactInput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint160[]",
                "name": "sqrtPriceX96AfterList",
                "type": "uint160[]"
            },
            {
                "internalType": "uint32[]",
                "name": "initializedTicksCrossedList",
                "type": "uint32[]"
            },
            {
                "internalType": "uint256",
                "name": "gasEstimate",
                "type": "uint256"
            },
            {
                "internalType": "uint16[]",
                "name": "feeList",
                "type": "uint16[]"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint160",
                        "name": "limitSqrtPrice",
                        "type": "uint160"
                    }
                ],
                "internalType": "struct IQuoterV2.QuoteExactInputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "quoteExactInputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint160",
                "name": "sqrtPriceX96After",
                "type": "uint160"
            },
            {
                "internalType": "uint32",
                "name": "initializedTicksCrossed",
                "type": "uint32"
            },
            {
                "internalType": "uint256",
                "name": "gasEstimate",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes",
                "name": "path",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "amountOutRequired",
                "type": "uint256"
            }
        ],
        "name": "quoteExactOutput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint160[]",
                "name": "sqrtPriceX96AfterList",
                "type": "uint160[]"
            },
            {
                "internalType": "uint32[]",
                "name": "initializedTicksCrossedList",
                "type": "uint32[]"
            },
            {
                "internalType": "uint256",
                "name": "gasEstimate",
                "type": "uint256"
            },
            {
                "internalType": "uint16[]",
                "name": "feeList",
                "type": "uint16[]"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint160",
                        "name": "limitSqrtPrice",
                        "type": "uint160"
                    }
                ],
                "internalType": "struct IQuoterV2.QuoteExactOutputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "quoteExactOutputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "uint160",
                "name": "sqrtPriceX96After",
                "type": "uint160"
            },
            {
                "internalType": "uint32",
                "name": "initializedTicksCrossed",
                "type": "uint32"
            },
            {
                "internalType": "uint256",
                "name": "gasEstimate",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    }
] as const


================================================
File: src/abis/algebraRouter.ts
================================================
export const algebraRouterABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_WNativeToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_poolDeployer",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "WNativeToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "int256",
                "name": "amount0Delta",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "amount1Delta",
                "type": "int256"
            },
            {
                "internalType": "bytes",
                "name": "_data",
                "type": "bytes"
            }
        ],
        "name": "algebraSwapCallback",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "bytes",
                        "name": "path",
                        "type": "bytes"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMinimum",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct ISwapRouter.ExactInputParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactInput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMinimum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint160",
                        "name": "limitSqrtPrice",
                        "type": "uint160"
                    }
                ],
                "internalType": "struct ISwapRouter.ExactInputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactInputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountIn",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOutMinimum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint160",
                        "name": "limitSqrtPrice",
                        "type": "uint160"
                    }
                ],
                "internalType": "struct ISwapRouter.ExactInputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactInputSingleSupportingFeeOnTransferTokens",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountOut",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "bytes",
                        "name": "path",
                        "type": "bytes"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountInMaximum",
                        "type": "uint256"
                    }
                ],
                "internalType": "struct ISwapRouter.ExactOutputParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactOutput",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "tokenIn",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenOut",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "deadline",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountOut",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amountInMaximum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint160",
                        "name": "limitSqrtPrice",
                        "type": "uint160"
                    }
                ],
                "internalType": "struct ISwapRouter.ExactOutputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactOutputSingle",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "factory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes[]",
                "name": "data",
                "type": "bytes[]"
            }
        ],
        "name": "multicall",
        "outputs": [
            {
                "internalType": "bytes[]",
                "name": "results",
                "type": "bytes[]"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "poolDeployer",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "refundNativeToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "value",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "nonce",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "expiry",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitAllowed",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "nonce",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "expiry",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitAllowedIfNecessary",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "value",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint8",
                "name": "v",
                "type": "uint8"
            },
            {
                "internalType": "bytes32",
                "name": "r",
                "type": "bytes32"
            },
            {
                "internalType": "bytes32",
                "name": "s",
                "type": "bytes32"
            }
        ],
        "name": "selfPermitIfNecessary",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "sweepToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "feeBips",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "feeRecipient",
                "type": "address"
            }
        ],
        "name": "sweepTokenWithFee",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "unwrapWNativeToken",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amountMinimum",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "feeBips",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "feeRecipient",
                "type": "address"
            }
        ],
        "name": "unwrapWNativeTokenWithFee",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "stateMutability": "payable",
        "type": "receive"
    }
] as const


================================================
File: src/abis/gammaHypervisor.ts
================================================
export const gammaHypervisorABI = [
    {
        inputs: [
            { name: "_pool", internalType: "address", type: "address" },
            { name: "_owner", internalType: "address", type: "address" },
            { name: "name", internalType: "string", type: "string" },
            { name: "symbol", internalType: "string", type: "string" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    { inputs: [], name: "InvalidShortString", type: "error" },
    {
        inputs: [{ name: "str", internalType: "string", type: "string" }],
        name: "StringTooLong",
        type: "error",
    },
    { inputs: [], name: "tickOutOfRange", type: "error" },
    {
        inputs: [
            { indexed: true, name: "owner", internalType: "address", type: "address" },
            { indexed: true, name: "spender", internalType: "address", type: "address" },
            { indexed: false, name: "value", internalType: "uint256", type: "uint256" },
        ],
        name: "Approval",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [
            { indexed: true, name: "sender", internalType: "address", type: "address" },
            { indexed: true, name: "to", internalType: "address", type: "address" },
            { indexed: false, name: "shares", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "amount0", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        name: "Deposit",
        anonymous: false,
        type: "event",
    },
    { inputs: [], name: "EIP712DomainChanged", anonymous: false, type: "event" },
    {
        inputs: [
            { indexed: false, name: "tick", internalType: "int24", type: "int24" },
            { indexed: false, name: "totalAmount0", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "totalAmount1", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "feeAmount0", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "feeAmount1", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "totalSupply", internalType: "uint256", type: "uint256" },
        ],
        name: "Rebalance",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [{ indexed: false, name: "newFee", internalType: "uint8", type: "uint8" }],
        name: "SetFee",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [
            { indexed: true, name: "from", internalType: "address", type: "address" },
            { indexed: true, name: "to", internalType: "address", type: "address" },
            { indexed: false, name: "value", internalType: "uint256", type: "uint256" },
        ],
        name: "Transfer",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [
            { indexed: true, name: "sender", internalType: "address", type: "address" },
            { indexed: true, name: "to", internalType: "address", type: "address" },
            { indexed: false, name: "shares", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "amount0", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        name: "Withdraw",
        anonymous: false,
        type: "event",
    },
    {
        inputs: [
            { indexed: false, name: "fee", internalType: "uint8", type: "uint8" },
            { indexed: false, name: "fees0", internalType: "uint256", type: "uint256" },
            { indexed: false, name: "fees1", internalType: "uint256", type: "uint256" },
        ],
        name: "ZeroBurn",
        anonymous: false,
        type: "event",
    },
    {
        outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }],
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [],
        name: "PRECISION",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "tickLower", internalType: "int24", type: "int24" },
            { name: "tickUpper", internalType: "int24", type: "int24" },
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
            { name: "inMin", internalType: "uint256[2]", type: "uint256[2]" },
        ],
        name: "addLiquidity",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
            { name: "data", internalType: "bytes", type: "bytes" },
        ],
        name: "algebraMintCallback",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "owner", internalType: "address", type: "address" },
            { name: "spender", internalType: "address", type: "address" },
        ],
        name: "allowance",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [
            { name: "spender", internalType: "address", type: "address" },
            { name: "amount", internalType: "uint256", type: "uint256" },
        ],
        name: "approve",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [{ name: "account", internalType: "address", type: "address" }],
        name: "balanceOf",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "baseLower",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "baseUpper",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "baseToken0Owed", internalType: "uint128", type: "uint128" },
            { name: "baseToken1Owed", internalType: "uint128", type: "uint128" },
            { name: "limitToken0Owed", internalType: "uint128", type: "uint128" },
            { name: "limitToken1Owed", internalType: "uint128", type: "uint128" },
        ],
        inputs: [{ name: "inMin", internalType: "uint256[4]", type: "uint256[4]" }],
        name: "compound",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "tick", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "currentTick",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint8", type: "uint8" }],
        inputs: [],
        name: "decimals",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [
            { name: "spender", internalType: "address", type: "address" },
            { name: "subtractedValue", internalType: "uint256", type: "uint256" },
        ],
        name: "decreaseAllowance",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "deposit0", internalType: "uint256", type: "uint256" },
            { name: "deposit1", internalType: "uint256", type: "uint256" },
            { name: "to", internalType: "address", type: "address" },
            { name: "from", internalType: "address", type: "address" },
            { name: "inMin", internalType: "uint256[4]", type: "uint256[4]" },
        ],
        name: "deposit",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [],
        name: "deposit0Max",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [],
        name: "deposit1Max",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [],
        name: "directDeposit",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "fields", internalType: "bytes1", type: "bytes1" },
            { name: "name", internalType: "string", type: "string" },
            { name: "version", internalType: "string", type: "string" },
            { name: "chainId", internalType: "uint256", type: "uint256" },
            { name: "verifyingContract", internalType: "address", type: "address" },
            { name: "salt", internalType: "bytes32", type: "bytes32" },
            { name: "extensions", internalType: "uint256[]", type: "uint256[]" },
        ],
        inputs: [],
        name: "eip712Domain",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint8", type: "uint8" }],
        inputs: [],
        name: "fee",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "feeRecipient",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "liquidity", internalType: "uint128", type: "uint128" },
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        inputs: [],
        name: "getBasePosition",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "liquidity", internalType: "uint128", type: "uint128" },
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        inputs: [],
        name: "getLimitPosition",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "total0", internalType: "uint256", type: "uint256" },
            { name: "total1", internalType: "uint256", type: "uint256" },
        ],
        inputs: [],
        name: "getTotalAmounts",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [
            { name: "spender", internalType: "address", type: "address" },
            { name: "addedValue", internalType: "uint256", type: "uint256" },
        ],
        name: "increaseAllowance",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "limitLower",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "limitUpper",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [],
        name: "maxTotalSupply",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "string", type: "string" }],
        inputs: [],
        name: "name",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [{ name: "owner", internalType: "address", type: "address" }],
        name: "nonces",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "owner",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "owner", internalType: "address", type: "address" },
            { name: "spender", internalType: "address", type: "address" },
            { name: "value", internalType: "uint256", type: "uint256" },
            { name: "deadline", internalType: "uint256", type: "uint256" },
            { name: "v", internalType: "uint8", type: "uint8" },
            { name: "r", internalType: "bytes32", type: "bytes32" },
            { name: "s", internalType: "bytes32", type: "bytes32" },
        ],
        name: "permit",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "contract IAlgebraPool", type: "address" }],
        inputs: [],
        name: "pool",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        inputs: [
            { name: "tickLower", internalType: "int24", type: "int24" },
            { name: "tickUpper", internalType: "int24", type: "int24" },
            { name: "shares", internalType: "uint128", type: "uint128" },
            { name: "amountMin", internalType: "uint256[2]", type: "uint256[2]" },
        ],
        name: "pullLiquidity",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [
            { name: "_baseLower", internalType: "int24", type: "int24" },
            { name: "_baseUpper", internalType: "int24", type: "int24" },
            { name: "_limitLower", internalType: "int24", type: "int24" },
            { name: "_limitUpper", internalType: "int24", type: "int24" },
            { name: "_feeRecipient", internalType: "address", type: "address" },
            { name: "inMin", internalType: "uint256[4]", type: "uint256[4]" },
            { name: "outMin", internalType: "uint256[4]", type: "uint256[4]" },
        ],
        name: "rebalance",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [],
        name: "removeWhitelisted",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newFee", internalType: "uint8", type: "uint8" }],
        name: "setFee",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newTickSpacing", internalType: "int24", type: "int24" }],
        name: "setTickSpacing",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "_address", internalType: "address", type: "address" }],
        name: "setWhitelist",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "string", type: "string" }],
        inputs: [],
        name: "symbol",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "int24", type: "int24" }],
        inputs: [],
        name: "tickSpacing",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [],
        name: "toggleDirectDeposit",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "contract IERC20", type: "address" }],
        inputs: [],
        name: "token0",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "contract IERC20", type: "address" }],
        inputs: [],
        name: "token1",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
        inputs: [],
        name: "totalSupply",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [
            { name: "to", internalType: "address", type: "address" },
            { name: "amount", internalType: "uint256", type: "uint256" },
        ],
        name: "transfer",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "bool", type: "bool" }],
        inputs: [
            { name: "from", internalType: "address", type: "address" },
            { name: "to", internalType: "address", type: "address" },
            { name: "amount", internalType: "uint256", type: "uint256" },
        ],
        name: "transferFrom",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newOwner", internalType: "address", type: "address" }],
        name: "transferOwnership",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "whitelistedAddress",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [
            { name: "amount0", internalType: "uint256", type: "uint256" },
            { name: "amount1", internalType: "uint256", type: "uint256" },
        ],
        inputs: [
            { name: "shares", internalType: "uint256", type: "uint256" },
            { name: "to", internalType: "address", type: "address" },
            { name: "from", internalType: "address", type: "address" },
            { name: "minAmounts", internalType: "uint256[4]", type: "uint256[4]" },
        ],
        name: "withdraw",
        stateMutability: "nonpayable",
        type: "function",
    },
] as const;



================================================
File: src/abis/gammaUniProxy.ts
================================================
export const gammaUniProxyABI = [
    {
        inputs: [
            { name: "_clearance", internalType: "address", type: "address" },
            { name: "_owner", internalType: "address", type: "address" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        outputs: [{ name: "", internalType: "contract IClearing", type: "address" }],
        inputs: [],
        name: "clearance",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
        inputs: [
            { name: "deposit0", internalType: "uint256", type: "uint256" },
            { name: "deposit1", internalType: "uint256", type: "uint256" },
            { name: "to", internalType: "address", type: "address" },
            { name: "pos", internalType: "address", type: "address" },
            { name: "minIn", internalType: "uint256[4]", type: "uint256[4]" },
        ],
        name: "deposit",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [
            { name: "amountStart", internalType: "uint256", type: "uint256" },
            { name: "amountEnd", internalType: "uint256", type: "uint256" },
        ],
        inputs: [
            { name: "pos", internalType: "address", type: "address" },
            { name: "token", internalType: "address", type: "address" },
            { name: "_deposit", internalType: "uint256", type: "uint256" },
        ],
        name: "getDepositAmount",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [{ name: "", internalType: "address", type: "address" }],
        inputs: [],
        name: "owner",
        stateMutability: "view",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newClearance", internalType: "address", type: "address" }],
        name: "transferClearance",
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        outputs: [],
        inputs: [{ name: "newOwner", internalType: "address", type: "address" }],
        name: "transferOwnership",
        stateMutability: "nonpayable",
        type: "function",
    },
] as const;



================================================
File: src/abis/index.ts
================================================
export * from "./algebraFactory";
export * from "./algebraPool";
export * from "./algebraPositionManager";
export * from "./algebraQuoter";
export * from "./algebraQuoterV2";
export * from "./algebraRouter";
export * from "./plugins";
export * from "./farming";
export * from "./tokens";
export * from "./gammaHypervisor";
export * from "./gammaUniProxy";



================================================
File: src/abis/farming/algebraEternalFarming.ts
================================================
export const algebraEternalFarmingABI = [
    {
        inputs: [
            {
                internalType: 'contract IAlgebraPoolDeployer',
                name: '_deployer',
                type: 'address',
            },
            {
                internalType: 'contract INonfungiblePositionManager',
                name: '_nonfungiblePositionManager',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
    {
        inputs: [],
        name: 'anotherFarmingIsActive',
        type: 'error',
    },
    {
        inputs: [],
        name: 'claimToZeroAddress',
        type: 'error',
    },
    {
        inputs: [],
        name: 'emergencyActivated',
        type: 'error',
    },
    {
        inputs: [],
        name: 'farmDoesNotExist',
        type: 'error',
    },
    {
        inputs: [],
        name: 'incentiveNotExist',
        type: 'error',
    },
    {
        inputs: [],
        name: 'incentiveStopped',
        type: 'error',
    },
    {
        inputs: [],
        name: 'invalidPool',
        type: 'error',
    },
    {
        inputs: [],
        name: 'invalidTokenAmount',
        type: 'error',
    },
    {
        inputs: [],
        name: 'minimalPositionWidthTooWide',
        type: 'error',
    },
    {
        inputs: [],
        name: 'pluginNotConnected',
        type: 'error',
    },
    {
        inputs: [],
        name: 'poolReentrancyLock',
        type: 'error',
    },
    {
        inputs: [],
        name: 'positionIsTooNarrow',
        type: 'error',
    },
    {
        inputs: [],
        name: 'reentrancyLock',
        type: 'error',
    },
    {
        inputs: [],
        name: 'tokenAlreadyFarmed',
        type: 'error',
    },
    {
        inputs: [],
        name: 'zeroLiquidity',
        type: 'error',
    },
    {
        inputs: [],
        name: 'zeroRewardAmount',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'bool',
                name: 'newStatus',
                type: 'bool',
            },
        ],
        name: 'EmergencyWithdraw',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'contract IERC20Minimal',
                name: 'bonusRewardToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'contract IAlgebraPool',
                name: 'pool',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'virtualPool',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'nonce',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'bonusReward',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint24',
                name: 'minimalAllowedPositionWidth',
                type: 'uint24',
            },
        ],
        name: 'EternalFarmingCreated',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'rewardAddress',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'bonusRewardToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'bonusReward',
                type: 'uint256',
            },
        ],
        name: 'FarmEnded',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
            {
                indexed: false,
                internalType: 'uint128',
                name: 'liquidity',
                type: 'uint128',
            },
        ],
        name: 'FarmEntered',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'farmingCenter',
                type: 'address',
            },
        ],
        name: 'FarmingCenter',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'IncentiveDeactivated',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'rewardAmount',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'bonusRewardAmount',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'RewardAmountsDecreased',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'rewardAddress',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'RewardClaimed',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'rewardAmount',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'bonusRewardAmount',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'RewardsAdded',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'rewardAmount',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'bonusRewardAmount',
                type: 'uint256',
            },
        ],
        name: 'RewardsCollected',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint128',
                name: 'rewardRate',
                type: 'uint128',
            },
            {
                indexed: false,
                internalType: 'uint128',
                name: 'bonusRewardRate',
                type: 'uint128',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'RewardsRatesChanged',
        type: 'event',
    },
    {
        inputs: [],
        name: 'FARMINGS_ADMINISTRATOR_ROLE',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'INCENTIVE_MAKER_ROLE',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint128',
                name: 'rewardAmount',
                type: 'uint128',
            },
            {
                internalType: 'uint128',
                name: 'bonusRewardAmount',
                type: 'uint128',
            },
        ],
        name: 'addRewards',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amountRequested',
                type: 'uint256',
            },
        ],
        name: 'claimReward',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amountRequested',
                type: 'uint256',
            },
        ],
        name: 'claimRewardFrom',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'collectRewards',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'bonusReward',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                components: [
                    {
                        internalType: 'uint128',
                        name: 'reward',
                        type: 'uint128',
                    },
                    {
                        internalType: 'uint128',
                        name: 'bonusReward',
                        type: 'uint128',
                    },
                    {
                        internalType: 'uint128',
                        name: 'rewardRate',
                        type: 'uint128',
                    },
                    {
                        internalType: 'uint128',
                        name: 'bonusRewardRate',
                        type: 'uint128',
                    },
                    {
                        internalType: 'uint24',
                        name: 'minimalPositionWidth',
                        type: 'uint24',
                    },
                ],
                internalType: 'struct IAlgebraEternalFarming.IncentiveParams',
                name: 'params',
                type: 'tuple',
            },
            {
                internalType: 'address',
                name: 'plugin',
                type: 'address',
            },
        ],
        name: 'createEternalFarming',
        outputs: [
            {
                internalType: 'address',
                name: 'virtualPool',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
        ],
        name: 'deactivateIncentive',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint128',
                name: 'rewardAmount',
                type: 'uint128',
            },
            {
                internalType: 'uint128',
                name: 'bonusRewardAmount',
                type: 'uint128',
            },
        ],
        name: 'decreaseRewardsAmount',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'enterFarming',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'exitFarming',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'farmingCenter',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'farms',
        outputs: [
            {
                internalType: 'uint128',
                name: 'liquidity',
                type: 'uint128',
            },
            {
                internalType: 'int24',
                name: 'tickLower',
                type: 'int24',
            },
            {
                internalType: 'int24',
                name: 'tickUpper',
                type: 'int24',
            },
            {
                internalType: 'uint256',
                name: 'innerRewardGrowth0',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'innerRewardGrowth1',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getRewardInfo',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'bonusReward',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'incentives',
        outputs: [
            {
                internalType: 'uint128',
                name: 'totalReward',
                type: 'uint128',
            },
            {
                internalType: 'uint128',
                name: 'bonusReward',
                type: 'uint128',
            },
            {
                internalType: 'address',
                name: 'virtualPoolAddress',
                type: 'address',
            },
            {
                internalType: 'uint24',
                name: 'minimalPositionWidth',
                type: 'uint24',
            },
            {
                internalType: 'bool',
                name: 'deactivated',
                type: 'bool',
            },
            {
                internalType: 'address',
                name: 'pluginAddress',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'isEmergencyWithdrawActivated',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: 'incentiveId',
                type: 'bytes32',
            },
        ],
        name: 'isIncentiveDeactivated',
        outputs: [
            {
                internalType: 'bool',
                name: 'res',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'nonfungiblePositionManager',
        outputs: [
            {
                internalType: 'contract INonfungiblePositionManager',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'numOfIncentives',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
        ],
        name: 'rewards',
        outputs: [
            {
                internalType: 'uint256',
                name: 'rewardAmount',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bool',
                name: 'newStatus',
                type: 'bool',
            },
        ],
        name: 'setEmergencyWithdrawStatus',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '_farmingCenter',
                type: 'address',
            },
        ],
        name: 'setFarmingCenterAddress',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint128',
                name: 'rewardRate',
                type: 'uint128',
            },
            {
                internalType: 'uint128',
                name: 'bonusRewardRate',
                type: 'uint128',
            },
        ],
        name: 'setRates',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
] as const;



================================================
File: src/abis/farming/farmingCenter.ts
================================================
export const farmingCenterABI = [
    {
        inputs: [
            {
                internalType: 'contract IAlgebraEternalFarming',
                name: '_eternalFarming',
                type: 'address',
            },
            {
                internalType: 'contract INonfungiblePositionManager',
                name: '_nonfungiblePositionManager',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'int256',
                name: 'liquidityDelta',
                type: 'int256',
            },
        ],
        name: 'applyLiquidityDelta',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'burnPosition',
        outputs: [
            {
                internalType: 'bool',
                name: 'success',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amountRequested',
                type: 'uint256',
            },
        ],
        name: 'claimReward',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'collectRewards',
        outputs: [
            {
                internalType: 'uint256',
                name: 'reward',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'bonusReward',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IAlgebraPool',
                name: 'pool',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newVirtualPool',
                type: 'address',
            },
        ],
        name: 'connectVirtualPool',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'liquidityDelta',
                type: 'uint256',
            },
        ],
        name: 'decreaseLiquidity',
        outputs: [
            {
                internalType: 'bool',
                name: 'success',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'deposits',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'enterFarming',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'eternalFarming',
        outputs: [
            {
                internalType: 'contract IAlgebraEternalFarming',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'rewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IERC20Minimal',
                        name: 'bonusRewardToken',
                        type: 'address',
                    },
                    {
                        internalType: 'contract IAlgebraPool',
                        name: 'pool',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct IncentiveKey',
                name: 'key',
                type: 'tuple',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'exitFarming',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        name: 'incentiveKeys',
        outputs: [
            {
                internalType: 'contract IERC20Minimal',
                name: 'rewardToken',
                type: 'address',
            },
            {
                internalType: 'contract IERC20Minimal',
                name: 'bonusRewardToken',
                type: 'address',
            },
            {
                internalType: 'contract IAlgebraPool',
                name: 'pool',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'nonce',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'liquidityDelta',
                type: 'uint256',
            },
        ],
        name: 'increaseLiquidity',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes[]',
                name: 'data',
                type: 'bytes[]',
            },
        ],
        name: 'multicall',
        outputs: [
            {
                internalType: 'bytes[]',
                name: 'results',
                type: 'bytes[]',
            },
        ],
        stateMutability: 'payable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'nonfungiblePositionManager',
        outputs: [
            {
                internalType: 'contract INonfungiblePositionManager',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'virtualPoolAddresses',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
] as const;



================================================
File: src/abis/farming/index.ts
================================================
export * from './algebraEternalFarming';
export * from './farmingCenter';



================================================
File: src/abis/plugins/algebraBasePlugin.ts
================================================
export const algebraBasePluginABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_pool",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_pluginFactory",
                "type": "address"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "targetIsTooOld",
        "type": "error"
    },
    {
        "inputs": [],
        "name": "volatilityOracleAlreadyInitialized",
        "type": "error"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "uint16",
                        "name": "alpha1",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "alpha2",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint32",
                        "name": "beta1",
                        "type": "uint32"
                    },
                    {
                        "internalType": "uint32",
                        "name": "beta2",
                        "type": "uint32"
                    },
                    {
                        "internalType": "uint16",
                        "name": "gamma1",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "gamma2",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "baseFee",
                        "type": "uint16"
                    }
                ],
                "indexed": false,
                "internalType": "struct AlgebraFeeConfiguration",
                "name": "feeConfig",
                "type": "tuple"
            }
        ],
        "name": "FeeConfiguration",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "newIncentive",
                "type": "address"
            }
        ],
        "name": "Incentive",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "newPlugin",
                "type": "address"
            }
        ],
        "name": "LimitOrderPlugin",
        "type": "event"
    },
    {
        "inputs": [],
        "name": "ALGEBRA_BASE_PLUGIN_MANAGER",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "afterFlash",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "uint160",
                "name": "",
                "type": "uint160"
            },
            {
                "internalType": "int24",
                "name": "tick",
                "type": "int24"
            }
        ],
        "name": "afterInitialize",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            },
            {
                "internalType": "int128",
                "name": "",
                "type": "int128"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "afterModifyPosition",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "zeroToOne",
                "type": "bool"
            },
            {
                "internalType": "int256",
                "name": "",
                "type": "int256"
            },
            {
                "internalType": "uint160",
                "name": "",
                "type": "uint160"
            },
            {
                "internalType": "int256",
                "name": "",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "",
                "type": "int256"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "afterSwap",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "beforeFlash",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "uint160",
                "name": "",
                "type": "uint160"
            }
        ],
        "name": "beforeInitialize",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "",
                "type": "int24"
            },
            {
                "internalType": "int128",
                "name": "",
                "type": "int128"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "beforeModifyPosition",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            },
            {
                "internalType": "int256",
                "name": "",
                "type": "int256"
            },
            {
                "internalType": "uint160",
                "name": "",
                "type": "uint160"
            },
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            },
            {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
            }
        ],
        "name": "beforeSwap",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "components": [
                    {
                        "internalType": "uint16",
                        "name": "alpha1",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "alpha2",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint32",
                        "name": "beta1",
                        "type": "uint32"
                    },
                    {
                        "internalType": "uint32",
                        "name": "beta2",
                        "type": "uint32"
                    },
                    {
                        "internalType": "uint16",
                        "name": "gamma1",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "gamma2",
                        "type": "uint16"
                    },
                    {
                        "internalType": "uint16",
                        "name": "baseFee",
                        "type": "uint16"
                    }
                ],
                "internalType": "struct AlgebraFeeConfiguration",
                "name": "_config",
                "type": "tuple"
            }
        ],
        "name": "changeFeeConfiguration",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "defaultPluginConfig",
        "outputs": [
            {
                "internalType": "uint8",
                "name": "",
                "type": "uint8"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "feeConfig",
        "outputs": [
            {
                "internalType": "uint16",
                "name": "alpha1",
                "type": "uint16"
            },
            {
                "internalType": "uint16",
                "name": "alpha2",
                "type": "uint16"
            },
            {
                "internalType": "uint32",
                "name": "beta1",
                "type": "uint32"
            },
            {
                "internalType": "uint32",
                "name": "beta2",
                "type": "uint32"
            },
            {
                "internalType": "uint16",
                "name": "gamma1",
                "type": "uint16"
            },
            {
                "internalType": "uint16",
                "name": "gamma2",
                "type": "uint16"
            },
            {
                "internalType": "uint16",
                "name": "baseFee",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getCurrentFee",
        "outputs": [
            {
                "internalType": "uint16",
                "name": "fee",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint32",
                "name": "secondsAgo",
                "type": "uint32"
            }
        ],
        "name": "getSingleTimepoint",
        "outputs": [
            {
                "internalType": "int56",
                "name": "tickCumulative",
                "type": "int56"
            },
            {
                "internalType": "uint88",
                "name": "volatilityCumulative",
                "type": "uint88"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint32[]",
                "name": "secondsAgos",
                "type": "uint32[]"
            }
        ],
        "name": "getTimepoints",
        "outputs": [
            {
                "internalType": "int56[]",
                "name": "tickCumulatives",
                "type": "int56[]"
            },
            {
                "internalType": "uint88[]",
                "name": "volatilityCumulatives",
                "type": "uint88[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "incentive",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "initialize",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "targetIncentive",
                "type": "address"
            }
        ],
        "name": "isIncentiveConnected",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "isInitialized",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "lastTimepointTimestamp",
        "outputs": [
            {
                "internalType": "uint32",
                "name": "",
                "type": "uint32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "limitOrderPlugin",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "pool",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint16",
                "name": "startIndex",
                "type": "uint16"
            },
            {
                "internalType": "uint16",
                "name": "amount",
                "type": "uint16"
            }
        ],
        "name": "prepayTimepointsStorageSlots",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "newIncentive",
                "type": "address"
            }
        ],
        "name": "setIncentive",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "plugin",
                "type": "address"
            }
        ],
        "name": "setLimitOrderPlugin",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "timepointIndex",
        "outputs": [
            {
                "internalType": "uint16",
                "name": "",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "timepoints",
        "outputs": [
            {
                "internalType": "bool",
                "name": "initialized",
                "type": "bool"
            },
            {
                "internalType": "uint32",
                "name": "blockTimestamp",
                "type": "uint32"
            },
            {
                "internalType": "int56",
                "name": "tickCumulative",
                "type": "int56"
            },
            {
                "internalType": "uint88",
                "name": "volatilityCumulative",
                "type": "uint88"
            },
            {
                "internalType": "int24",
                "name": "tick",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "averageTick",
                "type": "int24"
            },
            {
                "internalType": "uint16",
                "name": "windowStartIndex",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
] as const


================================================
File: src/abis/plugins/index.ts
================================================
export * from './algebraBasePlugin';


================================================
File: src/abis/tokens/index.ts
================================================
export * from './wNative'


================================================
File: src/abis/tokens/wNative.ts
================================================
export const wNativeABI = [
    {
      "constant": true,
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "name": "",
          "type": "string"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "guy",
          "type": "address"
        },
        {
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "src",
          "type": "address"
        },
        {
          "name": "dst",
          "type": "address"
        },
        {
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "name": "",
          "type": "uint8"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "name": "",
          "type": "string"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "dst",
          "type": "address"
        },
        {
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "deposit",
      "outputs": [],
      "payable": true,
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "address"
        },
        {
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "payable": true,
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "name": "src",
          "type": "address"
        },
        {
          "indexed": true,
          "name": "guy",
          "type": "address"
        },
        {
          "indexed": false,
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "name": "src",
          "type": "address"
        },
        {
          "indexed": true,
          "name": "dst",
          "type": "address"
        },
        {
          "indexed": false,
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "name": "dst",
          "type": "address"
        },
        {
          "indexed": false,
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "name": "src",
          "type": "address"
        },
        {
          "indexed": false,
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "Withdrawal",
      "type": "event"
    }
  ] as const


================================================
File: src/components/common/Banner.tsx
================================================
import { ReactNode, memo } from "react";
import tw, { styled, theme } from "twin.macro";
import LineBoxBase from "./LineBoxBase";

const _Banner = styled(LineBoxBase)`
    ${() => tw`h-[100px] m:h-[86px]`}

    >.inner {
        padding: 22px 20px;
        ${() => tw`flex items-center justify-between gap-[10px] m:px-[16px] m:py-[12px]`}
    }
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 24px;
    line-height: 1.2;
    ${() => tw`flex items-center m:text-[16px]`}
`;
const _Description = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-weight: 400;
    line-height: 1.2;
    margin-top: 6px;
    text-align: left;
    ${() => tw``}

    @media (max-width: ${theme`screens.mobile.max`}) {
        margin-top: 11px;
    }
`;
const Banner: FCProps<{
    title: ReactNode;
    description: ReactNode;
    rightContent?: ReactNode;
}> = ({ title, description, rightContent, className }) => {
    return (
        <_Banner className={className}>
            <div>
                <_Title>{title}</_Title>
                <_Description>{description}</_Description>
            </div>

            {rightContent}
        </_Banner>
    );
};

export default memo(Banner);



================================================
File: src/components/common/Bulletin.tsx
================================================
import { memo, useCallback } from "react";
import tw, { styled } from "twin.macro";
import { useSwapState } from "@/state/swapStore";
import Image from "./Image";
import FloatingButton from "./FloatingButton";
import LineBoxBase from "./LineBoxBase";

const _Bulletin = styled(LineBoxBase)`
    background: #ff6b00;

    > .inner {
        padding: 36px 14px 21px;
        ${() => tw`relative flex flex-col items-center`}
    }

    ${() => tw`m:w-[calc(100% - 40px)] fixed right-[48px] h-auto w-[320px] m:right-[20px] m:z-[10]`}
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-weight: 700;
    line-height: 120%;
`;
const Bulletin = () => {
    const {
        actions: { changeShowBulletin },
    } = useSwapState();

    const close = useCallback(() => {
        changeShowBulletin(false);
    }, [changeShowBulletin]);

    return (
        <_Bulletin>
            <Image
                onClick={close}
                className="absolute right-[12px] top-[12px] cursor-pointer"
                width={16}
                height={16}
                src="/close-none.svg"
                alt=""
            />
            <_Title>11X SPARKS, ONLY IN 11 DAYS</_Title>

            <Image
                className="mt-[19px] m:w-full"
                width={285}
                height={162}
                src="/advertising/11x.jpg"
                alt=""
            />

            <FloatingButton
                className="mt-[19px]"
                onClick={() =>
                    window.open("https://x.com/glyph_exchange/status/1855840555059855485")
                }
            >
                GET RICH NOW
            </FloatingButton>
        </_Bulletin>
    );
};

export default memo(Bulletin);



================================================
File: src/components/common/Checkbox.tsx
================================================
import { memo, useMemo } from "react";
import tw, { styled } from "twin.macro";

const _Text = styled.div<{ $color: string }>`
    font-family: Geneva-Regular;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    color: ${(props) => props.$color};

    ${() => tw`m:text-[12px]`}
`;

const _Checkbox = styled.div<{ $disabled?: boolean }>`
    cursor: ${(props) => (props.$disabled ? "not-allowed" : "pointer")};
    ${() => tw`flex items-center gap-[4px]`}
`;

const Checkbox: FCProps<{ checked?: boolean; disabled?: boolean; color?: `#${string}` }> = (
    props,
) => {
    const { checked, disabled, color } = props;
    const _color = useMemo(() => {
        const initColor = color ?? "#000000";
        return disabled ? initColor + "66" : initColor;
    }, [color, disabled]);

    return (
        <_Checkbox {...props} $disabled={disabled}>
            <svg
                style={{ marginTop: "-1px" }}
                width="14"
                height="15"
                viewBox="0 0 14 15"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
            >
                <rect
                    x="0.4375"
                    y="0.9375"
                    width="13.125"
                    height="13.125"
                    rx="3.0625"
                    fill="white"
                    stroke={_color}
                    strokeWidth="0.875"
                />
                {checked && (
                    <rect x="2.625" y="3.125" width="8.75" height="8.75" rx="1.75" fill={_color} />
                )}
            </svg>

            <_Text $color={_color}>{props.children}</_Text>
        </_Checkbox>
    );
};

export default memo(Checkbox);



================================================
File: src/components/common/Collapsible.tsx
================================================
import tw, { styled } from "twin.macro";
import Image from "./Image";
import { ReactNode, memo, useCallback, useLayoutEffect, useMemo, useRef, useState } from "react";

const _Collapsible = styled.div`
    ${() => tw``}
`;
const _Trigger = styled.div`
    ${() => tw`flex w-max cursor-pointer items-center gap-[8px]`}
`;
const _Content = styled.div`
    ${() => tw`overflow-hidden duration-200 will-change-[height]`}
`;
const Collapsible: FCProps<{
    triggerClassName?: string;
    contentClassName?: string;
    title?: ReactNode;
    expanded?: boolean;
    toggleExpanded?: (val: boolean) => void;
    internal?: boolean; // use internal trigger flow
    hideTriggerArrow?: boolean;
    arrowSize?: number;
}> = ({
    className,
    triggerClassName,
    contentClassName,
    style,
    title,
    children,
    expanded,
    toggleExpanded,
    internal,
    hideTriggerArrow,
    arrowSize = 20,
}) => {
    const [height, setHeight] = useState<number>();
    const content = useRef<HTMLDivElement>(null);
    const [_internalExpanded, _internalToggleExpanded] = useState(expanded);

    const _expanded = useMemo(
        () => (internal ? _internalExpanded : expanded),
        [internal, expanded, _internalExpanded],
    );

    const _toggleExpanded = useCallback(() => {
        internal ? _internalToggleExpanded(!_internalExpanded) : toggleExpanded?.(!expanded);
    }, [internal, expanded, toggleExpanded, _internalExpanded, _internalToggleExpanded]);

    useLayoutEffect(() => {
        setHeight(content.current?.clientHeight);
    }, []);

    return (
        <_Collapsible className={className} style={style}>
            <_Trigger className={triggerClassName} onClick={_toggleExpanded}>
                {title}
                {!hideTriggerArrow && (
                    <Image
                        className={`duration-200 ${_expanded && "rotate-180"}`}
                        src="/icon_bottom_arrow.svg"
                        width={arrowSize}
                        height={arrowSize}
                    />
                )}
            </_Trigger>
            <_Content
                ref={content}
                className={contentClassName}
                style={{ height: height ? (_expanded ? height : 0) : "auto" }}
            >
                {children}
            </_Content>
        </_Collapsible>
    );
};

export default memo(Collapsible);



================================================
File: src/components/common/FloatingButton.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { CSSProperties, forwardRef, memo, useMemo, useState } from "react";
import tw, { styled } from "twin.macro";

const _BottomBox = styled.div<{ $offset: string; $isSmall: boolean }>`
    position: absolute;
    border: 1px solid #000;
    width: inherit;
    height: inherit;

    background-color: ${(props) => (props.$isSmall ? "#000" : "#d9d9d9")};
    transform: ${(props) => `translate(${props.$offset},${props.$offset})`};

    ${() => tw`transition-all`}
`;
const _TopBox = styled.div<{
    $mouseDown: boolean;
    $offset: string;
    $disabled: boolean;
    $isSmall: boolean;
    $isMobile: boolean;
    $color?: string;
}>`
    position: absolute;
    z-index: 1;
    width: inherit;
    height: inherit;
    padding: 2px;
    border: 1px solid #000;

    font-family: ${(props) => (props.$isSmall ? "Geneva-Regular" : "FraktionMono-Bold")};
    font-size: ${(props) =>
        props.$isMobile ? (props.$isSmall ? "12px" : "14px") : props.$isSmall ? "14px" : "18px"};
    line-height: ${(props) => (props.$isSmall ? "normal" : "1.2")};
    background-color: ${(props) => (props.$disabled ? "#bbb" : props.$isSmall ? "#fff" : "#000")};
    color: ${(props) =>
        props.$color
            ? props.$color
            : props.$disabled
              ? "#858484"
              : props.$isSmall
                ? "#000"
                : "#fff"};
    cursor: ${(props) => (props.$disabled ? "not-allowed" : "pointer")};
    transform: ${(props) =>
        props.$mouseDown && !props.$disabled
            ? `translate(${props.$offset},${props.$offset})`
            : "translate(0)"};

    ${() => tw`flex select-none items-center justify-center transition-all`}
`;
const _FloatingButton = styled.div<{
    $width: string;
    $height: string;
}>`
    width: ${(props) => props.$width};
    height: ${(props) => props.$height};

    ${() => tw`relative`};
`;

const FloatingButton: FCProps<{
    width?: string;
    height?: string;
    offset?: string;
    disabled?: boolean;
    type?: "default" | "small";
    color?: string;
    innerStyle?: CSSProperties;
}> = forwardRef((props, ref) => {
    const isMobile = useMediaQuery("mobile");

    const { isSmall, disabled, width, height, offset } = useMemo(() => {
        const type = props.type ?? "default";
        const isSmall = type === "small";

        return {
            isSmall,
            disabled: props.disabled ?? false,
            width: props.width ? props.width : isSmall ? "88px" : "100%",
            height: props.height
                ? props.height
                : isMobile
                  ? isSmall
                      ? "25px"
                      : "48px"
                  : isSmall
                    ? "28px"
                    : "56px",
            offset: props.offset ? props.offset : isSmall ? "3px" : "4px",
        };
    }, [props, isMobile]);

    const [mouseDown, setMouseDown] = useState(false);

    return (
        <_FloatingButton
            ref={ref}
            $width={width}
            $height={height}
            onClick={(e) => (disabled ? null : props.onClick?.(e))}
            style={props.style}
            className={props.className}
        >
            <_TopBox
                $isMobile={isMobile}
                $mouseDown={mouseDown}
                $offset={offset}
                $disabled={disabled}
                $isSmall={isSmall}
                $color={props.color}
                onMouseDown={() => setMouseDown(true)}
                onMouseUp={() => setMouseDown(false)}
                onMouseOut={() => setMouseDown(false)}
                onTouchStart={() => setMouseDown(true)}
                onTouchEnd={() => setMouseDown(false)}
                style={props.innerStyle}
            >
                <span className="truncate">{props.children}</span>
            </_TopBox>

            <_BottomBox $offset={offset} $isSmall={isSmall} />
        </_FloatingButton>
    );
});
export default memo(FloatingButton);



================================================
File: src/components/common/Image.tsx
================================================
import { memo } from "react";
import { LazyLoadImage, LazyLoadImageProps } from "react-lazy-load-image-component";

const Image: FCProps<LazyLoadImageProps> = (props) => {
    return (
        <LazyLoadImage
            {...props}
            style={{
                width: props.width ? props.width + "px" : "100%",
                height: props.height ? props.height + "px" : "100%",
            }}
            onError={(e) => (e.currentTarget.src = "/error.svg") && props.onError?.(e)}
        />
    );
};

export default memo(Image);



================================================
File: src/components/common/LineBoxBase.tsx
================================================
import { memo } from "react";
import tw, { styled, theme } from "twin.macro";

const _LineBoxBase = styled.div`
    border: 1px solid #000;
    background: white;

    ${() => tw`h-full p-[2px]`};
    @media (max-width: ${theme`screens.mobile.max`}) {
        box-shadow: 0px 4px 4px 0px rgba(0, 0, 0, 0.25);
    }
`;
const _Inner = styled.div`
    border: 2px solid #000;
    ${() => tw`h-full w-full`}
`;
const LineBoxBase: FCProps = ({ children, className, style }) => {
    return (
        <_LineBoxBase className={className} style={style}>
            <_Inner className="inner">{children}</_Inner>
        </_LineBoxBase>
    );
};

export default memo(LineBoxBase);



================================================
File: src/components/common/PageSelector.tsx
================================================
import { ReactNode, memo, useMemo } from "react";
import tw, { styled } from "twin.macro";
import PanelBase from "./Panel/PanelBase";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import Checkbox from "./Checkbox";
import PanelTitle from "./Panel/PanelTitle";

const _Selector = styled.div<{ $gap: string }>`
    gap: ${({ $gap }) => $gap};
    ${() => tw`flex h-[60px] items-center justify-center m:h-[50px]`}
`;

const _PageSelector = styled(PanelBase)`
    ${() => tw`w-full max-w-[434px]`}
`;

type Items = {
    name: ReactNode;
    active?: boolean;
    disabled?: boolean;
    action?: () => void;
    color?: `#${string}`;
}[];

const PageSelector: FCProps<{ items: Items }> = ({ className, items }) => {
    const isMobile = useMediaQuery("mobile");
    const gap = useMemo(() => (isMobile ? "28px" : "56px"), [isMobile]);

    return (
        <_PageSelector className={className}>
            <PanelTitle title="SELECTOR" />

            <_Selector $gap={gap}>
                {items &&
                    Object.values(items).map((item, index) => (
                        <Checkbox
                            key={index}
                            checked={item.active}
                            disabled={item.disabled}
                            color={item.color}
                            onClick={() => !item.disabled && item.action?.()}
                        >
                            {item.name}
                        </Checkbox>
                    ))}
            </_Selector>
        </_PageSelector>
    );
};

export default memo(PageSelector);



================================================
File: src/components/common/Popver.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { memo, ReactNode, useEffect, useState } from "react";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";
import tw, { styled } from "twin.macro";

const _Popver = styled.div`
    ${() => tw``}
`;
const _PopoverContent = styled(PopoverContent)`
    box-shadow: unset;
    background: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(3px);
    ${() => tw`flex w-[287px] flex-col gap-[15px] rounded-[4px] b1 m:gap-[12px]`}
`;
const _ContentTitle = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 12px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    ${() => tw`flex flex-nowrap gap-[4px]`}
`;
const _ContentDesc = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw``}
`;
const Popver: FCProps<{ triger: ReactNode; title: ReactNode; description?: ReactNode }> = ({
    className,
    style,
    triger,
    title,
    description,
}) => {
    const isMobile = useMediaQuery("mobile");
    const [hover, setHover] = useState(false);

    useEffect(() => {
        setHover(false);
    }, [isMobile]);

    return (
        <_Popver className={className} style={style}>
            <Popover open={isMobile ? undefined : hover}>
                <PopoverTrigger
                    className="flex flex-nowrap items-center gap-[4px] outline-0"
                    onMouseEnter={() => !isMobile && setHover(true)}
                    onMouseLeave={() => !isMobile && setHover(false)}
                >
                    {triger}
                </PopoverTrigger>
                <_PopoverContent
                    align={isMobile ? "center" : "start"}
                    sideOffset={10}
                    collisionPadding={{ left: 44, right: 44 }}
                >
                    <_ContentTitle>{title}</_ContentTitle>
                    {description && <_ContentDesc>{description}</_ContentDesc>}
                </_PopoverContent>
            </Popover>
        </_Popver>
    );
};

export default memo(Popver);



================================================
File: src/components/common/SearchBox.tsx
================================================
import { ChangeEventHandler, memo, useCallback, useRef } from "react";
import tw, { styled, theme } from "twin.macro";
import { Input } from "../ui/input";
import Image from "./Image";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

const _SearchBox = styled.div`
    border-radius: 4px;
    border: 1px solid #000;
    background: #e8e8e8;

    &:hover {
        background-color: #e8e8e8;
    }

    &:focus,
    &:focus-within {
        background-color: #f5f5f5;
    }

    ${() => tw`relative flex cursor-text items-center`}
`;

const _SearchInput = styled(Input)`
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 35px;
    border: unset;
    padding: 0 0 0 16px;
    color: #000;

    &::placeholder {
        color: #999;
    }

    ${() => tw`h-[35px] w-[calc(100%-44px)] focus:border-opacity-100`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        height: 33px;
        line-height: 33px;
        font-size: 12px;
        padding: 0 0 0 10px;

        ${() => tw`w-[calc(100%-32px)]`}
    }
`;

const SearchBox: FCProps<{
    value: string;
    onChange: ChangeEventHandler<HTMLInputElement>;
}> = ({ value, onChange, className }) => {
    const isMobile = useMediaQuery("mobile");
    const inputRef = useRef<HTMLInputElement>(null);

    const handleSearnClick = useCallback(() => {
        if (inputRef.current) {
            inputRef.current.focus();
        }
    }, []);

    return (
        <_SearchBox onClick={handleSearnClick} className={className}>
            <_SearchInput
                ref={inputRef}
                placeholder="Search pool"
                value={value}
                onChange={onChange}
            />
            <Image
                width={isMobile ? 16 : 20}
                height={isMobile ? 16 : 20}
                src="/search_icon.svg"
                alt=""
                className="absolute left-[calc(100%-36px)] m:left-[calc(100%-28px)]"
            />
        </_SearchBox>
    );
};

export default memo(SearchBox);



================================================
File: src/components/common/SeparateBar.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _SeparateBar = styled.div`
    ${() => tw`relative h-[24px] w-full`}
`;

const Img = styled.img`
    ${() => tw`absolute left-1/2 top-1/2 w-full -translate-x-1/2 -translate-y-1/2`}
`;

const SeparateBar: FCProps<{ middleElement: JSX.Element }> = ({
    className,
    style,
    middleElement,
}) => {
    return (
        <_SeparateBar className={className} style={style}>
            <Img src="/bar-line.svg" />
            <span className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2">
                {middleElement}
            </span>
        </_SeparateBar>
    );
};

export default memo(SeparateBar);



================================================
File: src/components/common/Svg.tsx
================================================
import { memo } from "react";
import tw, { css, styled } from "twin.macro";
import { LazyLoadImage, LazyLoadImageProps } from "react-lazy-load-image-component";

const _Svg = styled(LazyLoadImage)<{ $color?: string; width?: string | number }>`
    ${(props) =>
        props.$color &&
        css`
            transform: translateX(-100%);
            filter: drop-shadow(${props.$color} ${props.width}px 0);
        `}

    ${() => tw``}
`;
const Svg: FCProps<
    LazyLoadImageProps & {
        $color?: string;
    }
> = (props) => {
    return (
        <div className="overflow-hidden">
            <_Svg {...props} />
        </div>
    );
};

export default memo(Svg);



================================================
File: src/components/common/WarningBox.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { ReactNode, memo } from "react";
import tw, { styled } from "twin.macro";

const _WarningBox = styled.div<{ $emphatic: boolean }>`
    border: 1px solid ${({ $emphatic }) => ($emphatic ? "#fd375b" : "#000")};
    background: #f5f5f5;
    color: ${({ $emphatic }) => ($emphatic ? "#fd375b" : "#000")};
    font-family: Geneva;
    font-size: 12px;
    font-weight: 400;

    ${() =>
        tw`flex w-full items-center gap-[20px] border-x-0 p-[24px] m:gap-[20px] m:p-[16px_20px] m:text-[10px]`};
`;
const WarningBox: FCProps<{ description: ReactNode; emphatic?: boolean }> = ({
    className,
    style,
    description,
    emphatic = false,
}) => {
    const isMobile = useMediaQuery("mobile");

    return (
        <_WarningBox $emphatic={emphatic} className={className} style={style}>
            <img
                width={isMobile ? 24 : 27}
                height={isMobile ? 24 : 27}
                src={emphatic ? "/warning-red.svg" : "/warning-icon.svg"}
                alt=""
            />
            {description}
        </_WarningBox>
    );
};

export default memo(WarningBox);



================================================
File: src/components/common/Card/index.tsx
================================================
import React from "react";

interface CardProps {
    children: React.ReactNode
}

const Card = ({ children }: CardProps) => {

    return <div className="bg-card-gradient border border-card-border rounded-2xl">
        {children}
    </div>
    
}

export default Card;


================================================
File: src/components/common/CardInfo/index.tsx
================================================
import { cn } from '@/lib/utils';
import React, { FC } from 'react';

interface CardInfoProps {
    title: string;
    additional?: string;
    className?: string;
    children?: React.ReactNode;
}

const CardInfo: FC<CardInfoProps> = ({
    title,
    children,
    additional,
    className,
}) => {
    return (
        <div
            className={cn(
                'flex items-start flex-col gap-2 rounded-3xl border-border border bg-card-dark p-4',
                className
            )}
        >
            <h3 className="font-bold text-sm">{title}</h3>
            <div className="flex justify-between w-full items-end">
                <div className="flex items-center mr-auto text-2xl font-bold">
                    {children}
                </div>
                {additional && <p className="max-sm:hidden">{additional}</p>}
            </div>
        </div>
    );
};

export default CardInfo;



================================================
File: src/components/common/CurrencyLogo/index.tsx
================================================
import { Currency } from "@glyph-exchange/integral-sdk";
import React from "react";
import { Address } from "wagmi";
import { cn } from "@/lib/utils";
import { Skeleton } from "@/components/ui/skeleton";
import tw, { styled } from "twin.macro";
import Image from "../Image";
interface CurrencyLogoProps {
    currency: Currency | undefined | null;
    size: number;
    className?: string;
    style?: React.CSSProperties;
}

export const specialTokens: { [key: Address]: { symbol: string; logo: string } } = {
    // core
    ["0x0000000000000000000000000000000000000000".toLowerCase()]: {
        symbol: "CORE",
        logo: "/tokens/CORE.svg",
    },
    ["0x191e94fa59739e188dce837f7f6978d84727ad01".toLowerCase()]: {
        symbol: "WCORE",
        logo: "/tokens/WCORE.svg",
    },
    ["0x900101d06a7426441ae63e9ab3b9b0f63be145f1".toLowerCase()]: {
        symbol: "USDT",
        logo: "/tokens/USDT.svg",
    },
    ["0xa4151b2b3e269645181dccf2d426ce75fcbdeca9".toLowerCase()]: {
        symbol: "USDC",
        logo: "/tokens/USDC.svg",
    },
    ["0xb3a8f0f0da9ffc65318aa39e55079796093029ad".toLowerCase()]: {
        symbol: "stCORE",
        logo: "/tokens/stCORE.svg",
    },
    ["0x5832f53d147b3d6cd4578b9cbd62425c7ea9d0bd".toLowerCase()]: {
        symbol: "WBTC",
        logo: "/tokens/WBTC.svg",
    },
    ["0x8034ab88c3512246bf7894f57c834dddbd1de01f".toLowerCase()]: {
        symbol: "coreBTC",
        logo: "/tokens/coreBTC.svg",
    },
    ["0xb28b43209d9de61306172af0320f4f55e50e2f29".toLowerCase()]: {
        symbol: "ASX",
        logo: "/tokens/ASX.svg",
    },
    ["0xeab3ac417c4d6df6b143346a46fee1b847b50296".toLowerCase()]: {
        symbol: "WETH",
        logo: "/tokens/WETH.svg",
    },
    ["0xc0e5f8e2a9a2f1fbf34ab4d5fbf417ffd02fdb79".toLowerCase()]: {
        symbol: "CPEPE",
        logo: "/tokens/CPEPE.svg",
    },
    ["0x78e3389b8f1f1a977544ea25768dc8073b74bd41".toLowerCase()]: {
        symbol: "CTO",
        logo: "/tokens/CTO.svg",
    },
    ["0x5b1fb849f1f76217246b8aaac053b5c7b15b7dc3".toLowerCase()]: {
        symbol: "SolvBTC.b",
        logo: "/tokens/SolvBTC.b.svg",
    },
    ["0x7a6888c85edba8e38f6c7e0485212da602761c08".toLowerCase()]: {
        symbol: "BTCB",
        logo: "/tokens/BTCB.svg",
    },
    ["0x70727228db8c7491bf0ad42c180dbf8d95b257e2".toLowerCase()]: {
        symbol: "aBTC",
        logo: "/tokens/aBTC.svg",
    },
    ["0x473286fad076c050fb48a449c77d7434d947ce00".toLowerCase()]: {
        symbol: "rBTC",
        logo: "/tokens/rBTC.svg",
    },
    ["0xe04d21d999faedf1e72ade6629e20a11a1ed14fa".toLowerCase()]: {
        symbol: "SolvBTC.m",
        logo: "/tokens/SolvBTC.m.svg",
    },
    ["0x86b8C90fe6532FA328cE25A44e09F690bb3B4856".toLowerCase()]: {
        symbol: "GP",
        logo: "/tokens/GP.gif",
    },
    ["0x9410e8052bc661041e5cb27fdf7d9e9e842af2aa".toLowerCase()]: {
        symbol: "SolvBTC.CORE",
        logo: "/tokens/SolvBTC.CORE.svg",
    },
    ["0x000734cf9e469bad78c8ec1b0deed83d0a03c1f8".toLowerCase()]: {
        symbol: "OBTC",
        logo: "/tokens/OBTC.svg",
    },
    ["0xa5c4cd9ad4beda2ef1befece1ee16511ebcc41ad".toLowerCase()]: {
        symbol: "JUC",
        logo: "/tokens/JUC.svg",
    },
    ["0x30a540b05468a250fcc17da2d9d4aaa84b358ea7".toLowerCase()]: {
        symbol: "CLND",
        logo: "/tokens/CLND.svg",
    },
    ["0xbb4a26a053b217bb28766a4ed4b062c3b4de58ce".toLowerCase()]: {
        symbol: "uBTC",
        logo: "/tokens/uBTC.svg",
    },
    ["0xad0c524ce19cea03654dc377da7bac52c56edd10".toLowerCase()]: {
        symbol: "BtcUSD",
        logo: "/tokens/BtcUSD.svg",
    },
    ["0x5f81702fdfdd9d36471b52a4f105d103442c88df".toLowerCase()]: {
        symbol: "AMCL",
        logo: "/tokens/AMCL.svg",
    },
    ["0xc5555ea27e63cd89f8b227dece2a3916800c0f4f".toLowerCase()]: {
        symbol: "dualCORE",
        logo: "/tokens/dualCORE.svg",
    },
    ["0x6bede1c6009a78c222d9bdb7974bb67847fdb68c".toLowerCase()]: {
        symbol: "USBD",
        logo: "/tokens/USBD.svg",
    },
    ["0x56663f56333717a32cd91ec41182d6d76d98864e".toLowerCase()]: {
        symbol: "CORP",
        logo: "/tokens/CORP.svg",
    },
    ["0xd60d60b168360dbd3496ec0ed0afe4a7498de3ce".toLowerCase()]: {
        symbol: "PT-dualBTC",
        logo: "/tokens/PT-dualBTC.svg",
    },
    ["0x00000000efe302beaa2b3e6e1b18d08d69a9012a".toLowerCase()]: {
        symbol: "AUSD",
        logo: "/tokens/AUSD.svg",
    },
    // core

    // core-tetnet
    ["0xc5f59163918ea373c987bd51fe3abf312c3e21ff".toLowerCase()]: {
        symbol: "CORE",
        logo: "/tokens/CORE.svg",
    },
    ["0x9cf7ea86e0fb5fc729fda2958eba35430a7b48f1".toLowerCase()]: {
        symbol: "USDT",
        logo: "/tokens/USDT.svg",
    },
    ["0xf793787435bfbb53fbc83c196d9afa92dd2ae2e8".toLowerCase()]: {
        symbol: "WBTC",
        logo: "/tokens/WBTC.svg",
    },
    // core-tetnet
};

const _DefaultIcon = styled.div`
    font-family: FraktionMono-Bold;
    font-size: 70%;
    font-weight: 700;
    line-height: 1;
    ${() =>
        tw`flex items-center justify-center overflow-hidden bg-[#838383] text-white b1-[#EBEBEB]`}
`;

const CurrencyLogo = ({ currency, size, className, style = {} }: CurrencyLogoProps) => {
    if (!currency)
        return (
            <Skeleton
                className={cn(`flex rounded-full bg-[#838383]`, className)}
                style={{
                    minWidth: `${size}px`,
                    minHeight: `${size}px`,
                    width: `${size}px`,
                    height: `${size}px`,
                    ...style,
                }}
            />
        );

    const address = currency.wrapped.address.toLowerCase() as Address;

    const classString = cn(
        `w-[${size}px] h-[${size}px] min-w-[${size}px] min-h-[${size}px] rounded-full`,
        className,
    );

    if (address in specialTokens) {
        return (
            <Image
                src={specialTokens[address].logo}
                alt={specialTokens[address].symbol}
                width={size}
                height={size}
                className={cn(classString, "overflow-visible")}
                style={style}
            />
        );
    }

    if (currency.isNative) {
        return (
            <Image
                src="/tokens/CORE.svg"
                alt={"CORE"}
                width={size}
                height={size}
                className={classString}
                style={style}
            />
        );
    }

    return (
        <_DefaultIcon
            className={`${classString}`}
            style={{
                minWidth: `${size}px`,
                minHeight: `${size}px`,
                width: `${size}px`,
                height: `${size}px`,
                ...style,
            }}
        >
            {currency.symbol?.slice(0, 2)}
        </_DefaultIcon>
    );
};

export default CurrencyLogo;



================================================
File: src/components/common/Footer/MenuModal.tsx
================================================
import { memo, useCallback, useEffect, useLayoutEffect, useRef, useState } from "react";
import tw, { styled } from "twin.macro";
import Image from "../Image";
import { useNavigate } from "react-router-dom";
import { keyframes } from "styled-components";
import Collapsible from "../Collapsible";
import Socials from "./Socials";

const In = keyframes`
  from {
    transform:translateY(100%);
  }

  to {
    transform:translateY(0%);
  }
`;

const Out = keyframes`
  from {
    transform:translateY(0%);
  }

  to {
    transform:translateY(100%);
  }
`;

const _MenuModal = styled.div<{ $enter?: boolean }>`
    left: 0;
    right: 0;
    top: var(--header-height);
    bottom: var(--footer-height);
    background-color: rgb(51 51 51 / 0.5);
    opacity: ${(props) => (props.$enter ? 1 : 0)};

    ${() => tw`fixed z-[10] overflow-hidden duration-200`}
`;

const _ModalContent = styled.div<{ $enter?: boolean }>`
    animation: ${(props) => (props.$enter ? In : Out)} 0.2s both;

    ${() => tw`relative flex h-full flex-col bg-[#E8E8E8]`};
`;

const _CollapsibleContent = styled.div`
    ${() => tw`flex flex-col gap-[20px] p-[28px_16px] pb-0`}
`;

const _MenuTitle = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 28px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw``}
`;
const _MenuItem = styled.a`
    display: flex;
    align-items: center;
    gap: 8px;
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    cursor: pointer;

    ${() => tw`flex items-center`};
`;

const menus = [
    {
        title: "SWAP",
        items: [
            {
                name: "V2 AMM",
                link: "https://app.glyph.exchange/swap",
                external: true,
            },
            {
                name: "V4 AMM",
                link: "/swap",
            },
        ],
    },
    {
        title: "POOL",
        items: [
            {
                name: "V2 POOLS",
                link: "https://app.glyph.exchange/pool",
                external: true,
            },
            {
                name: "V4 POOLS",
                link: "/pools",
            },
        ],
    },

    {
        title: "BRIDGE",
        items: [
            {
                name: "Core Official Bridge",
                link: "https://bridge.coredao.org/",
                external: true,
            },
            // {
            //     name: "Orange Bridge",
            //     link: "https://bridge.orangecrypto.com/",
            //     external: true,
            // },
            {
                name: "Stargate Finance",
                link: "https://stargate.finance/",
                external: true,
            },
        ],
    },
];

const MenuModal: FCProps<{ open?: boolean; onClose?: (status: boolean) => void }> = memo(
    ({ className, style, open, onClose }) => {
        const navigate = useNavigate();
        const [innerOpen, setInnerOpen] = useState(open);
        const [enter, setEnter] = useState(false);
        const [selected, setSelected] = useState("");

        const close = useCallback(() => {
            setEnter(false);
            setTimeout(() => {
                setInnerOpen(false);
                onClose?.(false);
                setSelected("");
            }, 200);
        }, [onClose]);

        const onItemClick = useCallback(
            (item: { name: string; link: string; external?: boolean }) => {
                if (item.external) window.open(item.link);
                else navigate(item.link);
                close();
            },
            [close, navigate],
        );

        useEffect(() => {
            if (open === innerOpen) return;
            if (open) {
                setEnter(true);
                setInnerOpen(true);
            } else close();
        }, [innerOpen, open, close]);

        return (
            <>
                {innerOpen && (
                    <_MenuModal $enter={enter} className={className} style={style}>
                        <_ModalContent $enter={enter}>
                            <Image
                                src="/close.svg"
                                width={24}
                                height={24}
                                className="absolute right-[20px] top-[20px] cursor-pointer"
                                onClick={close}
                            />

                            <div className="my-[60px] flex flex-1 flex-col gap-[40px] overflow-y-auto p-[20px]">
                                {menus.map((menu) => (
                                    <Collapsible
                                        key={menu.title}
                                        title={<_MenuTitle>{menu.title}</_MenuTitle>}
                                        expanded={selected === menu.title}
                                        toggleExpanded={() =>
                                            setSelected(selected === menu.title ? "" : menu.title)
                                        }
                                    >
                                        <_CollapsibleContent>
                                            {menu?.items.map((item) => (
                                                <_MenuItem
                                                    key={item.name}
                                                    onClick={() => onItemClick(item)}
                                                >
                                                    {item.name}
                                                    {item.external && (
                                                        <Image
                                                            src="/link.svg"
                                                            width={16}
                                                            height={16}
                                                        />
                                                    )}
                                                </_MenuItem>
                                            ))}
                                        </_CollapsibleContent>
                                    </Collapsible>
                                ))}
                            </div>
                            <Socials />
                        </_ModalContent>
                    </_MenuModal>
                )}
            </>
        );
    },
);

export default MenuModal;



================================================
File: src/components/common/Footer/Socials.tsx
================================================
import { memo } from "react";
import Image from "../Image";
import tw, { styled } from "twin.macro";

const _Socials = styled.div`
    &::-webkit-scrollbar {
        display: none;
    }

    ${() =>
        tw`flex w-full flex-nowrap items-center gap-[24px] overflow-x-auto bg-white p-[16px_20px] bt1`}
`;

const _Item = styled.a`
    display: flex;
    align-items: center;
    gap: 8px;
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    cursor: pointer;
    min-width: max-content;
`;
const Socials: FCProps = memo(({ className, style }) => {
    return (
        <_Socials className={className} style={style}>
            <_Item href="https://twitter.com/glyph_exchange" target="_blank" className="item">
                <Image src="/twitter.svg" width={20} height={20} />X (Twitter)
            </_Item>
            <_Item href="https://discord.com/invite/glyphexchange" target="_blank" className="item">
                <Image src="/discord.svg" width={20} height={20} />
                Discord
            </_Item>
            <_Item href="https://t.me/Glyphexchange" target="_blank" className="item">
                <Image src="/telegram.svg" width={20} height={20} />
                Telegram
            </_Item>
            <_Item
                href="https://glyph-exhange.gitbook.io/glyph.exchange"
                target="_blank"
                className="item"
            >
                <Image src="/doc.svg" width={20} height={20} />
                Document
            </_Item>
        </_Socials>
    );
});

export default memo(Socials);



================================================
File: src/components/common/Footer/index.tsx
================================================
import { memo, useEffect, useMemo, useState } from "react";
import { useLocation } from "react-router-dom";
import tw, { styled } from "twin.macro";
import Image from "../Image";
import MenuModal from "./MenuModal";

const _Footer = styled.div`
    height: var(--footer-height);
    ${() => tw`fixed bottom-0 left-0 z-[11] w-full bg-white p-[16px_20px] bt1`}
`;

const _Page = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 18px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw`uppercase`}
`;

const _Menus = styled.div`
    ${() => tw`flex items-center gap-[12px]`}
`;

const _Btn = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() =>
        tw`relative flex cursor-pointer items-center gap-[8px] rounded-[6px] p-[8px] transition-colors b1`}
`;

const _BuyBtn = styled(_Btn)`
    ${() => tw`cursor-not-allowed opacity-40`}
`;

const _MenuBtn = styled(_Btn)`
    &.open {
        background-color: #000;
        color: #fff;
        img {
            ${() => tw`invert`}
        }
    }
`;

const Page: FCProps = memo(({ className, style }) => {
    const location = useLocation();
    const page = useMemo(() => location.pathname.split("/")?.[1] ?? "SWAP", [location]);
    return (
        <_Page className={className} style={style}>
            {page}
        </_Page>
    );
});

const Menus: FCProps = memo(({ className, style }) => {
    const [open, setOpen] = useState(false);

    useEffect(() => {
        return () => setOpen(false);
    }, []);

    return (
        <_Menus className={className} style={style}>
            <_BuyBtn>
                <Image src="/g.gif" width={18} height={18} />
                Buy $G
            </_BuyBtn>
            <_MenuBtn className={open ? "open" : ""} onClick={() => setOpen(!open)}>
                <Image src="/module.svg" width={18} height={18} />
                Menu
            </_MenuBtn>
            {<MenuModal open={open} onClose={setOpen} />}
        </_Menus>
    );
});

const Footer: FCProps = ({ className, style }) => {
    return (
        <_Footer className={className} style={style}>
            <div className="flex items-center justify-between">
                <Page />
                <Menus />
            </div>
        </_Footer>
    );
};

export default memo(Footer);



================================================
File: src/components/common/Header/index.tsx
================================================
import Navigation from "@/components/common/Navigation";
import { NavLink } from "react-router-dom";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import { DEFAULT_CHAIN_ID } from "@/constants/default-chain-id";
import { AlignJustify, WalletIcon } from "lucide-react";
import Loader from "../Loader";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { memo, useState } from "react";
import { Address } from "viem";
import { TransactionCard } from "../TransactionCard";
import { useAccount } from "wagmi";
import {
    usePendingTransactions,
    usePendingTransactionsStore,
} from "@/state/pendingTransactionsStore";
import tw, { styled } from "twin.macro";
import FloatingButton from "../FloatingButton";
import { abbreviate } from "@/lib/utils";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import PanelTitle from "../Panel/PanelTitle";
import PanelContainer from "../Panel/PanelContainer";
import PanelFooter from "../Panel/PanelFooter";
import { useExplorer } from "@/hooks/common/useWeb3";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import Image from "../Image";

const _Header = styled.div`
    height: var(--header-height);
    box-shadow: 0px 1px 0px 0px #000;
    ${() =>
        tw`fixed left-0 top-0 z-10 flex w-full items-center justify-between gap-4 bg-white px-[48px] m:px-[20px]`}
`;

const Header = memo(() => {
    const desktop = useMediaQuery("desktop");
    return (
        <_Header>
            <Glyph />
            {desktop && <Navigation />}
            <Account />
        </_Header>
    );
});

const _Logo = styled.div`
    .version {
        padding: 4px;
        border-radius: 4px;
        background: #f7931a;
        color: #fff;
        font-family: Geneva;
        font-size: 12px;
        font-style: normal;
        font-weight: 400;
        line-height: 1;

        ${() => tw`m:text-[8px]`}
    }
    ${() => tw`flex items-center gap-[16px] m:gap-[8px]`}
`;

const Glyph = memo(() => {
    const isMobile = useMediaQuery("mobile");

    return (
        <NavLink to={"/"}>
            <_Logo>
                <Image src="/logo.svg" width={isMobile ? 128 : 158} height={isMobile ? 25 : 32} />
                <div className="version">V4</div>
            </_Logo>
        </NavLink>
    );
});

const Account = memo(() => {
    const { open } = useWeb3Modal();
    const isMobile = useMediaQuery("mobile");

    const { pendingTransactions } = usePendingTransactionsStore();

    const { address: account } = useAccount();

    const desktop = useMediaQuery("desktop");

    const showTxHistory =
        account && pendingTransactions[account]
            ? Object.keys(pendingTransactions[account]).length > 0
            : false;

    const pendingTxCount =
        account && pendingTransactions[account]
            ? Object.entries(pendingTransactions[account]).filter(
                  ([, transaction]) => transaction.loading,
              ).length
            : 0;

    const { selectedNetworkId } = useWeb3ModalState();

    return (
        <div className="flex items-center justify-end gap-[16px] whitespace-nowrap m:gap-[12px]">
            <FloatingButton
                type="small"
                width={isMobile ? "36px" : "113px"}
                onClick={() => window.open("https://app.glyph.exchange/")}
            >
                {isMobile ? "V2" : "Launch V2"}
            </FloatingButton>

            <div className="hidden m:block">
                <FloatingButton type="small" width="25px" height="25px" onClick={() => open()}>
                    <WalletIcon
                        size={16}
                        color={selectedNetworkId !== DEFAULT_CHAIN_ID ? "#FD375B" : undefined}
                    />
                </FloatingButton>
            </div>
            <FloatingButton
                className="m:hidden"
                color={selectedNetworkId !== DEFAULT_CHAIN_ID ? "#FD375B" : undefined}
                width={account ? "134px" : "88px"}
                type="small"
                onClick={() => open()}
            >
                {account ? abbreviate(account) : "Connect"}
            </FloatingButton>

            {showTxHistory && (
                <TransactionHistoryMdoal>
                    <FloatingButton
                        width={pendingTxCount > 0 ? "100px" : desktop ? "30px" : "25px"}
                        height={desktop ? undefined : "25px"}
                        type="small"
                        aria-label="Transaction history"
                    >
                        {pendingTxCount > 0 ? (
                            <div className="flex items-center justify-center">
                                <Loader className="shrink-0" size={14} />
                                <span>{pendingTxCount}</span>
                                <span className="truncate">Pending</span>
                            </div>
                        ) : (
                            <AlignJustify size={16} />
                        )}
                    </FloatingButton>
                </TransactionHistoryMdoal>
            )}
        </div>
    );
});

const _TransactionTitle = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;

    ${() => tw`m:text-[12px]`}
`;
const TransactionHistoryMdoal: FCProps = memo(({ className, children }) => {
    const [isOpen, setIsOpen] = useState<boolean>(false);
    const pendingTransactions = usePendingTransactions();
    const { address: account } = useAccount();
    const { toHash } = useExplorer();

    if (account) {
        return (
            <Credenza className={className} open={isOpen} onOpenChange={setIsOpen}>
                <CredenzaTrigger asChild>{children}</CredenzaTrigger>
                <CredenzaContent
                    onInteractOutside={() => setIsOpen(false)}
                    onEscapeKeyDown={() => setIsOpen(false)}
                >
                    <PanelTitle title="HISTORY" />
                    <CredenzaClose onClick={() => setIsOpen(false)} />
                    <PanelContainer
                        className="bb1"
                        scrollContentClassName="h-[60px] flex items-center px-[25px] m:px-[20px] relative"
                    >
                        <_TransactionTitle>Transaction History</_TransactionTitle>
                        <div className="absolute bottom-[3px] left-0 w-full bg-black bb1"></div>
                    </PanelContainer>
                    <PanelContainer alwayDisplayScroll className="!h-[430px]">
                        <ul>
                            {Object.entries(pendingTransactions[account])
                                .reverse()
                                .map(([hash, transaction]) => (
                                    <TransactionCard
                                        key={hash}
                                        hash={hash as Address}
                                        transaction={transaction}
                                        toHash={toHash}
                                    />
                                ))}
                        </ul>
                    </PanelContainer>
                    <PanelFooter />
                </CredenzaContent>
            </Credenza>
        );
    }
});

const TransactionHistoryPopover = ({ children }: { children: React.ReactNode }) => {
    const [isOpen, setIsOpen] = useState<boolean>(false);
    const pendingTransactions = usePendingTransactions();
    const { address: account } = useAccount();
    const { toHash } = useExplorer();

    if (account)
        return (
            <Popover open={isOpen} onOpenChange={setIsOpen}>
                <PopoverTrigger>{children}</PopoverTrigger>
                <PopoverContent
                    align="end"
                    className="flex max-h-80 w-fit flex-col gap-4"
                    sideOffset={20}
                >
                    Transaction History
                    <hr />
                    <ul className="flex w-64 flex-col gap-4 overflow-auto">
                        {Object.entries(pendingTransactions[account])
                            .reverse()
                            .map(([hash, transaction]) => (
                                <TransactionCard
                                    key={hash}
                                    hash={hash as Address}
                                    transaction={transaction}
                                    toHash={toHash}
                                />
                            ))}
                    </ul>
                </PopoverContent>
            </Popover>
        );
};

export default Header;



================================================
File: src/components/common/Info/InfoBase.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _InfoBase = styled.div`
    border-top: 1px solid #000;
    background: #f5f5f5;
    padding: 14px 20px 14px 24px;

    &::before {
        content: "";
        background-color: #000;
        height: 1px;
        width: calc(100% - 6px);
        bottom: 3px;
        ${() => tw`absolute left-1/2 -translate-x-1/2`}
    }

    ${() => tw`relative flex flex-col gap-[8px] m:px-[20px] m:pt-[12px]`}
`;

const InfoBase: FCProps = (props) => {
    return <_InfoBase {...props}>{props.children}</_InfoBase>;
};

export default memo(InfoBase);



================================================
File: src/components/common/Info/InfoItem.tsx
================================================
import { ReactNode, memo } from "react";
import tw, { styled } from "twin.macro";

const _InfoItem = styled.div`
    ${() => tw`flex items-center justify-between gap-[8px]`}
`;

const _InfoLabel = styled.div`
    font-family: FraktionMono-Bold;
    font-size: 10px;
    color: #000;
    flex-shrink: 0;
    ${() => tw`whitespace-nowrap uppercase m:text-[8px]`}
`;
const _InfoValue = styled.div`
    font-family: Geneva-Regular;
    font-size: 10px;
    color: #000;
    ${() => tw`truncate m:text-[8px]`}
`;

const InfoItem: FCProps<{
    label?: ReactNode;
    value?: ReactNode;
}> = ({ label, value, className, style, onClick }) => {
    return (
        <_InfoItem className={className} style={style} onClick={onClick}>
            {label && <_InfoLabel>{label}</_InfoLabel>}
            {value && <_InfoValue>{value}</_InfoValue>}
        </_InfoItem>
    );
};

export default memo(InfoItem);



================================================
File: src/components/common/Layout/index.tsx
================================================
import { Toaster } from "@/components/ui/toaster";
import Header from "../Header";
import { memo } from "react";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import Footer from "../Footer";

interface LayoutProps {
    children: React.ReactNode;
}

const Layout = ({ children }: LayoutProps) => {
    const isMobile = useMediaQuery("mobile");

    return (
        <div className="flex h-full w-full flex-col">
            <Header />
            <main className="h-full">{children}</main>

            {isMobile && <Footer />}
            <Toaster />
        </div>
    );
};

export default memo(Layout);



================================================
File: src/components/common/Loader/index.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { cn } from "@/lib/utils";
import { Loader2Icon } from "lucide-react";
import { useEffect } from "react";

interface LoaderProps {
    size?: number;
    color?: string;
    className?: string;
}

const Loader = ({ size, color = "black", className }: LoaderProps) => {
    const isMobile = useMediaQuery("mobile");
    return (
        <Loader2Icon
            size={size ?? isMobile ? 18 : 20}
            color={color}
            className={cn("animate-spin", className)}
        />
    );
};

export default Loader;



================================================
File: src/components/common/Navigation/External.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";
import Image from "../Image";

const _External = styled.div`
    ${() => tw`relative`}
`;

const _Menu = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 1;
    border: 1px solid transparent;

    &:hover {
        color: #fff;
        background-color: #000;
    }

    ${() =>
        tw`cursor-pointer select-none rounded-[6px] px-[16px] py-[9px] duration-200 m:text-[12px]`}
`;

const _Content = styled.div`
    ${() => tw`absolute left-0 top-full w-[205px] flex-col pt-[13px]`}
`;

const _Item = styled.a`
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    background-color: #fff;
    text-align: left;
    height: 38px;
    gap: 4px;

    &:hover {
        background-color: #000;
        color: #fff;
    }

    &:not(:first-of-type) {
        border-top: 1px dashed #000;
    }

    ${() => tw`flex items-center px-[16px] duration-200`}
`;

const External: FCProps<{ menu: { title: string; items?: { name: string; link: string }[] } }> = ({
    className,
    style,
    menu,
}) => {
    return (
        <_External className={`${className} group`} style={style}>
            <_Menu>{menu.title}</_Menu>
            {menu.items && (
                <_Content className="hidden group-hover:flex">
                    {menu.items.map((item) => (
                        <_Item
                            key={item.name}
                            className="group/item"
                            href={item.link}
                            target="_blank"
                        >
                            {item.name}
                            <Image
                                className="duration-150 group-hover/item:invert"
                                src="/link.svg"
                                width={14}
                                height={14}
                            />
                        </_Item>
                    ))}
                </_Content>
            )}
        </_External>
    );
};

export default memo(External);



================================================
File: src/components/common/Navigation/index.tsx
================================================
import { NavLink, matchPath, useLocation } from "react-router-dom";
import tw from "twin.macro";
import { styled } from "twin.macro";
import { memo } from "react";
import External from "./External";

const PATHS = {
    SWAP: "/swap",
    POOLS: "/pools",
};

const menuItems = [
    {
        title: "SWAP",
        link: "/swap",
        active: [PATHS.SWAP],
    },
    {
        title: "POOL",
        link: "/pools",
        active: [PATHS.POOLS],
    },
];

const _Link = styled(NavLink)`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 1;
    border: 1px solid transparent;
    ${() => tw`select-none rounded-[6px] bg-white px-[16px] py-[9px] duration-200 m:text-[12px]`}
`;

const Navigation = memo(() => {
    const { pathname } = useLocation();

    const setNavlinkClasses = (paths: string[]) =>
        paths.some((path) => matchPath(path, pathname))
            ? "text-black !border-black"
            : "hover:bg-black hover:text-white";

    return (
        <nav>
            <ul className="flex justify-center gap-[16px] whitespace-nowrap">
                {menuItems.map((item) => (
                    <_Link
                        key={`nav-item-${item.link}`}
                        to={item.link}
                        className={`${setNavlinkClasses(item.active)} `}
                    >
                        {item.title}
                    </_Link>
                ))}
                <External
                    key="bridge"
                    menu={{
                        title: "BRIDGE",
                        items: [
                            { name: "Core Official Bridge", link: "https://bridge.coredao.org/" },
                            // { name: "Orange Bridge", link: "https://bridge.orangecrypto.com/" },
                            { name: "Stargate Finance", link: "https://stargate.finance/" },
                        ],
                    }}
                />

                <External
                    key="socials"
                    menu={{
                        title: ":-)",
                        items: [
                            { name: "X (Twitter)", link: "https://twitter.com/glyph_exchange" },
                            { name: "Discord", link: "https://discord.com/invite/glyphexchange" },
                            {
                                name: "Document",
                                link: "https://glyph-exhange.gitbook.io/glyph.exchange",
                            },
                        ],
                    }}
                />
            </ul>
        </nav>
    );
});

export default Navigation;



================================================
File: src/components/common/PageContainer/index.tsx
================================================
import tw, { styled } from "twin.macro";

interface PageContainerProps {
    children: React.ReactNode;
    className?: string;
}

const _PageContainer = styled.div`
    ${() => tw`flex flex-col items-start py-[20px] lg:py-[55px]`}
`;
const PageContainer = ({ children, className }: PageContainerProps) => {
    return <_PageContainer className={className}>{children}</_PageContainer>;
};

export default PageContainer;



================================================
File: src/components/common/PageTitle/index.tsx
================================================
import Settings from "../Settings";

interface PageTitleProps {
    title: string;
    showSettings?: boolean;
    children?: React.ReactNode
}

const PageTitle = ({ title, children, showSettings = true }: PageTitleProps) => {

    return <div className="flex w-full items-center justify-between">
        <div className="flex items-center gap-8">
            <h1 className="scroll-m-20 text-2xl font-bold tracking-tight md:text-3xl lg:text-4xl">{title}</h1>
            {children && children}
        </div>
        {showSettings && <Settings />}
    </div>

}

export default PageTitle;


================================================
File: src/components/common/Panel/PanelBase.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _PanelBase = styled.div`
    backdrop-filter: blur(50px);
    border: 1px solid #000;
    box-shadow: 1px 1px 0px 1px #000;
    background-color: #fff;
    ${() => tw`flex flex-col`}
`;
const PanelBase: FCProps = (props) => {
    return <_PanelBase {...props}>{props.children}</_PanelBase>;
};

export default memo(PanelBase);



================================================
File: src/components/common/Panel/PanelContainer.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { memo, useEffect, useMemo } from "react";
import { useMeasure } from "react-use";
import tw, { styled } from "twin.macro";

const _VerticalLine = styled.div`
    position: absolute;
    width: 1px;
    height: 100%;
    top: 0;
    right: 28px;
    background-color: #000;

    ${() => tw`m:right-[16px]`};
`;

const _ScrollContent = styled.div``;

const _ScrollArea = styled.div<{
    $hasScrollbar?: boolean;
    $alwayDisplayScroll?: boolean;
    $isMobile: boolean;
}>`
    overflow-x: hidden;
    overflow-y: ${(props) =>
        props.$hasScrollbar || props.$alwayDisplayScroll ? "scroll" : "hidden"};
    height: 100%;
    max-height: inherit;
    padding-right: ${(props) =>
        props.$hasScrollbar || props.$alwayDisplayScroll ? "0" : props.$isMobile ? "16px" : "28px"};

    &::-webkit-scrollbar-thumb {
        border-width: 1px;
        border-left: 0;
        border-right: 0;
    }

    &::-webkit-scrollbar-track {
        border: 0;
        background-image: ${(props) => (props.$hasScrollbar ? 'url("/bg-fragment.png")' : "none")};
    }
`;

const _PanelContainer = styled.div`
    /* flex: 1; */
    height: inherit;
    max-height: inherit;
    overflow: hidden;
    position: relative;
`;

const PanelContainer: FCProps<{
    alwayDisplayScroll?: boolean;
    scrollContentClassName?: string;
}> = ({ alwayDisplayScroll = false, children, className, style, scrollContentClassName }) => {
    const [areaRef, { height: areaHeight }] = useMeasure<HTMLDivElement>();
    const [contentRef, { height: contentHeight }] = useMeasure<HTMLDivElement>();
    const isMobile = useMediaQuery("mobile");
    const hasScrollbar = useMemo(() => contentHeight > areaHeight, [areaHeight, contentHeight]);

    return (
        <_PanelContainer className={className} style={style}>
            <_ScrollArea
                ref={areaRef}
                $isMobile={isMobile}
                $hasScrollbar={hasScrollbar}
                $alwayDisplayScroll={alwayDisplayScroll}
            >
                <_ScrollContent className={scrollContentClassName} ref={contentRef}>
                    {children}
                </_ScrollContent>
            </_ScrollArea>
            <_VerticalLine />
        </_PanelContainer>
    );
};

export default memo(PanelContainer);



================================================
File: src/components/common/Panel/PanelFooter.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _VerticalLine = styled.div`
    position: absolute;
    width: 1px;
    height: 100%;
    top: 0;
    background-color: #000;
    right: 28px;

    ${() => tw`m:right-[16px]`};
`;

const _ResizeImg = styled.img`
    position: absolute;
    bottom: 6px;
    right: 6px;

    ${() => tw`m:bottom-[3px] m:right-[3px]`};
`;

const _PanelFooter = styled.div`
    border-top: 1px solid #000;
    position: relative;
    height: 28px;

    ${() => tw`m:h-[16px]`};
`;
const PanelFooter: FCProps = () => {
    const isMobile = useMediaQuery("mobile");

    return (
        <_PanelFooter>
            <_VerticalLine />
            <_ResizeImg
                width={isMobile ? 10 : 16}
                height={isMobile ? 10 : 16}
                src="/resize.svg"
                alt=""
            />
        </_PanelFooter>
    );
};

export default memo(PanelFooter);



================================================
File: src/components/common/Panel/PanelTitle.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { memo } from "react";
import tw, { styled, theme } from "twin.macro";

const _PanelTitle = styled.div`
    padding: 6px 4px;
    width: 100%;
    height: 28px;
    border-bottom: 1px solid #000;
    ${() => tw`relative flex truncate uppercase m:h-[21px]`}
`;
const _Title = styled.div`
    padding: 0 8px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;
    font-family: FraktionMono-Bold;
    font-size: 20px;
    letter-spacing: -0.08px;
    color: #000;

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 14px;
        letter-spacing: -0.056px;
    }
`;

const Img = styled.img`
    width: 100%;
    height: 16px;

    ${() => tw`m:h-[10px]`}
`;

const PanelTitle: FCProps<{ title?: string; className?: string }> = ({ title, className }) => {
    const isMobile = useMediaQuery("mobile");

    return (
        <_PanelTitle className={className}>
            <Img src={isMobile ? "/horizontal-line-mobile.svg" : "/horizontal-line.svg"} />
            {title && <_Title>{title}</_Title>}
        </_PanelTitle>
    );
};

export default memo(PanelTitle);



================================================
File: src/components/common/PluginIcons/index.tsx
================================================
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import Image from "../Image";
import tw, { styled } from "twin.macro";

const _PluginIconHoverCardContent = styled(HoverCardContent)`
    padding: 12px 16px;
    font-size: 12px;
    box-shadow: unset;
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(3px);

    ${() => tw`flex w-fit flex-col gap-[0] rounded-[4px] text-[#000] b1`}
`;

export const DynamicFeePluginIcon = () => (
    <HoverCard>
        <HoverCardTrigger>
            <Image width={20} height={20} src="/pool_dynamic_fee_coin.svg" alt="" />
            {/* <div className="text-sm h-fit py-2">
            <ZapIcon size={16} fill={'#d84eff'} stroke={'#d84eff'} />
        </div> */}
        </HoverCardTrigger>
        <_PluginIconHoverCardContent align={"start"} onClick={(e) => e.stopPropagation()}>
            <div className="mb-[8px] flex items-center gap-[4px]">
                <Image width={20} height={20} src="/pool_dynamic_fee_coin.svg" alt="" />
                <span className="font-[FraktionMono-Bold] font-bold">Dynamic Fees</span>
            </div>
            <div className="mb-[5px] text-left font-[Geneva] leading-[1.2]">
                This pool uses Dynamic Fees plugin
            </div>
            {/* <a
                className="flex w-fit items-center gap-[4px] text-left font-[Geneva] leading-[1.2] !text-[#F7931A] hover:underline"
                href={"https://docs.algebra.finance/algebra-integral/core-logic/plugins"}
                target={"_blank"}
            >
                Learn more
                <Image width={12} height={12} src="/link-orange.svg" alt="" />
            </a> */}
        </_PluginIconHoverCardContent>
    </HoverCard>
);

export const FarmingPluginIcon = () => (
    <HoverCard>
        <HoverCardTrigger>
            <Image width={20} height={20} src="/farming_pool_coin.svg" alt="" />
            {/* <div className="text-sm h-fit py-2">
                <Tractor size={16} stroke={'#d84eff'} />
            </div> */}
        </HoverCardTrigger>
        <_PluginIconHoverCardContent align={"start"} onClick={(e) => e.stopPropagation()}>
            <div className="mb-[8px] flex items-center gap-[4px]">
                <Image width={20} height={20} src="/pool_dynamic_fee_coin.svg" alt="" />
                <span className="font-[FraktionMono-Bold] font-bold">Farming Available</span>
            </div>
            <div className="mb-[5px] text-left font-[Geneva] leading-[1.2]">
                This pool uses Built-in Farming plugin
            </div>
            {/* <a
                className="flex w-fit items-center gap-[4px] text-left font-[Geneva] leading-[1.2] !text-[#F7931A] hover:underline"
                href={"https://docs.algebra.finance/algebra-integral/core-logic/plugins"}
                target={"_blank"}
            >
                Learn more
                <Image width={12} height={12} src="/link-orange.svg" alt="" />
            </a> */}
        </_PluginIconHoverCardContent>
    </HoverCard>
);

export const CoreIgnitionPluginIcon = () => (
    <HoverCard>
        <HoverCardTrigger>
            <Image width={20} height={20} src="/plugins/coreIgnition.svg" alt="" />
        </HoverCardTrigger>
        <_PluginIconHoverCardContent align={"start"} onClick={(e) => e.stopPropagation()}>
            <div className="mb-[8px] flex items-center gap-[4px]">
                <Image width={20} height={20} src="/plugins/coreIgnition.svg" alt="" />
                <span className="font-[FraktionMono-Bold] font-bold">CORE Ignition</span>
            </div>
            <div className="mb-[5px] text-left font-[Geneva] leading-[1.2]">
                You can earns Ignition Sparks in this pool
            </div>
            <a
                className="flex w-fit items-center gap-[4px] text-left font-[Geneva] leading-[1.2] !text-[#F7931A] hover:underline"
                href={"https://ignition.coredao.org/"}
                target={"_blank"}
            >
                Learn more
                <Image width={12} height={12} src="/link-orange.svg" alt="" />
            </a>
        </_PluginIconHoverCardContent>
    </HoverCard>
);

export const GammaPluginIcon = () => (
    <HoverCard>
        <HoverCardTrigger>
            <Image width={20} height={20} src="/gamma-icon.svg" alt="" />
        </HoverCardTrigger>
        <_PluginIconHoverCardContent align={"start"} onClick={(e) => e.stopPropagation()}>
            <div className="mb-[8px] flex items-center gap-[4px]">
                <Image width={20} height={20} src="/gamma-icon.svg" alt="" />
                <span className="font-[FraktionMono-Bold] font-bold">Gamma Strategy Powered</span>
            </div>
            <div className="mb-[5px] max-w-[255px] text-left font-[Geneva] leading-[1.2]">
                Gamma Strategy manages your position and boosts your APR.
            </div>
        </_PluginIconHoverCardContent>
    </HoverCard>
);



================================================
File: src/components/common/PoweredBy/Aggregator.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _PoweredByAggregator = styled.a`
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;

    ${() => tw`flex items-center justify-center gap-[3px] rounded-[4px] bg-white p-[9px] b1`}
`;
const PoweredByAggregator = ({ className }: { className?: string }) => {
    return (
        <_PoweredByAggregator
            href={"https://icecreamswap.com"}
            target="_blank"
            className={className}
        >
            <span>Aggregator Powered by</span>
            <img src="/icecream.png" width={82} height={26} />
        </_PoweredByAggregator>
    );
};

export default memo(PoweredByAggregator);



================================================
File: src/components/common/PoweredBy/Algebra.tsx
================================================
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _PoweredByAlgebra = styled.a`
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: normal;

    ${() => tw`flex items-center justify-center gap-[5px] rounded-[4px] bg-white p-[12px] b1`}
`;
const PoweredByAlgebra = ({ className }: { className?: string }) => {
    return (
        <_PoweredByAlgebra href={"https://algebra.finance"} target="_blank" className={className}>
            <span>Powered by</span>
            <img src="/algebra-logo.svg" width={16} height={16} />
            <img src="/algebra-itegral.svg" width={104} height={16} />
        </_PoweredByAlgebra>
    );
};

export default memo(PoweredByAlgebra);



================================================
File: src/components/common/Settings/index.tsx
================================================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Separator } from "@/components/ui/separator";
import { Switch } from "@/components/ui/switch";
import { useUserState } from "@/state/userStore";
import { Percent } from "@glyph-exchange/integral-sdk";
import { memo, useState } from "react";
import Image from "../Image";
import tw, { styled } from "twin.macro";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import PanelTitle from "../Panel/PanelTitle";
import PanelContainer from "../Panel/PanelContainer";
import PanelFooter from "../Panel/PanelFooter";
import { SettingsIcon } from "lucide-react";
import WarningBox from "../WarningBox";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

const _SettingButton = styled.div`
    padding: 6px 8px;
    border-radius: 2px;
    border: 1px solid #000;
    background: #fff;
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    ${() => tw`ml-auto flex w-max cursor-pointer items-center gap-[4px] m:text-[10px]`}
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;

    ${() => tw`flex items-center justify-between m:text-[12px]`}
`;

const _Desc = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw`m:text-[10px]`}
`;

const _Button = styled.div`
    border-radius: 6px;
    border: 1px solid #000;
    background: #fff;
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    &.active {
        background: #000;
        color: white;
    }

    ${() => tw`flex cursor-pointer items-center p-[8px_11px] transition-colors m:text-[12px]`}
`;

const _Input = styled(Input)`
    padding: 4px 0 4px 16px;
    ${() =>
        tw`h-[35px] rounded-[4px] rounded-r-none border-none bg-[#E8E8E8] text-right text-[14px] text-[#000] placeholder:text-[#999] m:pl-[12px] m:text-[12px]`}
`;

const _Suffix = styled.div`
    ${() =>
        tw`flex select-none items-center rounded-[4px] rounded-l-none bg-[#E8E8E8] pl-[6px] pr-[16px] text-[#000] m:pr-[12px]`}
`;

export const SettingModal: FCProps<{ inAggregator?: boolean }> = memo(
    ({ className, style, inAggregator = false }) => {
        const [isOpen, setIsOpen] = useState(false);
        const { slippage } = useUserState();
        const isMobile = useMediaQuery("mobile");

        return (
            <Credenza className={className} open={isOpen} onOpenChange={setIsOpen}>
                <CredenzaTrigger asChild>
                    <_SettingButton onClick={() => setIsOpen(true)}>
                        {slippage !== "auto" && <span>{Number(slippage.toFixed(2))}%</span>}
                        Slippage
                        <Image
                            width={isMobile ? 12 : 16}
                            height={isMobile ? 12 : 16}
                            src="/setting.svg"
                        />
                    </_SettingButton>
                </CredenzaTrigger>
                <CredenzaContent
                    onInteractOutside={() => setIsOpen(false)}
                    onEscapeKeyDown={() => setIsOpen(false)}
                >
                    <PanelTitle title="TRANSACTION SETTINGS" />
                    <CredenzaClose onClick={() => setIsOpen(false)} />
                    <PanelContainer>
                        <div className="flex flex-col gap-[28px] p-[32px_24px] m:gap-[24px] m:p-[20px_20px_28px]">
                            <SlippageTolerance />

                            {!inAggregator && (
                                <>
                                    <TransactionDeadline />
                                    <Multihop />
                                    <ExpertMode />
                                </>
                            )}
                        </div>
                    </PanelContainer>
                    <PanelFooter />
                </CredenzaContent>
            </Credenza>
        );
    },
);

const Settings = () => {
    return (
        <Popover>
            <PopoverTrigger asChild>
                <Button variant={"icon"} size={"icon"}>
                    <SettingsIcon />
                </Button>
            </PopoverTrigger>
            <PopoverContent
                alignOffset={-24}
                align={"end"}
                className="flex w-[406px] flex-col gap-4 rounded-3xl border border-card-border bg-card p-6 text-white"
            >
                <div className="text-md font-bold">Transaction Settings</div>
                <Separator orientation={"horizontal"} className="bg-border" />
                <SlippageTolerance />
                <TransactionDeadline />
                <Multihop />
                <ExpertMode />
            </PopoverContent>
        </Popover>
    );
};

const SlippageTolerance = () => {
    const {
        slippage,
        actions: { setSlippage },
    } = useUserState();

    const [slippageInput, setSlippageInput] = useState("");
    const [slippageError, setSlippageError] = useState<boolean>(false);

    function parseSlippageInput(value: string) {
        // populate what the user typed and clear the error
        setSlippageInput(value);
        setSlippageError(false);

        if (value.length === 0) {
            setSlippage("auto");
        } else {
            const parsed = Math.max(Math.floor(Number.parseFloat(value) * 100), 1);

            if (!Number.isInteger(parsed) || parsed < 0 || parsed > 5000) {
                setSlippage("auto");
                if (value !== ".") {
                    setSlippageError(true);
                }
            } else {
                setSlippage(new Percent(parsed, 10_000));
            }
        }
    }

    const tooLow = slippage !== "auto" && slippage.lessThan(new Percent(5, 10_000));
    const tooHigh = slippage !== "auto" && slippage.greaterThan(new Percent(1, 100));

    const slippageString = slippage !== "auto" ? slippage.toFixed(2) : "auto";

    return (
        <div className="flex flex-col gap-[16px] m:gap-[12px]">
            <_Title>Slippage Tolerance</_Title>
            <div className="flex flex-wrap gap-[8px]">
                <_Button
                    className={slippageString === "auto" ? "active" : ""}
                    onClick={() => parseSlippageInput("")}
                >
                    Auto
                </_Button>
                <_Button
                    className={slippageString === "0.10" ? "active" : ""}
                    onClick={() => parseSlippageInput("0.10")}
                >
                    0.1%
                </_Button>
                <_Button
                    className={slippageString === "0.50" ? "active" : ""}
                    onClick={() => parseSlippageInput("0.5")}
                >
                    0.5%
                </_Button>
                <_Button
                    className={slippageString === "1.00" ? "active" : ""}
                    onClick={() => parseSlippageInput("1")}
                >
                    1%
                </_Button>
                <div className="flex min-w-[80px] flex-1 rounded-[4px] font-[Geneva] text-[14px] b1 m:w-full m:flex-none m:text-[12px]">
                    <_Input
                        className="m:!text-left"
                        value={
                            slippageInput.length > 0
                                ? slippageInput
                                : slippage === "auto"
                                  ? ""
                                  : Math.max(Number(slippage.toFixed(2)), 0.01)
                        }
                        onChange={(e) => parseSlippageInput(e.target.value)}
                        onBlur={() => {
                            setSlippageInput("");
                            setSlippageError(false);
                        }}
                        placeholder={"0.0"}
                    />
                    <_Suffix>%</_Suffix>
                </div>
            </div>
            {slippageError || tooLow || tooHigh ? (
                <WarningBox
                    className="ml-[-24px] !w-[calc(100%_+_48px)] m:ml-[-20px] m:!w-[calc(100%_+_40px)]"
                    emphatic
                    description={
                        slippageError
                            ? "Enter a valid slippage percentage"
                            : tooLow
                              ? "Slippage below 0.05% may result in a failed transaction."
                              : "Your transaction may be frontrun and result in an unfavourable trade."
                    }
                />
            ) : null}
        </div>
    );
};

const TransactionDeadline = () => {
    const {
        txDeadline,
        actions: { setTxDeadline },
    } = useUserState();

    const [deadlineInput, setDeadlineInput] = useState("");
    const [deadlineError, setDeadlineError] = useState<boolean>(false);

    function parseCustomDeadline(value: string) {
        setDeadlineInput(value);
        setDeadlineError(false);

        if (value.length === 0) {
            setTxDeadline(60 * 30);
        } else {
            try {
                const parsed: number = Math.floor(Number.parseFloat(value) * 60);
                if (!Number.isInteger(parsed) || parsed < 60 || parsed > 180 * 60) {
                    setDeadlineError(true);
                } else {
                    setTxDeadline(parsed);
                }
            } catch (error) {
                setDeadlineError(true);
            }
        }
    }

    return (
        <div className="flex flex-col gap-[16px] m:gap-[12px]">
            <_Title>Transaction Deadline</_Title>
            <div className="flex rounded-[4px] font-[Geneva] text-[14px] b1 m:text-[12px]">
                <_Input
                    placeholder={"30"}
                    value={
                        deadlineInput.length > 0
                            ? deadlineInput
                            : txDeadline === 180
                              ? ""
                              : (txDeadline / 60).toString()
                    }
                    onChange={(e) => parseCustomDeadline(e.target.value)}
                    onBlur={() => {
                        setDeadlineInput("");
                        setDeadlineError(false);
                    }}
                    color={deadlineError ? "red" : ""}
                    className="!text-left"
                />
                <_Suffix>Minutes</_Suffix>
            </div>
        </div>
    );
};
const ExpertMode = () => {
    const {
        isExpertMode,
        actions: { setIsExpertMode },
    } = useUserState();

    return (
        <div className="flex flex-col gap-[8px]">
            <_Title>
                <label htmlFor="expert-mode">Expert mode</label>
                <Switch id="expert-mode" checked={isExpertMode} onCheckedChange={setIsExpertMode} />
            </_Title>
            <_Desc>
                Advanced control over swap parameters such as price setting and gas management.
            </_Desc>
        </div>
    );
};

const Multihop = () => {
    const {
        isMultihop,
        actions: { setIsMultihop },
    } = useUserState();

    return (
        <div className="flex flex-col gap-[8px]">
            <_Title>
                <label htmlFor="multihop">Multihop</label>
                <Switch id="multihop" checked={isMultihop} onCheckedChange={setIsMultihop} />
            </_Title>
            <_Desc>Optimized trades across multiple liquidity pools.</_Desc>
        </div>
    );
};

export default Settings;



================================================
File: src/components/common/Table/common.tsx
================================================
import { cn } from "@/lib/utils";
import { ChevronDownIcon } from "lucide-react";

interface HeaderItemProps {
    children: React.ReactNode;
    className?: string;
    sort?: () => void;
    isAsc?: boolean;
}

export const HeaderItem = ({ children, className, sort, isAsc }: HeaderItemProps) => (
    <div>
        <span
            onClick={() => sort && sort()}
            className={cn(
                "inline-flex select-none items-center gap-[2px] rounded-xl font-[FraktionMono-Bold] text-[10px] font-bold text-[#000] duration-300",
                className,
                sort && "cursor-pointer",
            )}
        >
            {children}
            {sort && (
                <ChevronDownIcon
                    color="black"
                    size={16}
                    className={`!mt-0 opacity-[0.4] ${isAsc ? "rotate-180" : "rotate-0"} duration-300`}
                />
            )}
        </span>
    </div>
);



================================================
File: src/components/common/Table/loadingState.tsx
================================================
import { Skeleton } from "@/components/ui/skeleton";

export const LoadingState = () => (
    <div className="flex w-full flex-col gap-4 p-4">
        {[1, 2, 3, 4].map((v) => (
            <Skeleton
                key={`table-skeleton-${v}`}
                className="h-[50px] w-full rounded-xl bg-[#999]"
            />
        ))}
    </div>
);



================================================
File: src/components/common/Table/myPositionsColumns.tsx
================================================
import { ColumnDef } from "@tanstack/react-table";
import { HeaderItem } from "./common";
import { formatUSD } from "@/utils/common/formatUSD";

interface MyPosition {
    id: number;
    outOfRange: boolean;
    range: string;
    liquidityUSD: number;
    feesUSD: number;
    apr: number;
    inGamma?: boolean;
}

export const myPositionsColumns: ColumnDef<MyPosition>[] = [
    {
        accessorKey: "id",
        header: () => <HeaderItem>ID</HeaderItem>,
        cell: ({ getValue }) => <span>{`#${getValue()}`}</span>,
    },
    {
        accessorKey: "liquidityUSD",
        header: ({ column }) => (
            <HeaderItem
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                LIQUIDITY
            </HeaderItem>
        ),
        cell: ({ getValue }) => formatUSD.format(getValue() as number),
    },
    {
        accessorKey: "feesUSD",
        header: ({ column }) => (
            <HeaderItem
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                FEES
            </HeaderItem>
        ),
        cell: ({ row, getValue }) => (
            <>{!row.original?.inGamma && formatUSD.format(getValue() as number)}</>
        ),
        // cell: ({ getValue }) => formatUSD.format(getValue() as number),
    },
    {
        accessorKey: "outOfRange",
        header: ({ column }) => (
            <HeaderItem
                className="min-w-[85px]"
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                STATUS
            </HeaderItem>
        ),
        cell: ({ row, getValue }) => (
            <>
                {row.original?.inGamma ? (
                    <span className="text-[10px] text-[#F7931A]">Narrow Strategy</span>
                ) : getValue() ? (
                    <span className="text-[#FD375B]">Out of range</span>
                ) : (
                    <span className="text-[#40B883]">In range</span>
                )}
            </>
        ),
    },
    {
        accessorKey: "range",
        header: () => <HeaderItem className="min-w-[167px]">Range</HeaderItem>,
        cell: ({ getValue }) => getValue() as string,
    },
    {
        accessorKey: "apr",
        header: ({ column }) => (
            <HeaderItem
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                APR
            </HeaderItem>
        ),
        cell: ({ getValue }) => `${(getValue() as number)?.toFixed(2)}%`,
    },
];



================================================
File: src/components/common/Table/myPositionsTable.tsx
================================================
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { usePositionFilterStore } from "@/state/positionFilterStore";
import {
    ColumnDef,
    ColumnFiltersState,
    SortingState,
    flexRender,
    getCoreRowModel,
    getFilteredRowModel,
    getSortedRowModel,
    useReactTable,
} from "@tanstack/react-table";
import { ChevronDown } from "lucide-react";
import { useCallback, useState } from "react";
import { useNavigate } from "react-router-dom";
import { LoadingState } from "./loadingState";
import { PositionsStatus } from "@/types/position-filter-status";

interface MyPositionsTableProps<TData, TValue> {
    columns: ColumnDef<TData, TValue>[];
    data: TData[];
    selectedRow?: number;
    action?: (args?: any) => void;
    defaultSortingID?: string;
    link?: string;
    showPagination?: boolean;
    searchID?: string;
    loading?: boolean;
}

const MyPositionsTable = <TData, TValue>({
    columns,
    data,
    selectedRow,
    action,
    link,
    defaultSortingID,
    loading,
}: MyPositionsTableProps<TData, TValue>) => {
    const [sorting, setSorting] = useState<SortingState>(
        defaultSortingID ? [{ id: defaultSortingID, desc: true }] : [],
    );
    const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);

    const [expandActive, setExpandActive] = useState(true);
    const [expandOnFarming, setExpandOnFarming] = useState(true);
    const [expandClosed, setExpandClosed] = useState(true);
    const [expandOnGamma, setExpandOnGamma] = useState(true);

    const { filterStatus } = usePositionFilterStore();

    const navigate = useNavigate();

    const table = useReactTable({
        data,
        columns,
        getCoreRowModel: getCoreRowModel(),
        onSortingChange: setSorting,
        getSortedRowModel: getSortedRowModel(),
        onColumnFiltersChange: setColumnFilters,
        getFilteredRowModel: getFilteredRowModel(),
        state: {
            sorting,
            columnFilters,
        },
    });

    const activePositions = data.filter(
        (pos: any) => !pos.inFarming && !pos.isClosed && !pos?.inGamma,
    );

    const farmingPositions = data.filter((pos: any) => pos.inFarming && !pos.isClosed);

    const closedPositions = data.filter((pos: any) => pos.isClosed);

    const gammaPositions = data.filter((pos: any) => pos?.inGamma && !pos.isClosed);

    const noActivePositions = !filterStatus.Open || activePositions.length === 0;
    const noFarmingPositions = !filterStatus.OnFarming || farmingPositions.length === 0;
    const noClosedPositions = !filterStatus.Closed || closedPositions.length === 0;
    const noGammaPositions = !filterStatus.OnGamma || gammaPositions.length === 0;

    const renderHeaderRow = useCallback(
        (positionStatus: PositionsStatus) => {
            const isStatusActive = positionStatus === PositionsStatus.OPEN;
            const isStatusOnFarming = positionStatus === PositionsStatus.ON_FARMING;
            const isStatusClosed = positionStatus === PositionsStatus.CLOSED;
            const isStatusOnGamma = positionStatus === PositionsStatus.ON_GAMMA;

            return (
                <TableRow
                    key={"open-positions"}
                    className="h-full w-[100%] cursor-pointer bg-[#F5F5F5]"
                    onClick={() => {
                        if (isStatusActive) setExpandActive(!expandActive);
                        if (isStatusOnFarming) setExpandOnFarming(!expandOnFarming);
                        if (isStatusClosed) setExpandClosed(!expandClosed);
                        if (isStatusOnGamma) setExpandOnGamma(!expandOnGamma);
                    }}
                >
                    <td
                        colSpan={columns.length}
                        className="h-[38px] whitespace-nowrap p-0 pl-[24px] text-left"
                    >
                        <span className="flex items-center gap-[2px] font-[FraktionMono-Bold] text-[10px] font-bold text-[#000]">
                            {isStatusActive && "Open"}
                            {isStatusOnFarming && "On Farming"}
                            {isStatusClosed && "Closed"}
                            {isStatusOnGamma && (
                                <div className="flex items-center">
                                    GAMMA VAULT
                                    <img
                                        width={12}
                                        height={12}
                                        src={"/gamma-icon.svg"}
                                        alt=""
                                        className="ml-[2px]"
                                    />
                                </div>
                            )}
                            <ChevronDown
                                className={cn(
                                    "mt-auto -rotate-180 transition-transform duration-200 ease-in-out",
                                    isStatusActive && !expandActive && "-rotate-0",
                                    isStatusOnFarming && !expandOnFarming && "-rotate-0",
                                    isStatusClosed && !expandClosed && "-rotate-0",
                                    isStatusOnGamma && !expandOnGamma && "-rotate-0",
                                )}
                                size={16}
                            />
                        </span>
                    </td>
                </TableRow>
            );
        },
        [expandActive, expandOnFarming, expandClosed, expandOnGamma, columns.length],
    );

    const renderPositions = useCallback(
        (positionStatus: PositionsStatus) => {
            const isStatusActive = positionStatus === PositionsStatus.OPEN;
            const isStatusOnFarming = positionStatus === PositionsStatus.ON_FARMING;
            const isStatusClosed = positionStatus === PositionsStatus.CLOSED;
            const isStatusOnGamma = positionStatus === PositionsStatus.ON_GAMMA;

            return table.getRowModel().rows.map((row: any) => {
                const isSelected = Number(selectedRow) === Number(row.original.id);
                if (
                    (isStatusActive &&
                        !row.original.inFarming &&
                        !row.original.isClosed &&
                        !row.original?.inGamma) ||
                    (isStatusOnFarming && row.original.inFarming && !row.original.isClosed) ||
                    (isStatusClosed && row.original.isClosed) ||
                    (isStatusOnGamma && row.original?.inGamma && !row.original.isClosed)
                ) {
                    return (
                        <TableRow
                            key={row.id}
                            data-state={row.getIsSelected() && "selected"}
                            className={`group h-[38px] w-full by1-[transparent] ${
                                isSelected ? "bg-[#FAFAFA]" : "bg-[#FFFFFF]"
                            } ${(action || link) && "cursor-pointer"} ${isStatusActive && !expandActive && "collapse border-0 opacity-0"} ${
                                isStatusOnFarming &&
                                !expandOnFarming &&
                                "collapse border-0 opacity-0"
                            } ${
                                isStatusOnGamma && !expandOnGamma && "collapse border-0 opacity-0"
                            } ${isStatusClosed && !expandClosed && "collapse border-0 opacity-0"}`}
                            onClick={() => {
                                if (action) {
                                    action(row.original.id);
                                } else if (link) {
                                    navigate(`/${link}/${row.original.id}`);
                                }
                            }}
                        >
                            {row.getVisibleCells().map((cell: any) => (
                                <TableCell
                                    key={cell.id}
                                    className={`text-left font-[Geneva] text-[12px] leading-[1.2] text-[#000] last:text-right last:[padding:0_26px_0_24px] group-hover:by1 ${isSelected ? "by1" : ""}`}
                                >
                                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                                </TableCell>
                            ))}
                        </TableRow>
                    );
                } else return null;
            });
        },
        [
            action,
            link,
            expandActive,
            expandOnFarming,
            expandClosed,
            expandOnGamma,
            selectedRow,
            table,
            navigate,
        ],
    );

    if (loading) return <LoadingState />;

    // const haveResults = useMemo(()=>{
    //     return table.getRowModel().rows?.length !== 0 ||
    //     (!filterStatus.Open &&
    //         !filterStatus.Closed &&
    //         !filterStatus.OnFarming) ||
    //     (noActivePositions &&
    //         noFarmingPositions &&
    //         !filterStatus.Closed) ||
    //     (noActivePositions &&
    //         noClosedPositions &&
    //         !filterStatus.OnFarming) ||
    //     (noActivePositions &&
    //         !filterStatus.Closed &&
    //         !filterStatus.OnFarming) ||
    //     (noFarmingPositions &&
    //         noClosedPositions &&
    //         !filterStatus.Open) ||
    //     (noFarmingPositions &&
    //         !filterStatus.Open &&
    //         !filterStatus.Closed) ||
    //     (noClosedPositions &&
    //         !filterStatus.Open &&
    //         !filterStatus.OnFarming)
    // },[filterStatus, noActivePositions,noFarmingPositions, noClosedPositions, table]);

    return (
        <>
            <Table>
                <TableHeader className="[&_tr]:[border:unset]">
                    {table.getHeaderGroups().map((headerGroup) => (
                        <TableRow key={headerGroup.id} className="hover:bg-transparent">
                            {headerGroup.headers.map((header) => (
                                <TableHead
                                    key={header.id}
                                    className="h-[35px] [padding:0px_8px_0_24px] last:[padding:0px_26px_0_24px] [&_svg]:mt-auto"
                                >
                                    {header.isPlaceholder
                                        ? null
                                        : flexRender(
                                              header.column.columnDef.header,
                                              header.getContext(),
                                          )}
                                </TableHead>
                            ))}
                        </TableRow>
                    ))}
                </TableHeader>
                <TableBody>
                    {table.getRowModel().rows?.length === 0 ||
                    (noActivePositions &&
                        noFarmingPositions &&
                        noClosedPositions &&
                        noGammaPositions) ? (
                        <TableRow className="h-full font-[Geneva] text-[14px] text-[#999]">
                            <TableCell
                                colSpan={columns.length}
                                className="h-24 !px-[24px] text-center"
                            >
                                No results.
                            </TableCell>
                        </TableRow>
                    ) : (
                        <>
                            {activePositions.length > 0 && filterStatus.Open && (
                                <>
                                    {renderHeaderRow(PositionsStatus.OPEN)}
                                    {renderPositions(PositionsStatus.OPEN)}
                                </>
                            )}

                            {farmingPositions.length > 0 && filterStatus.OnFarming && (
                                <>
                                    {renderHeaderRow(PositionsStatus.ON_FARMING)}
                                    {renderPositions(PositionsStatus.ON_FARMING)}
                                </>
                            )}
                            {closedPositions.length > 0 && filterStatus.Closed && (
                                <>
                                    {renderHeaderRow(PositionsStatus.CLOSED)}
                                    {renderPositions(PositionsStatus.CLOSED)}
                                </>
                            )}
                            {gammaPositions.length > 0 && filterStatus.OnGamma && (
                                <>
                                    {renderHeaderRow(PositionsStatus.ON_GAMMA)}
                                    {renderPositions(PositionsStatus.ON_GAMMA)}
                                </>
                            )}
                        </>
                    )}
                </TableBody>
            </Table>
        </>
    );
};

export default MyPositionsTable;



================================================
File: src/components/common/Table/poolsColumns.tsx
================================================
import { ColumnDef } from "@tanstack/react-table";
import { HeaderItem } from "./common";
import { Address } from "wagmi";
import CurrencyLogo from "../CurrencyLogo";
import { TokenFieldsFragment } from "@/graphql/generated/graphql";
import { formatUSD } from "@/utils/common/formatUSD";
import { usePoolPlugins } from "@/hooks/pools/usePoolPlugins";
import { Skeleton } from "@/components/ui/skeleton";
import { useCurrency } from "@/hooks/common/useCurrency";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import { formatPercent } from "@/utils/common/formatPercent";
import { ReactNode } from "react";
import tw, { styled } from "twin.macro";
import {
    CoreIgnitionPluginIcon,
    DynamicFeePluginIcon,
    FarmingPluginIcon,
    GammaPluginIcon,
} from "../PluginIcons";
import { cn } from "@/lib/utils";

const _SymbolFontStyle = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 12px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;
    max-width: 114px;
    ${() => tw`truncate`}
`;

const _PairFeeBox = styled.div`
    color: #fff;
    font-family: Geneva;
    font-size: 8px;
    font-style: normal;
    font-weight: 400;
    line-height: 14px;
    ${() => tw`flex items-center justify-center rounded-[4px] bg-[#000] px-[4px]`}
`;

const _DefaultFontStyle = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    ${() => tw``}
`;

const _AvgAPRHoverCardContent = styled(HoverCardContent)`
    padding: 12px 16px;
    font-size: 12px;
    box-shadow: unset;
    font-family: Geneva;
    font-weight: 400;
    line-height: 120%;
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(3px);

    ${() => tw`flex w-fit flex-col gap-[7px] rounded-[4px] text-[#000] b1`}
`;

interface Pair {
    token0: TokenFieldsFragment;
    token1: TokenFieldsFragment;
}

interface Pool {
    id: Address;
    associatePool: Address;
    pair: Pair;
    fee: number;
    tvlUSD: number;
    volume24USD: number;
    poolMaxApr: number;
    poolAvgApr: number;
    avgApr: number;
    farmApr: number;
    isMyPool: boolean;
    hasActiveFarming: boolean;
    isGamma?: boolean;
    isRainBow?: boolean;
    isCoreIgnition?: boolean;
}

const PoolPair = ({ id, associatePool, pair, fee, isGamma }: Pool) => {
    const token0 = pair.token0.id as Address;
    const token1 = pair.token1.id as Address;

    const currencyA = useCurrency(token0, true);
    const currencyB = useCurrency(token1, true);

    const poolId = isGamma ? associatePool : id;
    const { dynamicFeePlugin } = usePoolPlugins(poolId);

    return (
        <div className="flex items-center gap-[8px]">
            <div className="flex items-center">
                <CurrencyLogo currency={currencyA} size={24} />
                <CurrencyLogo currency={currencyB} size={24} className="-ml-2" />
            </div>

            {currencyA && currencyB ? (
                <_SymbolFontStyle>{`${currencyA?.symbol}-${currencyB?.symbol}`}</_SymbolFontStyle>
            ) : (
                <Skeleton className="h-[20px] w-[90px] bg-[#999]" />
            )}

            <_PairFeeBox
                className={cn({
                    "!bg-[#F7931A]": !dynamicFeePlugin,
                })}
            >{`${fee}%`}</_PairFeeBox>

            {isGamma && <GammaPluginIcon />}
        </div>
    );
};

const Plugins = ({ id, associatePool, isGamma, isRainBow, isCoreIgnition }: Pool) => {
    const poolId = isGamma ? associatePool : id;
    const { dynamicFeePlugin, farmingPlugin } = usePoolPlugins(poolId);

    return (
        <div className="flex items-center gap-[8px]">
            {dynamicFeePlugin && <DynamicFeePluginIcon />}
            {farmingPlugin && !isGamma && <FarmingPluginIcon />}
            {isRainBow && <img width={20} height={20} src={"/plugins/rainBow.svg"} alt="" />}
            {isCoreIgnition && <CoreIgnitionPluginIcon />}

            {/* {dynamicFeePlugin && (
                <Image width={20} height={20} src="/pool_dynamic_fee_coin.svg" alt="" />
            )}
            {farmingPlugin && <Image width={20} height={20} src="/farming_pool_coin.svg" alt="" />} */}
        </div>
    );
};

const AvgAPR = ({
    children,
    avgApr,
    farmApr,
    maxApr,
}: {
    children: ReactNode;
    avgApr: string;
    farmApr: string | undefined;
    maxApr: string;
}) => {
    return (
        <_DefaultFontStyle className="flex items-center">
            <HoverCard>
                <HoverCardTrigger>{children}</HoverCardTrigger>
                <_AvgAPRHoverCardContent align={"end"}>
                    <p>Avg. APR - {avgApr}</p>
                    {farmApr && <p>Farm APR - {farmApr}</p>}
                    {/* <p>Max APR - {maxApr}</p> */}
                </_AvgAPRHoverCardContent>
            </HoverCard>
        </_DefaultFontStyle>
    );
};

export const poolsColumns: ColumnDef<Pool>[] = [
    {
        accessorKey: "pair",
        header: () => <HeaderItem>POOL</HeaderItem>,
        cell: ({ row }) => <PoolPair {...row.original} />,
        filterFn: (v, _, value) =>
            [
                v.original.pair.token0.symbol,
                v.original.pair.token1.symbol,
                v.original.pair.token0.name,
                v.original.pair.token1.name,
            ]
                .join(" ")
                .toLowerCase()
                .includes(value.toLowerCase()),
    },
    {
        accessorKey: "plugins",
        header: () => <HeaderItem>PLUGINS</HeaderItem>,
        cell: ({ row }) => <Plugins {...row.original} />,
        filterFn: (v, _, value: boolean) => v.original.hasActiveFarming === value,
    },
    {
        accessorKey: "tvlUSD",
        header: ({ column }) => (
            <HeaderItem
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                TVL
            </HeaderItem>
        ),
        cell: ({ getValue }) => {
            return (
                <_DefaultFontStyle className="flex items-center">
                    {formatUSD.format(getValue() as number)}
                </_DefaultFontStyle>
            );
        },
    },
    // {
    //     accessorKey: "volume24USD",
    //     header: ({ column }) => (
    //         <HeaderItem sort={() => column.toggleSorting(column.getIsSorted() === "asc")} isAsc={column.getIsSorted() === "asc"}>
    //             Volume 24H
    //         </HeaderItem>
    //     ),
    //     cell: ({ getValue }) => formatUSD.format(getValue() as number),
    // },
    // {
    //     accessorKey: "fees24USD",
    //     header: ({ column }) => (
    //         <HeaderItem sort={() => column.toggleSorting(column.getIsSorted() === "asc")} isAsc={column.getIsSorted() === "asc"}>
    //             Fees 24H
    //         </HeaderItem>
    //     ),
    //     cell: ({ getValue }) => formatUSD.format(getValue() as number),
    // },
    {
        accessorKey: "avgApr",
        header: ({ column }) => (
            <HeaderItem
                sort={() => column.toggleSorting(column.getIsSorted() === "asc")}
                isAsc={column.getIsSorted() === "asc"}
            >
                AVG. APR
            </HeaderItem>
        ),
        cell: ({ getValue, row }) => {
            return (
                <AvgAPR
                    avgApr={formatPercent.format(row.original.poolAvgApr / 100)}
                    maxApr={formatPercent.format(row.original.poolMaxApr / 100)}
                    farmApr={
                        row.original.hasActiveFarming
                            ? formatPercent.format(row.original.farmApr / 100)
                            : undefined
                    }
                >
                    {formatPercent.format((getValue() as number) / 100)}
                </AvgAPR>
            );
        },
    },
];



================================================
File: src/components/common/Table/poolsTable.tsx
================================================
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import {
    ColumnDef,
    ColumnFiltersState,
    SortingState,
    flexRender,
    getCoreRowModel,
    getFilteredRowModel,
    getPaginationRowModel,
    getSortedRowModel,
    useReactTable,
} from "@tanstack/react-table";
import { useCallback, useEffect, useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { LoadingState } from "./loadingState";
import { Switch } from "@/components/ui/switch";
import Pagination from "@/components/ui/pagination";
import { styled, theme } from "twin.macro";
import PanelBase from "../Panel/PanelBase";
import tw from "twin.macro";
import PanelTitle from "../Panel/PanelTitle";
import PanelFooter from "../Panel/PanelFooter";
import PanelContainer from "../Panel/PanelContainer";
import Checkbox from "../Checkbox";
import { PoolTableType } from "@/types/pool-table-state";
import Image from "../Image";
import SearchBox from "../SearchBox";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

const _PoolTableBody = styled(PanelBase)`
    ${() => tw`h-[573px] w-full m:h-[588px]`}
`;

const _ListTopInfoBox = styled.div`
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 17px 0 3px;
    /* border-right: 1px solid #000; */
    box-sizing: border-box;
`;

const _HorizontalLine = styled.div`
    width: 100%;
    height: 1px;
    background: #000;
`;

const _CreateBtn = styled.div`
    height: 35px;
    border-radius: 6px;
    border: 1px solid #000;
    background: #000;

    display: flex;
    padding: 0 16px;
    justify-content: center;
    align-items: center;

    color: #fff;
    text-align: right;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 1.2;
    margin-left: 8px;

    @media (max-width: ${theme`screens.mobile.max`}) {
        margin-left: unset;
        height: 33px;
        padding: 0 12px;
        font-size: 12px;
    }
`;

interface PoolsTableProps<TData, TValue> {
    columns: ColumnDef<TData, TValue>[];
    data: TData[];
    action?: (args?: any) => void;
    defaultSortingID?: string;
    link?: string;
    showPagination?: boolean;
    searchID?: string;
    loading?: boolean;
}

const PoolsTable = <TData, TValue>({
    columns,
    data,
    action,
    link,
    defaultSortingID,
    showPagination = true,
    loading,
}: PoolsTableProps<TData, TValue>) => {
    const isMobile = useMediaQuery("mobile");
    const [sorting, setSorting] = useState<SortingState>(
        defaultSortingID ? [{ id: defaultSortingID, desc: true }] : [],
    );
    const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
    const [page, setPage] = useState(0);
    const PAGESIZE = 6;
    const searchID = "pair";

    const navigate = useNavigate();

    const table = useReactTable({
        data,
        columns,
        getCoreRowModel: getCoreRowModel(),
        getPaginationRowModel: showPagination ? getPaginationRowModel() : undefined,
        initialState: {
            pagination: {
                pageSize: PAGESIZE, // Set the initial page size here
            },
        },
        onSortingChange: setSorting,
        getSortedRowModel: getSortedRowModel(),
        onColumnFiltersChange: setColumnFilters,
        getFilteredRowModel: getFilteredRowModel(),
        state: {
            sorting,
            columnFilters,
        },
        globalFilterFn: (row: any, _, value: boolean | undefined) =>
            row.original.isMyPool === value,
    });

    const isMyPools: boolean | undefined = table.getState().globalFilter;

    const handlePageChange = useCallback(
        (page: number) => {
            setPage(page);
            table.setPageIndex(page);
        },
        [table],
    );

    useEffect(() => {
        setPage(0);
    }, [isMyPools]);

    const totalRows = Math.ceil(table.getFilteredRowModel().rows.length / PAGESIZE);
    // const startsFromRow = table.getState().pagination.pageIndex * table.getState().pagination.pageSize + 1;
    // const endsAtRow = Math.min(startsFromRow + table.getState().pagination.pageSize - 1, totalRows);

    if (loading) return <LoadingState />;

    return (
        <_PoolTableBody>
            <PanelTitle title={isMobile ? "POOLS" : "V4 POOLS"} />
            {searchID && (
                <PanelContainer className="!h-[auto] bb1">
                    <_ListTopInfoBox>
                        <div className="mb-[17px] flex w-full flex-wrap items-center px-[24px] m:mb-[14px] m:items-start m:gap-[12px] m:px-[21px]">
                            <div className="flex flex-[3.64] items-center justify-start m:flex-[1.375] m:flex-col m:items-start m:pt-[9px]">
                                <div className="flex flex-[1.88] items-center m:flex-1">
                                    <Checkbox
                                        key={PoolTableType.ALL}
                                        checked={!isMyPools}
                                        onClick={() => table.setGlobalFilter(undefined)}
                                        className="mr-[32px] m:mr-[22px]"
                                    >
                                        {PoolTableType.ALL}
                                    </Checkbox>

                                    <Checkbox
                                        key={PoolTableType.MYPOOLS}
                                        checked={isMyPools}
                                        onClick={() => table.setGlobalFilter(true)}
                                    >
                                        {PoolTableType.MYPOOLS}
                                    </Checkbox>
                                </div>
                                <div className="max-md:gap-[8px] max-sm:hidden flex w-fit flex-[1.76] items-center gap-[4px] m:mt-[29px] m:flex-1">
                                    <Switch
                                        id="farmingAvailable"
                                        checked={
                                            table.getColumn("plugins")?.getFilterValue() === true
                                        }
                                        onCheckedChange={() => {
                                            const column = table.getColumn("plugins");
                                            if (column?.getFilterValue() === undefined)
                                                column?.setFilterValue(true);
                                            else column?.setFilterValue(undefined);
                                            setPage(0);
                                        }}
                                        className="data-[state=checked]:bg-[#F2E9FF]"
                                    />
                                    <label
                                        className="flex cursor-pointer items-center gap-[4px]"
                                        htmlFor="farmingAvailable"
                                    >
                                        <Image
                                            width={isMobile ? 16 : 20}
                                            height={isMobile ? 16 : 20}
                                            src="/farming_pool_coin.svg"
                                            alt=""
                                        />
                                        <span className="max-md:hidden mt-[2px] font-[Geneva] text-[14px] leading-[1] text-[#000] m:mt-[unset] m:whitespace-nowrap m:text-[12px]">
                                            Farming Available
                                        </span>
                                    </label>
                                </div>
                            </div>
                            <div className="flex flex-[2.59] items-center justify-end m:flex-1 m:flex-col m:items-end m:justify-start">
                                <div className="flex flex-[1.59] items-center justify-end m:flex-1">
                                    <SearchBox
                                        value={
                                            (table
                                                .getColumn(searchID)
                                                ?.getFilterValue() as string) ?? ""
                                        }
                                        onChange={(event) => {
                                            table
                                                .getColumn(searchID)
                                                ?.setFilterValue(event.target.value);
                                            setPage(0);
                                        }}
                                        className="h-[35px] w-[164px] m:h-[33px] m:w-[100%]"
                                    />
                                </div>
                                <Link
                                    className="flex flex-[1] items-center justify-end m:mt-[12px]"
                                    to={"create"}
                                >
                                    <_CreateBtn>Create Pool</_CreateBtn>
                                </Link>
                            </div>
                        </div>
                        <_HorizontalLine></_HorizontalLine>
                    </_ListTopInfoBox>
                </PanelContainer>
            )}

            <PanelContainer
                alwayDisplayScroll={true}
                className="flex-1"
                scrollContentClassName="h-[100%] flex flex-col justify-between items-start"
            >
                <Table>
                    {table.getRowModel().rows.length && (
                        <TableHeader className="[&_tr]:[border:unset]">
                            {table.getHeaderGroups().map((headerGroup) => (
                                <TableRow key={headerGroup.id} className="hover:bg-transparent">
                                    {headerGroup.headers.map((header) => (
                                        <TableHead
                                            key={header.id}
                                            className="font-bold text-white [&_svg]:mt-auto"
                                        >
                                            {header.isPlaceholder
                                                ? null
                                                : flexRender(
                                                      header.column.columnDef.header,
                                                      header.getContext(),
                                                  )}
                                        </TableHead>
                                    ))}
                                </TableRow>
                            ))}
                        </TableHeader>
                    )}
                    <TableBody className="text-[16px]">
                        {!table.getRowModel().rows.length ? (
                            <TableRow className="h-full font-[Geneva] text-[14px] text-[#999]">
                                <TableCell
                                    colSpan={columns.length}
                                    className="h-24 !px-[24px] text-center"
                                >
                                    No results.
                                </TableCell>
                            </TableRow>
                        ) : (
                            table.getRowModel().rows.map((row: any) => {
                                return (
                                    <TableRow
                                        key={row.id}
                                        data-state={row.getIsSelected() && "selected"}
                                        className="group h-[52px] cursor-pointer by1-[transparent]"
                                        onClick={() => {
                                            if (action) {
                                                action(row.original.id);
                                            } else if (link) {
                                                navigate(`/${link}/${row.original.id}`);
                                            }
                                        }}
                                    >
                                        {row.getVisibleCells().map((cell: any) => (
                                            <TableCell
                                                key={cell.id}
                                                className="min-w-[229px] text-left last:min-w-[122px] group-hover:by1"
                                            >
                                                {flexRender(
                                                    cell.column.columnDef.cell,
                                                    cell.getContext(),
                                                )}
                                            </TableCell>
                                        ))}
                                    </TableRow>
                                );
                            })
                        )}
                    </TableBody>
                </Table>

                {showPagination && table.getRowModel().rows.length && (
                    <>
                        {/* <div className="flex items-center justify-end space-x-2 px-4 mt-auto">
                            {totalRows > 0 && (
                                <p className="mr-2">
                                    {startsFromRow === totalRows
                                        ? `${startsFromRow} of ${totalRows}`
                                        : `${startsFromRow} - ${endsAtRow} of ${totalRows}`}
                                </p>
                            )}
                            <Button variant="outline" size="sm" onClick={() => table.previousPage()} disabled={!table.getCanPreviousPage()}>
                                Previous
                            </Button>
                            <Button variant="outline" size="sm" onClick={() => table.nextPage()} disabled={!table.getCanNextPage()}>
                                Next
                            </Button>
                        </div> */}
                        <Pagination
                            totalPages={totalRows}
                            page={page}
                            handlePageChange={handlePageChange}
                            className="px-[23px] pb-[28px] pt-[auto] m:[padding:24px_0_22px_20px]"
                        />
                    </>
                )}
            </PanelContainer>

            <PanelFooter />
        </_PoolTableBody>
    );
};
export default PoolsTable;



================================================
File: src/components/common/TokenSelector/index.tsx
================================================
import { TokenFieldsFragment } from "@/graphql/generated/graphql";
import { useAlgebraToken } from "@/hooks/common/useAlgebraToken";
import { useCurrency } from "@/hooks/common/useCurrency";
import useDebounce from "@/hooks/common/useDebounce";
import { useFuse } from "@/hooks/common/useFuse";
import { useAllTokens } from "@/hooks/tokens/useAllTokens";
import { memo, MouseEventHandler, useCallback, useEffect, useMemo, useState } from "react";
import { FixedSizeList } from "react-window";
import { Address, isAddress } from "viem";
import { useAccount, useBalance } from "wagmi";
import CurrencyLogo from "../CurrencyLogo";
import { ADDRESS_ZERO, Currency, ExtendedNative, Token } from "@glyph-exchange/integral-sdk";
import { useTokensState } from "@/state/tokensStore";
import { cn } from "@/lib/utils";
import { formatBalance } from "@/utils/common/formatBalance";
import { styled } from "twin.macro";
import tw from "twin.macro";
import PanelContainer from "../Panel/PanelContainer";
import Image from "../Image";
import WarningBox from "../WarningBox";

const TokenSelectorView = {
    DEFAULT_LIST: "DEFAULT_LIST",
    IMPORT_TOKEN: "IMPORT_TOKEN",
    NOT_FOUND: "NOT_FOUND",
};

type TokenSelectorViewType = (typeof TokenSelectorView)[keyof typeof TokenSelectorView];

const _Input = styled.input`
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    border-radius: 4px;
    background: #e8e8e8;
    color: #000;

    ${() =>
        tw`w-full p-[12px_16px] shadow-none outline-none b1 placeholder:text-[#999] m:p-[8px_10px] m:text-[12px]`}
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;

    ${() => tw`m:text-[14px]`}
`;

const Search = ({
    data,
    onSearch,
}: {
    data: TokenFieldsFragment[];
    onSearch: (matchedTokens: TokenFieldsFragment[], importToken: Token | undefined) => void;
}) => {
    const [query, setQuery] = useState<Address | string | undefined>(undefined);
    const debouncedQuery = useDebounce(query, 200);
    const tokenEntity = useAlgebraToken(
        debouncedQuery && isAddress(debouncedQuery) ? debouncedQuery : undefined,
    );

    const fuseOptions = useMemo(
        () => ({
            keys: ["id", "symbol", "name"],
            threshold: 0,
        }),
        [],
    );

    const { result, pattern, search } = useFuse<TokenFieldsFragment>({
        data,
        options: fuseOptions,
    });

    const handleInput = (input: string | undefined) => {
        setQuery(input);
    };

    useEffect(() => {
        search(query);
    }, [query, search]);

    useEffect(() => {
        onSearch(result, tokenEntity instanceof ExtendedNative ? undefined : tokenEntity);
    }, [result, tokenEntity, pattern, onSearch]);

    return (
        <_Input
            type="text"
            placeholder="Search name or paste address"
            autoComplete="off"
            onChange={(e) => handleInput(e.target.value)}
        />
    );
};

const LoadingRow = () => (
    <PanelContainer
        alwayDisplayScroll
        scrollContentClassName="h-full flex items-center justify-center"
    >
        <Image src="/loading.gif" width={20} height={20} />
    </PanelContainer>
);

const _TokenRow = styled.button`
    border: 1px solid transparent;
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    padding: 12px 24px;

    ${() =>
        tw`flex w-full items-center justify-between border-x-0 text-left duration-75 hover:border-black disabled:opacity-60`}
`;

const TokenRow = ({
    account,
    token,
    onSelect,
    otherCurrency,
    style,
}: {
    token: TokenFieldsFragment;
    account: Address | undefined;
    onSelect: (currency: Currency) => void;
    otherCurrency: Currency | null | undefined;
    style: React.CSSProperties;
}) => {
    const currency = useCurrency(token.id as Address);

    const { data: balance, isLoading } = useBalance({
        address: account,
        token: token.id === ADDRESS_ZERO ? undefined : (token.id as Address),
    });

    const balanceString = useMemo(() => {
        if (isLoading || !balance) return "Loading...";

        return formatBalance(balance.formatted);
    }, [balance, isLoading]);

    const lock = otherCurrency?.isNative
        ? token.id === ADDRESS_ZERO
        : token.id.toLowerCase() === otherCurrency?.wrapped.address.toLowerCase();

    const [isCopied, setIsCopied] = useState(false);

    const handleCopy: MouseEventHandler<HTMLDivElement> = (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(token.id).then(() => {
            setIsCopied(true);
            setTimeout(() => setIsCopied(false), 3000);
        });
    };

    return (
        <_TokenRow
            disabled={lock}
            onClick={() => currency && onSelect(currency)}
            style={{ ...style, height: 52 }}
        >
            <div className="flex items-center gap-[8px]">
                <CurrencyLogo currency={currency} size={20} />
                <div>
                    <div>{token.symbol}</div>
                    <div className="text-[8px]">{token.name}</div>
                </div>
                <div
                    className={cn(
                        'relative cursor-pointer duration-75 after:absolute after:left-5 after:top-1/2 after:-translate-y-1/2 after:text-xs after:duration-100 after:content-["Copied"]',
                        isCopied ? "after:block" : "after:hidden",
                    )}
                    onClick={handleCopy}
                >
                    <Image src="/copy.svg" width={16} height={16} />
                </div>
            </div>
            <div className="tracking-[-0.24px] text-[#999]">
                {isLoading ? "Loading..." : balance ? balanceString : ""}
            </div>
        </_TokenRow>
    );
};

const ImportTokenRow = ({
    token,
    onImport,
}: {
    token: Token;
    onImport: (token: Token) => void;
}) => (
    <_TokenRow>
        <div className="flex items-center gap-[8px]">
            <CurrencyLogo currency={token} size={20} />
            <div>
                <div>{token.symbol}</div>
                <div className="text-[8px]">{token.name}</div>
            </div>
        </div>
        <button
            className="rounded-[4px] bg-black p-[7px_12px] text-white"
            onClick={() => onImport(token)}
        >
            Import
        </button>
    </_TokenRow>
);

export const TokenSelector = memo(
    ({
        onSelect,
        otherCurrency,
        showNativeToken,
    }: {
        onSelect: (currency: Currency) => void;
        otherCurrency: Currency | null | undefined;
        showNativeToken?: boolean;
    }) => {
        const { address: account } = useAccount();

        const [selectorView, setSelectorView] = useState<TokenSelectorViewType>(
            TokenSelectorView.DEFAULT_LIST,
        );

        const {
            actions: { importToken },
        } = useTokensState();

        const { tokens, isLoading } = useAllTokens(showNativeToken);

        const [matchedTokens, setMatchedTokens] = useState<TokenFieldsFragment[]>([]);
        const [tokenForImport, setTokenForImport] = useState<Token>();

        const filteredTokens = useMemo(
            () => (matchedTokens.length ? matchedTokens : tokens),
            [tokens, matchedTokens],
        );

        const handleSearch = useCallback(
            (matchedTokens: TokenFieldsFragment[], importToken: Token | undefined) => {
                if (matchedTokens.length) {
                    setMatchedTokens(matchedTokens);
                    setSelectorView(TokenSelectorView.DEFAULT_LIST);
                } else if (importToken) {
                    setTokenForImport(importToken);
                    setSelectorView(TokenSelectorView.IMPORT_TOKEN);
                } else if (!isLoading) {
                    setSelectorView(TokenSelectorView.NOT_FOUND);
                }
            },
            [isLoading],
        );

        const handleImport = useCallback(
            (token: Token) => {
                importToken(
                    token.address as Address,
                    token.symbol || "Unknown",
                    token.name || "Unknown",
                    token.decimals,
                    token.chainId,
                );
                setSelectorView(TokenSelectorView.DEFAULT_LIST);
                setTokenForImport(undefined);
            },
            [importToken],
        );

        const Row = useCallback(
            ({
                data,
                index,
                style,
            }: {
                data: TokenFieldsFragment[];
                index: number;
                style: React.CSSProperties;
            }) => {
                const token = data[index];

                if (!token) return null;

                return (
                    <TokenRow
                        account={account}
                        onSelect={onSelect}
                        token={token}
                        otherCurrency={otherCurrency}
                        style={style}
                    />
                );
            },
            [account, onSelect, otherCurrency],
        );

        const itemKey = useCallback((index: number, data: TokenFieldsFragment[]) => {
            const currency = data[index];
            return currency.name;
        }, []);

        return (
            <div className="text-black">
                <PanelContainer>
                    <div className="relative p-[24px] m:p-[16px_20px]">
                        <_Title className="mb-[12px]">Select A Token</_Title>
                        <Search data={tokens} onSearch={handleSearch} />
                        <div className="absolute bottom-[3px] left-0 w-full bb1"></div>
                    </div>
                </PanelContainer>
                <div className="h-[430px] border-t border-black">
                    {selectorView === TokenSelectorView.DEFAULT_LIST ? (
                        isLoading ? (
                            <LoadingRow />
                        ) : filteredTokens.length <= 8 ? (
                            <PanelContainer alwayDisplayScroll>
                                <FixedSizeList
                                    width={"100%"}
                                    height={430}
                                    itemData={filteredTokens}
                                    itemCount={filteredTokens.length}
                                    itemKey={itemKey}
                                    itemSize={52}
                                    className="!will-change-[unset]"
                                >
                                    {Row}
                                </FixedSizeList>
                            </PanelContainer>
                        ) : (
                            <FixedSizeList
                                width={"100%"}
                                height={430}
                                itemData={filteredTokens}
                                itemCount={filteredTokens.length}
                                itemKey={itemKey}
                                itemSize={52}
                                className="!will-change-[unset] [&>div]:br1"
                            >
                                {Row}
                            </FixedSizeList>
                        )
                    ) : selectorView === TokenSelectorView.IMPORT_TOKEN && tokenForImport ? (
                        <PanelContainer
                            alwayDisplayScroll
                            scrollContentClassName="py-[2px] relative h-full"
                        >
                            <ImportTokenRow token={tokenForImport} onImport={handleImport} />
                            <WarningBox
                                emphatic
                                className="absolute bottom-0"
                                description={`${tokenForImport.symbol} will be imported from an external token list. Glyph makes no representation about the quality, nature or legal categorisation of the token.`}
                            />
                        </PanelContainer>
                    ) : (
                        <PanelContainer alwayDisplayScroll>
                            <div className="mt-[40px] text-center font-[Geneva] text-[12px] text-[#999]">
                                No result found.
                            </div>
                        </PanelContainer>
                    )}
                </div>
            </div>
        );
    },
);



================================================
File: src/components/common/TransactionCard/index.tsx
================================================
import { useCurrency } from "@/hooks/common/useCurrency";
import { truncateHash } from "@/utils/common/truncateHash";
import { Address } from "viem";
import CurrencyLogo from "../CurrencyLogo";
import { Check, X } from "lucide-react";
import { Transaction, TransactionType } from "@/state/pendingTransactionsStore";
import Loader from "../Loader";
import { FarmingPositionImg } from "@/components/farming/FarmingPositionImg";
import { styled } from "twin.macro";
import tw from "twin.macro";
import Image from "../Image";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

const _TransactionCard = styled.li`
    height: 64px;
    padding: 10px 25px;

    ${() =>
        tw`flex w-full cursor-pointer items-center gap-[16px] transition-all duration-200 by1-[transparent] hover:border-black m:h-[52px] m:gap-[22px]`}
`;

const _TokenArea = styled.div`
    max-width: 56px;

    > :not(:first-child) {
        ${() => tw`ml-[-10px] m:ml-[-8px]`}
    }

    ${() => tw`flex w-full shrink-0 items-center m:max-w-[42px]`}
`;

const _Label = styled.div`
    color: #999;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw`truncate m:text-[10px]`}
`;
const _Value = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;
    margin-top: 6px;
    ${() => tw`truncate m:mt-[2px] m:text-[14px]`}
`;
export const TransactionCard = ({
    hash,
    transaction,
    toHash,
}: {
    hash: Address;
    transaction: Transaction;
    toHash?: (address: string) => void;
}) => {
    const currencyA = useCurrency(transaction.data.tokenA, true);
    const currencyB = useCurrency(transaction.data.tokenB, true);
    const isMobile = useMediaQuery("mobile");

    const txType = transaction.data.type;

    return (
        <_TransactionCard onClick={() => toHash?.(hash)} className="group" key={hash}>
            <_TokenArea>
                {txType === TransactionType.FARM && transaction.data.tokenId ? (
                    <FarmingPositionImg
                        className="h-[32px] m:h-[24px]"
                        positionId={BigInt(transaction.data.tokenId)}
                        size={isMobile ? 42 : 56}
                    />
                ) : currencyB && currencyA ? (
                    <>
                        <CurrencyLogo currency={currencyA} size={isMobile ? 24 : 32} />
                        <CurrencyLogo currency={currencyB} size={isMobile ? 24 : 32} />
                    </>
                ) : currencyA ? (
                    <CurrencyLogo currency={currencyA} size={isMobile ? 24 : 32} />
                ) : (
                    <Image src="/core.svg" width={40} height={40} />
                )}
            </_TokenArea>
            <div className="mr-auto flex min-w-0 flex-col">
                <_Label className="text-xs">{transaction.data.title}</_Label>
                {currencyB && currencyA ? (
                    <_Value>
                        {currencyA.symbol} / {currencyB.symbol}
                    </_Value>
                ) : currencyA ? (
                    <_Value>{currencyA.symbol}</_Value>
                ) : (
                    <_Value>{truncateHash(hash as Address)}</_Value>
                )}
            </div>
            <span className="shrink-0">
                {transaction.loading ? (
                    <Loader className="group-hover:hidden" size={isMobile ? 16 : 22} />
                ) : transaction.success ? (
                    <Check
                        className="text-[#F7931A] group-hover:hidden"
                        size={isMobile ? 16 : 22}
                    />
                ) : (
                    transaction.error && (
                        <X
                            className="text-[#FD375B] group-hover:hidden"
                            size={isMobile ? 16 : 22}
                        />
                    )
                )}
                <Image
                    width={isMobile ? 18 : 24}
                    height={isMobile ? 18 : 24}
                    src="/link.svg"
                    className="hidden group-hover:block"
                />
            </span>
        </_TransactionCard>
    );
};



================================================
File: src/components/create-pool/CreatePoolForm/index.tsx
================================================
import { useDerivedSwapInfo, useSwapState } from "@/state/swapStore";
import { ReactNode, useEffect, useMemo } from "react";
import { SwapField } from "@/types/swap-field";
import {
    ADDRESS_ZERO,
    INITIAL_POOL_FEE,
    NonfungiblePositionManager,
    computePoolAddress,
} from "@glyph-exchange/integral-sdk";
import { usePrepareAlgebraPositionManagerMulticall } from "@/generated";
import { useTransactionAwait } from "@/hooks/common/useTransactionAwait";
import { Address, useAccount, useContractWrite } from "wagmi";
import { useDerivedMintInfo, useMintState } from "@/state/mintStore";
import Loader from "@/components/common/Loader";
import { PoolState, usePool } from "@/hooks/pools/usePool";
import Summary from "../Summary";
import SelectPair from "../SelectPair";
import { STABLECOINS } from "@/constants/tokens";
import { TransactionType } from "@/state/pendingTransactionsStore";
import tw, { styled } from "twin.macro";
import FloatingButton from "@/components/common/FloatingButton";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import Image from "@/components/common/Image";
import { useNavigate } from "react-router-dom";
import WarningBox from "@/components/common/WarningBox";

const _CreatePoolForm = styled.div`
    ${() => tw``}
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;

    ${() => tw`text-left m:text-[12px]`}
`;

type HandleStatus = {
    content: ReactNode;
    disabled: boolean;
    action?: any;
};

const CreatePoolForm = () => {
    const { currencies } = useDerivedSwapInfo();

    const { address: account } = useAccount();

    const { open } = useWeb3Modal();

    const { selectedNetworkId } = useWeb3ModalState();

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    const navigate = useNavigate();

    const {
        actions: { selectCurrency },
    } = useSwapState();

    const {
        startPriceTypedValue,
        actions: { typeStartPriceInput },
    } = useMintState();

    const currencyA = currencies[SwapField.INPUT];
    const currencyB = currencies[SwapField.OUTPUT];

    const areCurrenciesSelected = currencyA && currencyB;

    const isSameToken = areCurrenciesSelected && currencyA.wrapped.equals(currencyB.wrapped);

    const poolAddress =
        areCurrenciesSelected && !isSameToken
            ? (computePoolAddress({
                  tokenA: currencyA.wrapped,
                  tokenB: currencyB.wrapped,
              }) as Address)
            : undefined;

    const [poolState] = usePool(poolAddress);

    const isPoolExists = poolState === PoolState.EXISTS;

    const mintInfo = useDerivedMintInfo(
        currencyA ?? undefined,
        currencyB ?? undefined,
        poolAddress ?? undefined,
        INITIAL_POOL_FEE,
        currencyA ?? undefined,
        undefined,
    );

    const { calldata, value } = useMemo(() => {
        if (!mintInfo?.pool)
            return {
                calldata: undefined,
                value: undefined,
            };

        return NonfungiblePositionManager.createCallParameters(mintInfo.pool);
    }, [mintInfo?.pool]);

    const { config: createPoolConfig } = usePrepareAlgebraPositionManagerMulticall({
        args: Array.isArray(calldata) ? [calldata as Address[]] : [[calldata] as Address[]],
        value: BigInt(value || 0),
        enabled: Boolean(calldata),
    });

    const {
        data: createPoolData,
        write: createPool,
        isLoading: isConfirmLoading,
    } = useContractWrite(createPoolConfig);

    const { isLoading: isTransactionLoading } = useTransactionAwait(
        createPoolData?.hash,
        {
            title: "Create Pool",
            tokenA: currencyA?.wrapped.address as Address,
            tokenB: currencyB?.wrapped.address as Address,
            type: TransactionType.POOL,
        },
        "/pools",
    );

    useEffect(() => {
        selectCurrency(SwapField.INPUT, undefined);
        selectCurrency(SwapField.OUTPUT, undefined);
        typeStartPriceInput("");

        return () => {
            selectCurrency(SwapField.INPUT, ADDRESS_ZERO);
            selectCurrency(SwapField.OUTPUT, STABLECOINS.USDT.address as Account);
            typeStartPriceInput("");
        };
    }, []);

    const isLoading = useMemo(
        () => isConfirmLoading || isTransactionLoading,
        [isConfirmLoading, isTransactionLoading],
    );

    const status = useMemo(() => {
        const temp: HandleStatus = { content: "Connect Wallet", disabled: false };

        if (!account) {
            temp.content = "Connect Wallet";
            temp.action = () => open();
        } else if (isWrongChain) {
            temp.content = `Switch to ${DEFAULT_CHAIN_NAME}`;
            temp.action = () => open({ view: "Networks" });
        } else if (isLoading) {
            temp.content = <Loader />;
            temp.disabled = true;
        } else if (isSameToken) {
            temp.content = "Select another pair";
            temp.disabled = true;
        } else if (isPoolExists) {
            temp.content = (
                <div className="flex items-center gap-[4px]">
                    Add Liquidity <Image src="/link-white.svg" width={18} height={18} />
                </div>
            );
            temp.action = () => navigate("/pool/" + poolAddress);
        } else if (!areCurrenciesSelected || !startPriceTypedValue) {
            temp.content = "Input Amount";
            temp.disabled = true;
        } else {
            temp.content = "Create Pool";
            temp.action = () => createPool?.();
        }

        return temp;
    }, [
        isLoading,
        isSameToken,
        areCurrenciesSelected,
        isPoolExists,
        startPriceTypedValue,
        createPool,
        account,
        open,
        isWrongChain,
        poolAddress,
        navigate,
    ]);

    return (
        <_CreatePoolForm>
            <div className="p-[32px_24px_40px] m:p-[24px_20px_36px]">
                <_Title>You Create</_Title>

                <SelectPair
                    className="mt-[12px]"
                    mintInfo={mintInfo}
                    currencyA={currencyA}
                    currencyB={currencyB}
                />

                <FloatingButton
                    className="mt-[36px] m:mt-[28px]"
                    disabled={status.disabled}
                    onClick={() => status.action?.()}
                >
                    {status.content}
                </FloatingButton>
            </div>

            {isPoolExists && (
                <WarningBox
                    className="mt-[-16px] text-left"
                    description="This trading pair exists already. You can add liquidity to this exact pool."
                />
            )}

            {!isSameToken && !isPoolExists && (
                <Summary currencyA={currencyA} currencyB={currencyB} />
            )}
        </_CreatePoolForm>
    );
};

export default CreatePoolForm;



================================================
File: src/components/create-pool/SelectPair/index.tsx
================================================
import SwitchBar from "@/components/swap/SwitchBar";
import TokenCard from "@/components/swap/TokenCard";
import { cn } from "@/lib/utils";
import { IDerivedMintInfo, useMintActionHandlers, useMintState } from "@/state/mintStore";
import { useSwapActionHandlers } from "@/state/swapStore";
import { SwapField } from "@/types/swap-field";
import { Currency } from "@glyph-exchange/integral-sdk";
import { memo, useCallback } from "react";

interface ISelectPair {
    mintInfo: IDerivedMintInfo;
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    className?: string;
}

const SelectPair = ({ mintInfo, currencyA, currencyB, className }: ISelectPair) => {
    const { onCurrencySelection } = useSwapActionHandlers();

    const { onStartPriceInput } = useMintActionHandlers(mintInfo.noLiquidity);

    const { startPriceTypedValue } = useMintState();

    const handleInputSelect = useCallback(
        (inputCurrency: Currency) => {
            onCurrencySelection(SwapField.INPUT, inputCurrency);
        },
        [onCurrencySelection],
    );

    const handleOutputSelect = useCallback(
        (outputCurrency: Currency) => {
            onCurrencySelection(SwapField.OUTPUT, outputCurrency);
        },
        [onCurrencySelection],
    );

    const handleTypeInput = useCallback(
        (value: string) => {
            onStartPriceInput(value);
        },
        [onStartPriceInput],
    );

    return (
        <div className={cn("relative flex flex-col items-center", className)}>
            <TokenCard
                disabled
                showBalance={false}
                value={"1"}
                currency={currencyA}
                otherCurrency={currencyB}
                handleTokenSelection={handleInputSelect}
            />

            <SwitchBar className="my-[24px] m:my-[12px]" />

            <TokenCard
                showBalance={false}
                value={startPriceTypedValue}
                handleTokenSelection={handleOutputSelect}
                currency={currencyB}
                otherCurrency={currencyA}
                handleValueChange={handleTypeInput}
            />
        </div>
    );
};

export default memo(SelectPair);



================================================
File: src/components/create-pool/Summary/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import InfoBase from "@/components/common/Info/InfoBase";
import InfoItem from "@/components/common/Info/InfoItem";
import { Skeleton } from "@/components/ui/skeleton";
import { useSingleTokenQuery } from "@/graphql/generated/graphql";
import { useMintState } from "@/state/mintStore";
import { Currency } from "@glyph-exchange/integral-sdk";
import { useEffect, useState } from "react";
import { Address } from "viem";

interface ISummary {
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
}

const Summary = ({ currencyA, currencyB }: ISummary) => {
    const [suggestedPrice, setSuggestedPrice] = useState(0);
    const { startPriceTypedValue } = useMintState();

    const token0 = currencyA?.wrapped.address.toLowerCase() as Address;
    const token1 = currencyB?.wrapped.address.toLowerCase() as Address;

    const { data: singleToken0 } = useSingleTokenQuery({
        variables: {
            tokenId: token0,
        },
        skip: !token0,
    });

    const { data: singleToken1 } = useSingleTokenQuery({
        variables: {
            tokenId: token1,
        },
        skip: !token1,
    });
    useEffect(() => {
        if (!singleToken0?.token || !singleToken1?.token) {
            setSuggestedPrice(0);
            return;
        }
        if (
            Number(singleToken0.token.derivedMatic) === 0 ||
            Number(singleToken1.token.derivedMatic) === 0
        ) {
            setSuggestedPrice(0);
            return;
        }

        const suggstdPrice = singleToken1.token.derivedMatic / singleToken0.token.derivedMatic;
        const filteredSuggstdPrice = Number(suggstdPrice.toFixed(4));

        setSuggestedPrice(filteredSuggstdPrice);
    }, [singleToken0, singleToken1]);

    return (
        <InfoBase>
            <InfoItem
                className="!items-start"
                label="RATE"
                value={
                    <>
                        {currencyA && currencyB && Number(startPriceTypedValue) ? (
                            <>
                                <div className="truncate text-right">{`1 ${currencyA.symbol} = ${startPriceTypedValue || 0} ${currencyB?.symbol}`}</div>
                                <div className="mt-[8px] truncate text-right">{`1 ${currencyB.symbol} = ${Number((1 / Number(startPriceTypedValue)).toFixed(4))} ${currencyA?.symbol}`}</div>
                            </>
                        ) : (
                            <>
                                <div>-</div>
                                <div className="mt-[8px]">-</div>
                            </>
                        )}
                    </>
                }
            />

            {suggestedPrice > 0 && (
                <InfoItem
                    label="Suggested price"
                    value={`1 ${currencyA?.symbol} = ${suggestedPrice} ${currencyB?.symbol}`}
                />
            )}
        </InfoBase>
    );
};

export default Summary;



================================================
File: src/components/create-position/AddLiquidityButton/index.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import { ALGEBRA_POSITION_MANAGER, GAMMA_UNIPROXY } from "@/constants/addresses";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import {
    useGammaUniProxyDeposit,
    usePrepareAlgebraPositionManagerMulticall,
    usePrepareGammaUniProxyDeposit,
} from "@/generated";
import { useApprove } from "@/hooks/common/useApprove";
import { useTransactionAwait } from "@/hooks/common/useTransactionAwait";
import { IDerivedMintInfo } from "@/state/mintStore";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { useUserState } from "@/state/userStore";
import { ApprovalState } from "@/types/approve-state";
import {
    Percent,
    Currency,
    NonfungiblePositionManager,
    Field,
    ZERO,
} from "@glyph-exchange/integral-sdk";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import JSBI from "jsbi";
import { useCallback, useEffect, useMemo, useState } from "react";
import { Address, useAccount, useContractWrite } from "wagmi";
import { waitForTransaction } from "@wagmi/core";
import { PositionManager } from "@/types/position-state";
import { useNativeWrap } from "@/hooks/common/useGamma";
import { WrapState } from "@/types/gamma-state";

interface AddLiquidityButtonProps {
    baseCurrency: Currency | undefined | null;
    quoteCurrency: Currency | undefined | null;
    mintInfo: IDerivedMintInfo;
    poolAddress: Address | undefined;
}

const ZERO_PERCENT = new Percent("0");
const DEFAULT_ADD_IN_RANGE_SLIPPAGE_TOLERANCE = new Percent(50, 10_000);

export const AddLiquidityButton = ({
    baseCurrency,
    quoteCurrency,
    mintInfo,
    poolAddress,
}: AddLiquidityButtonProps) => {
    const { address: account } = useAccount();

    const { open } = useWeb3Modal();

    const { selectedNetworkId } = useWeb3ModalState();

    const { txDeadline } = useUserState();

    const [startAdd, setStartAdd] = useState(false);

    const useNative = baseCurrency?.isNative
        ? baseCurrency
        : quoteCurrency?.isNative
          ? quoteCurrency
          : undefined;

    /* const nativeCurrency = mintInfo.parsedAmounts[Field.CURRENCY_A]?.currency.isNative
        ? mintInfo.parsedAmounts[Field.CURRENCY_A]
        : mintInfo.parsedAmounts[Field.CURRENCY_B]?.currency.isNative
          ? mintInfo.parsedAmounts[Field.CURRENCY_B]
          : undefined; */

    const { calldata: algebraCallData, value } = useMemo(() => {
        if (!account || !mintInfo.position || JSBI.EQ(mintInfo.position.liquidity, ZERO))
            return { calldata: undefined, value: undefined };

        return NonfungiblePositionManager.addCallParameters(mintInfo.position, {
            slippageTolerance: mintInfo.outOfRange
                ? ZERO_PERCENT
                : DEFAULT_ADD_IN_RANGE_SLIPPAGE_TOLERANCE,
            recipient: account,
            deadline: Date.now() + txDeadline,
            useNative,
            createPool: mintInfo.noLiquidity,
        });
    }, [mintInfo, account, txDeadline, useNative]);

    const spender = useMemo(
        () =>
            (mintInfo.positionManager === PositionManager.GAMMA
                ? poolAddress // NOT GAMMA_UNIPROXY
                : ALGEBRA_POSITION_MANAGER) as Address,
        [poolAddress, mintInfo.positionManager],
    );

    const { approvalState: approvalStateA, approvalCallback: approvalCallbackA } = useApprove(
        mintInfo.parsedAmounts[Field.CURRENCY_A],
        spender,
    );

    const { approvalState: approvalStateB, approvalCallback: approvalCallbackB } = useApprove(
        mintInfo.parsedAmounts[Field.CURRENCY_B],
        spender,
    );

    /* const { wrapState, wrapCallback } = useNativeWrap(
        nativeCurrency,
        mintInfo.positionManager === PositionManager.GAMMA,
    ); */

    const showApproveA =
        approvalStateA === ApprovalState.NOT_APPROVED || approvalStateA === ApprovalState.PENDING;

    const showApproveB =
        approvalStateB === ApprovalState.NOT_APPROVED || approvalStateB === ApprovalState.PENDING;

    // const showWrap = wrapState === WrapState.NOT_WRAPPED || wrapState === WrapState.PENDING;

    const isReady = useMemo(() => {
        const condition =
            (mintInfo.depositADisabled ? true : approvalStateA === ApprovalState.APPROVED) &&
            (mintInfo.depositBDisabled ? true : approvalStateB === ApprovalState.APPROVED) &&
            !mintInfo.errorMessage &&
            !mintInfo.invalidRange;

        return Boolean(
            /* mintInfo.positionManager === PositionManager.GAMMA
                ? wrapState === WrapState.WRAPPED && condition
                :  */ condition,
        );
    }, [mintInfo, approvalStateA, approvalStateB /* , wrapState */]);

    const { config: algebraConfig } = usePrepareAlgebraPositionManagerMulticall({
        args: algebraCallData && [algebraCallData as `0x${string}`[]],
        value: BigInt(value || 0),
        enabled:
            mintInfo.positionManager === PositionManager.ALGEBRA &&
            Boolean(algebraCallData && isReady),
    });

    const {
        data: algebraData,
        write: algebraAdd,
        isLoading: algebraConfirmLoading,
    } = useContractWrite(algebraConfig);

    const gammaCallData = useMemo(() => {
        const amountA = mintInfo.parsedAmounts[Field.CURRENCY_A]?.numerator.toString();
        const amountB = mintInfo.parsedAmounts[Field.CURRENCY_B]?.numerator.toString();

        if (amountA && amountB && account && poolAddress) {
            return [
                BigInt(amountA),
                BigInt(amountB),
                account,
                poolAddress,
                [0n, 0n, 0n, 0n],
            ] as const;
        }
        return undefined;
    }, [mintInfo, account, poolAddress]);

    const { config: gammaConfig } = usePrepareGammaUniProxyDeposit({
        args: gammaCallData,
        enabled:
            mintInfo.positionManager === PositionManager.GAMMA && Boolean(gammaCallData && isReady),
    });

    const {
        data: gammaData,
        write: gammaAdd,
        isLoading: gammaConfirmLoading,
    } = useGammaUniProxyDeposit(gammaConfig);

    const addLiquidityData = useMemo(
        () => (mintInfo.positionManager === PositionManager.GAMMA ? gammaData : algebraData),
        [mintInfo.positionManager, gammaData, algebraData],
    );

    const [addLiquidity, callable] = useMemo(
        () =>
            mintInfo.positionManager === PositionManager.GAMMA
                ? [gammaAdd, !!gammaConfig.request]
                : [algebraAdd, true], // !!algebraConfig.request realtime update
        [
            mintInfo.positionManager,
            gammaAdd,
            gammaConfig.request,
            algebraAdd,
            // algebraConfig.request,
        ],
    );

    const isConfirmLoading = useMemo(
        () =>
            mintInfo.positionManager === PositionManager.GAMMA
                ? gammaConfirmLoading
                : algebraConfirmLoading,
        [mintInfo.positionManager, gammaConfirmLoading, algebraConfirmLoading],
    );

    const { isLoading: isAddingLiquidityLoading } = useTransactionAwait(
        addLiquidityData?.hash,
        {
            title: "Add Liquidity",
            tokenA: baseCurrency?.wrapped.address as Address,
            tokenB: quoteCurrency?.wrapped.address as Address,
            type: TransactionType.POOL,
        },
        `/pool/${poolAddress}`,
    );

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    /* const handleWrap = useCallback(async () => {
        if (showWrap) {
            const tx = await wrapCallback?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        setStartAdd(true);
    }, [wrapCallback, showWrap]); */

    const handleApproval = useCallback(async () => {
        if (showApproveA) {
            const tx = await approvalCallbackA?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        if (showApproveB) {
            const tx = await approvalCallbackB?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        // if (showWrap) {
        //     handleWrap();
        // } else {
        setStartAdd(true);
        // }
    }, [
        approvalCallbackA,
        approvalCallbackB,
        showApproveA,
        showApproveB /*,  showWrap, handleWrap */,
    ]);

    useEffect(() => {
        try {
            if (startAdd && addLiquidity) {
                setStartAdd(false);
                addLiquidity();
            }
        } catch (error) {
            new Error(`Add Failed ${error}`);
        }
    }, [startAdd, addLiquidity]);

    if (!account) return <FloatingButton onClick={() => open()}>Connect Wallet</FloatingButton>;

    if (isWrongChain)
        return (
            <FloatingButton
                onClick={() => open({ view: "Networks" })}
            >{`Connect to ${DEFAULT_CHAIN_NAME}`}</FloatingButton>
        );

    if (mintInfo.errorMessage)
        return <FloatingButton disabled>{mintInfo.errorMessage}</FloatingButton>;

    if (showApproveA || showApproveB)
        return (
            <div className="flex w-full gap-[16px]">
                <FloatingButton
                    disabled={
                        approvalStateA === ApprovalState.PENDING ||
                        approvalStateB === ApprovalState.PENDING
                    }
                    onClick={() => handleApproval()}
                >
                    {approvalStateA === ApprovalState.PENDING ||
                    approvalStateB === ApprovalState.PENDING ? (
                        <Loader />
                    ) : (
                        <>
                            Approve {showApproveA && mintInfo.currencies.CURRENCY_A?.symbol}{" "}
                            {showApproveA && showApproveB && " & "}{" "}
                            {showApproveB && mintInfo.currencies.CURRENCY_B?.symbol}
                        </>
                    )}
                </FloatingButton>

                {/* {showApproveA && (
                    <FloatingButton
                        disabled={approvalStateA === ApprovalState.PENDING}
                        onClick={() => approvalCallbackA && approvalCallbackA()}
                    >
                        {approvalStateA === ApprovalState.PENDING ? (
                            <Loader />
                        ) : (
                            `Approve ${mintInfo.currencies.CURRENCY_A?.symbol}`
                        )}
                    </FloatingButton>
                )}
                {showApproveB && (
                    <FloatingButton
                        disabled={approvalStateB === ApprovalState.PENDING}
                        onClick={() => approvalCallbackB && approvalCallbackB()}
                    >
                        {approvalStateB === ApprovalState.PENDING ? (
                            <Loader />
                        ) : (
                            `Approve ${mintInfo.currencies.CURRENCY_B?.symbol}`
                        )}
                    </FloatingButton>
                )} */}
            </div>
        );

    /* if (showWrap) {
        return (
            <FloatingButton disabled={wrapState === WrapState.PENDING} onClick={() => handleWrap()}>
                {wrapState === WrapState.PENDING ? <Loader /> : "Wrap CORE"}
            </FloatingButton>
        );
    } */

    return (
        <FloatingButton
            disabled={!isReady || isAddingLiquidityLoading || isConfirmLoading || !callable}
            onClick={() => addLiquidity && addLiquidity()}
        >
            {isAddingLiquidityLoading || isConfirmLoading ? <Loader /> : "Create Position"}
        </FloatingButton>
    );
};

export default AddLiquidityButton;



================================================
File: src/components/create-position/AmountsSection/index.tsx
================================================
import TokenRatio from "../TokenRatio";
import { Currency } from "@glyph-exchange/integral-sdk";
import { IDerivedMintInfo, useMintState } from "@/state/mintStore";
import { usePositionAPR } from "@/hooks/positions/usePositionAPR";
import { getPoolAPR } from "@/utils/pool/getPoolAPR";
import AddLiquidityButton from "../AddLiquidityButton";
import { Address } from "viem";
import { memo, useEffect, useMemo, useState } from "react";
import EnterAmounts from "../EnterAmounts";
import IncreaseLiquidityButton from "@/components/position/IncreaseLiquidityButton";
import { ManageLiquidity } from "@/types/manage-liquidity";
import { useParams } from "react-router-dom";
import tw, { styled } from "twin.macro";
import InfoBase from "@/components/common/Info/InfoBase";
import InfoItem from "@/components/common/Info/InfoItem";
import { PositionManager } from "@/types/position-state";
import Image from "@/components/common/Image";

const AlgebraApr: FCProps<{ poolAddress?: Address; mintInfo: IDerivedMintInfo }> = memo(
    ({ poolAddress, mintInfo }) => {
        const [poolAPR, setPoolAPR] = useState<number>();
        const apr = usePositionAPR(poolAddress, mintInfo.position);

        useEffect(() => {
            if (!poolAddress) return;
            getPoolAPR(poolAddress).then(setPoolAPR);
        }, [poolAddress]);

        return (
            <>
                <InfoItem
                    label="ESTIMATED POSITION APR"
                    value={
                        <span className="text-[#F7931A]">{apr ? `${apr.toFixed(2)}%` : "-"}</span>
                    }
                />

                <InfoItem
                    label="POOL APR"
                    value={
                        <span className="text-[#9747FF]">
                            {poolAPR !== undefined ? `${poolAPR}%` : "-"}
                        </span>
                    }
                />
            </>
        );
    },
);

const GammaApr: FCProps = memo(() => {
    const { hypervisor } = useMintState();

    return (
        <>
            <InfoItem
                label="POOL APR"
                value={
                    <span className="text-[#9747FF]">
                        {hypervisor.returns.allTime.feeApr
                            ? `${hypervisor.returns.allTime.feeApr * 100}%`
                            : "-"}
                    </span>
                }
            />
        </>
    );
});

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;

    ${() => tw`text-left m:text-[12px]`}
`;

interface AmountsSectionProps {
    tokenId?: number;
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    mintInfo: IDerivedMintInfo;
    manageLiquidity: ManageLiquidity;
    handleCloseModal?: () => void;
    className?: string;
}
type NewPositionPageParams = Record<"pool", Address>;
const AmountsSection = ({
    tokenId,
    currencyA,
    currencyB,
    mintInfo,
    manageLiquidity,
    handleCloseModal,
    className,
}: AmountsSectionProps) => {
    const { pool: poolAddress } = useParams<NewPositionPageParams>();

    const AprInfo = useMemo(() => {
        if (mintInfo.positionManager === PositionManager.ALGEBRA)
            return <AlgebraApr poolAddress={poolAddress} mintInfo={mintInfo} />;
        else if (mintInfo.positionManager === PositionManager.GAMMA) return <GammaApr />;
    }, [poolAddress, mintInfo]);

    const showBtn = useMemo(
        () =>
            /*  mintInfo.positionManager === PositionManager.GAMMA && */
            mintInfo.currencies.CURRENCY_A?.symbol === "WCORE" ||
            mintInfo.currencies.CURRENCY_B?.symbol === "WCORE",
        [mintInfo],
    );

    return (
        <div className={className}>
            <div className="p-[32px_24px_36px] m:p-[24px_20px_28px]">
                {showBtn && (
                    <a
                        className="ml-auto flex w-max items-center gap-[4px] p-[4px_8px] font-[Geneva] text-[12px] text-black b1"
                        href="/swap"
                        target="_blank"
                    >
                        Get WCORE <Image src="/link.svg" width={16} height={16} />
                    </a>
                )}

                <_Title className="mt-[10px]">You Add Liquidity</_Title>

                <EnterAmounts
                    className="mt-[12px]"
                    currencyA={currencyA}
                    currencyB={currencyB}
                    mintInfo={mintInfo}
                />

                <TokenRatio
                    className="mt-[28px] m:mt-[16px]"
                    mintInfo={mintInfo}
                    gammaAmounts={mintInfo.parsedAmounts}
                />

                {manageLiquidity === ManageLiquidity.INCREASE && (
                    <div className="mt-[28px] m:mt-[24px]">
                        <IncreaseLiquidityButton
                            tokenId={tokenId}
                            baseCurrency={currencyA}
                            quoteCurrency={currencyB}
                            mintInfo={mintInfo}
                            handleCloseModal={handleCloseModal}
                        />
                    </div>
                )}
                {manageLiquidity === ManageLiquidity.ADD && (
                    <div className="mt-[28px] m:mt-[24px]">
                        <AddLiquidityButton
                            baseCurrency={currencyA}
                            quoteCurrency={currencyB}
                            mintInfo={mintInfo}
                            poolAddress={poolAddress}
                        />
                    </div>
                )}
            </div>

            <InfoBase>{AprInfo}</InfoBase>
        </div>
    );
};

export default AmountsSection;



================================================
File: src/components/create-position/EnterAmounts/index.tsx
================================================
import { useNeedAllowance } from "@/hooks/common/useNeedAllowance";
import { IDerivedMintInfo, useMintState, useMintActionHandlers } from "@/state/mintStore";
import { Currency, Field } from "@glyph-exchange/integral-sdk";
import { useEffect, useMemo } from "react";
import EnterAmountCard from "../EnterAmountsCard";
import { ALGEBRA_POSITION_MANAGER } from "@/constants/addresses";
import { cn } from "@/lib/utils";
import SeparateBar from "@/components/common/SeparateBar";
import Image from "@/components/common/Image";
import FloatingButton from "@/components/common/FloatingButton";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { styled } from "twin.macro";
import tw from "twin.macro";

interface EnterAmountsProps {
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    mintInfo: IDerivedMintInfo;
    className?: string;
}

const _DisabledMask = styled.div`
    color: #fff;
    font-family: FraktionMono-Bold;
    font-size: 12px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    border-radius: 4px;

    ${() =>
        tw`absolute left-0 top-0 flex h-full w-full items-center justify-center break-words bg-black/60 p-[16px] b1 m:p-[10px] m:text-[10px]`}
`;

const EnterAmounts = ({ currencyA, currencyB, mintInfo, className }: EnterAmountsProps) => {
    const { independentField, typedValue } = useMintState();

    const { onFieldAInput, onFieldBInput } = useMintActionHandlers(mintInfo.noLiquidity);

    const isMobile = useMediaQuery("mobile");

    const formattedAmounts = {
        [independentField]: typedValue,
        [mintInfo.dependentField]:
            mintInfo.parsedAmounts[mintInfo.dependentField]?.toSignificant(6) ?? "",
    };

    const currencyAError = useMemo(() => {
        if (
            (mintInfo.errorCode !== 4 && mintInfo.errorCode !== 5) ||
            !mintInfo.errorMessage ||
            !currencyA
        )
            return;

        const erroredToken = mintInfo.errorMessage.split(" ")[1];
        const erroredSymbol = currencyA.isNative ? currencyA.symbol : currencyA.wrapped.symbol;

        if (erroredSymbol === erroredToken) return mintInfo.errorMessage;

        return;
    }, [mintInfo, currencyA]);

    const currencyBError = useMemo(() => {
        if (
            (mintInfo.errorCode !== 5 && mintInfo.errorCode !== 4) ||
            !mintInfo.errorMessage ||
            !currencyB
        )
            return;

        const erroredToken = mintInfo.errorMessage.split(" ")[1];

        if (currencyB.wrapped.symbol === erroredToken) return mintInfo.errorMessage;

        return;
    }, [mintInfo, currencyB]);

    const allowanceA = useNeedAllowance(
        currencyA,
        mintInfo.parsedAmounts[Field.CURRENCY_B],
        ALGEBRA_POSITION_MANAGER,
    );

    const allowanceB = useNeedAllowance(
        currencyB,
        mintInfo.parsedAmounts[Field.CURRENCY_B],
        ALGEBRA_POSITION_MANAGER,
    );

    useEffect(() => {
        return () => {
            onFieldAInput("");
            onFieldBInput("");
        };
    }, []);

    return (
        <div className={cn("flex flex-col", className)}>
            <div className="relative flex w-full">
                <EnterAmountCard
                    currency={currencyA}
                    value={formattedAmounts[Field.CURRENCY_A]}
                    valueForApprove={mintInfo.parsedAmounts[Field.CURRENCY_A]}
                    handleChange={(value) => onFieldAInput(value)}
                    needApprove={allowanceA}
                    error={currencyAError}
                />
                {mintInfo.depositADisabled && (
                    <_DisabledMask>For Selected Range this deposit is disabled</_DisabledMask>
                )}
            </div>

            <SeparateBar
                className="my-[16px] m:my-[12px]"
                middleElement={
                    <FloatingButton
                        type="small"
                        width={isMobile ? "16px" : "24px"}
                        height={isMobile ? "16px" : "24px"}
                        innerStyle={{ padding: isMobile ? "2px" : "3px" }}
                    >
                        <Image src="/add.svg" width={18} height={18} />
                    </FloatingButton>
                }
            />

            <div className="relative flex w-full">
                <EnterAmountCard
                    currency={currencyB}
                    value={formattedAmounts[Field.CURRENCY_B]}
                    needApprove={allowanceB}
                    valueForApprove={mintInfo.parsedAmounts[Field.CURRENCY_B]}
                    handleChange={(value) => onFieldBInput(value)}
                    error={currencyBError}
                />
                {mintInfo.depositBDisabled && (
                    <_DisabledMask>For Selected Range this deposit is disabled</_DisabledMask>
                )}
            </div>
        </div>
    );
};

export default EnterAmounts;



================================================
File: src/components/create-position/EnterAmountsCard/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import { Input } from "@/components/ui/input";
import { formatCurrency } from "@/utils/common/formatCurrency";
import { Currency, CurrencyAmount } from "@glyph-exchange/integral-sdk";
import { useCallback, useMemo, useState } from "react";
import tw, { styled } from "twin.macro";
import { Address, useAccount, useBalance } from "wagmi";

interface EnterAmountsCardProps {
    currency: Currency | undefined;
    value: string;
    needApprove: boolean;
    error: string | undefined;
    valueForApprove: CurrencyAmount<Currency> | undefined;
    handleChange: (value: string) => void;
}

const _EnterAmountCard = styled.div<{ $focus: boolean }>`
    padding: 15px 16px;
    background-color: ${({ $focus }) => ($focus ? "#F5F5F5" : "#E8E8E8")};
    ${() => tw`w-full rounded-[4px] duration-200 b1 m:p-[14px_12px]`};
`;

const _CurrencyArea = styled.div`
    border: 1px solid #000;
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    padding: 8px 12px;

    ${() =>
        tw`flex w-max max-w-[60%] items-center gap-[8px] rounded-[4px] !bg-white m:gap-[6px] m:p-[6px_8px] m:text-[10px]`}
`;
const _Input = styled(Input)`
    color: #000;
    text-align: right;
    font-family: FraktionMono-Bold;
    font-size: 18px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() =>
        tw`h-full max-w-[60%] rounded-none border-none p-0 disabled:cursor-not-allowed m:text-[16px]`}
`;

const _Row = styled.div`
    ${() => tw`flex min-w-0 items-center justify-between gap-[8px]`}
`;

const _MaxBtn = styled.button`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw`uppercase m:text-[10px]`}
`;

const _Value = styled.div`
    color: #999;
    text-align: right;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    letter-spacing: -0.24px;

    ${() => tw`flex min-w-0 items-center m:text-[10px]`}
`;

const EnterAmountCard = ({ currency, value, handleChange }: EnterAmountsCardProps) => {
    const { address: account } = useAccount();

    const [focus, setFocus] = useState(false);

    const { data: balance, isLoading } = useBalance({
        address: account,
        token: currency?.isNative ? undefined : (currency?.wrapped.address as Address),
        watch: true,
    });

    const balanceString = useMemo(() => {
        if (isLoading || !balance) return "Loading...";

        return formatCurrency.format(Number(balance.formatted));
    }, [balance, isLoading]);

    const handleInput = useCallback((value: string) => {
        if (value === ".") value = "0.";
        handleChange(value);
    }, []);

    const showMaxButton = useMemo(() => value !== balance?.formatted, [value, balance]);

    function setMax() {
        handleChange(balance?.formatted || "0");
    }

    return (
        <_EnterAmountCard $focus={focus}>
            <_Row>
                <_CurrencyArea>
                    <CurrencyLogo currency={currency} size={16} />
                    <span className="truncate">
                        {currency ? currency.symbol : "Select a token"}
                    </span>
                </_CurrencyArea>
                <_Input
                    value={value}
                    onFocus={() => setFocus(true)}
                    onBlur={() => setFocus(false)}
                    id={`amount-${currency?.symbol}`}
                    onUserInput={(v) => handleInput(v)}
                    placeholder={"0"}
                    maxDecimals={currency?.decimals}
                />
            </_Row>

            <_Row className="mt-[12px]">
                {currency && account && (
                    <_Row className="max-w-[60%] !gap-[4px]">
                        <_Value>
                            <span className="truncate">Balance: {balanceString}</span>
                        </_Value>
                        {showMaxButton && <_MaxBtn onClick={setMax}>Max</_MaxBtn>}
                    </_Row>
                )}

                {/* <div className="text-sm">{fiatValue && formatUSD.format(fiatValue)}</div>  */}
            </_Row>
        </_EnterAmountCard>
    );

    // return (
    //   <div
    //       className="flex flex-col justify-between w-full relative">
    //     <div
    //     className="absolute text-right">
    //       {/* // {`Balance: ${displayNumber(balance)}`} */}
    //       {`Balance: ${balance.toString()}`}
    //     </div>

    //     <div
    //     className="flex items-center justify-between">
    //       <div className="flex items-center p-2">
    //         {/* <EquilibreAvatar
    //           src={asset?.logoURI || ''}
    //           size={'md'}
    //           ml={1}
    //           mr={4}
    //         /> */}
    //         <Input value={value} onChange={v => handleChange(v.target.value)} />
    //         {/* <InputGroup flexDirection={'column'}>
    //           <NumberInput
    //             step={0.1}
    //             colorScheme="white"
    //             variant={'unstyled'}
    //             value={value}
    //             onChange={handleChange}>
    //             <NumberInputField
    //               fontSize={'2xl'}
    //               placeholder="0"
    //               textAlign={'left'}
    //             />
    //           </NumberInput>
    //         </InputGroup> */}
    //       </div>
    //       <Button
    //         onClick={setMax}>
    //         MAX
    //       </Button>
    //     </div>
    //     <div className="mt-4">
    //       {error ? (
    //         <div className="flex flex-col absolute">
    //           {error}
    //         </div>
    //       ) : needApprove ? (
    //         <Button
    //           disabled={!approve || isApprovalLoading}
    //           onClick={() => approve()}>
    //           {isApprovalLoading ? 'Loading...' : `Approve ${currency?.symbol}`}
    //         </Button>
    //       ) : valueForApprove ? (
    //         <div className="absolute">
    //           {/* <CheckIcon /> */}
    //           Approved
    //         </div>
    //       ) : null}
    //     </div>
    //   </div>
    // );
};

export default EnterAmountCard;



================================================
File: src/components/create-position/LiquidityChart/chart.tsx
================================================
// import { formatNumber } from "app/functions"
import { BarChart, ResponsiveContainer, XAxis, Bar, Cell, Tooltip } from "recharts";
import { useState } from "react";
import { Currency } from "@glyph-exchange/integral-sdk";
import tw, { styled } from "twin.macro";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

interface CustomBarProps {
    x: number;
    y: number;
    width: number;
    height: number;
    fill: string;
    percent: number | undefined;
    isCurrent: boolean;
}

interface CustomTooltipProps {
    props: any;
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    currentPrice: number | undefined;
}

interface ChartProps {
    formattedData: any;
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    leftPrice: string | undefined;
    rightPrice: string | undefined;
    currentPrice: number | undefined;
    isSorted: boolean | undefined;
    zoom: number;
    className?: string;
    height?: number;
}

const CustomBar = ({ x, y, width, height, fill, percent, isCurrent }: CustomBarProps) => {
    const isMobile = useMediaQuery("mobile");
    return (
        <g>
            <defs>
                <linearGradient id="colorUv" x1="0" y1="0" x2="0" y2="100%">
                    <stop offset="0" stopColor="#11A3FB" />
                    <stop offset="1" stopColor="#11A3FB" />
                </linearGradient>
            </defs>
            {percent && (
                <text
                    x={isMobile ? x : x + 10}
                    y={isMobile ? y - 8 : y - 10}
                    fill="black"
                    fontSize={"12px"}
                    fontWeight={600}
                    textAnchor="middle"
                    fontFamily="FraktionMono-Bold"
                    className="uppercase"
                >{`${percent.toFixed(0)}%`}</text>
            )}
            {isCurrent && (
                <text
                    x={isMobile ? x : x + 10}
                    y={isMobile ? y - 8 : y - 10}
                    fill="black"
                    fontSize={"10px"}
                    fontWeight={600}
                    fontFamily="FraktionMono-Bold"
                    textAnchor="middle"
                    className="uppercase"
                >
                    Current Price
                </text>
            )}
            <rect x={x} y={y} fill={fill} width={Math.max(width, 2)} height={height} rx="0" />
        </g>
    );
};

const _CustomTooltipBox = styled.div`
    padding: 16px 8px;
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(3px);

    font-weight: 400;
    line-height: 1;
    ${() => tw`flex flex-col gap-[12px] rounded-[4px] font-[Geneva] text-[12px] text-black b1`}
`;

const CustomTooltip = ({ props, currencyA, currencyB }: CustomTooltipProps) => {
    const price0 = props?.payload?.[0]?.payload.price0;
    const price1 = props?.payload?.[0]?.payload.price1;
    // const tvlToken0 = props?.payload?.[0]?.payload.tvlToken0
    // const tvlToken1 = props?.payload?.[0]?.payload.tvlToken1

    return (
        <_CustomTooltipBox>
            <div className="flex justify-between gap-4">
                <div>{`${currencyA?.symbol} Price:`}</div>
                <div>{`${
                    price0
                        ? `${Number(price0).toLocaleString(undefined, {
                              maximumSignificantDigits: 3,
                          })} ${currencyB?.symbol}`
                        : ""
                }`}</div>
            </div>
            <div className="flex justify-between gap-4">
                <div>{`${currencyB?.symbol} Price:`}</div>
                <div>{`${
                    price1
                        ? `${Number(price1).toLocaleString(undefined, {
                              maximumSignificantDigits: 3,
                          })} ${currencyA?.symbol}`
                        : ""
                }`}</div>
            </div>
            {/* {currentPrice && price0 && currentPrice > price1 ? <div className="flex gap-4 justify-between">
            <div>{`${currencyA?.symbol} Locked: `}</div>
            <div>{`${tvlToken0 ? formatNumber(tvlToken0) : ''} ${currencyA?.symbol}`}</div>
        </div> : <div className="flex gap-4 justify-between">
            <div>{`${currencyB?.symbol} Locked: `}</div>
            <div>{`${tvlToken1 ? formatNumber(tvlToken1) : ''} ${currencyB?.symbol}`}</div>
        </div>} */}
        </_CustomTooltipBox>
    );
};

export function Chart({
    formattedData,
    currencyA,
    currencyB,
    leftPrice,
    rightPrice,
    currentPrice,
    isSorted,
    zoom,
    className,
    height,
}: ChartProps) {
    const isMobile = useMediaQuery("mobile");
    const [focusBar, setFocusBar] = useState<number | undefined>(undefined);

    return (
        <ResponsiveContainer width={"100%"} height={height ? height : 230} className={className}>
            <BarChart
                data={formattedData}
                margin={{
                    top: isMobile ? 20 : 30,
                    right: 0,
                    left: 0,
                    bottom: 0,
                }}
                barCategoryGap={zoom > 30 ? 3 : 1.5}
                onMouseMove={(state) => {
                    if (state.isTooltipActive) {
                        setFocusBar(state.activeTooltipIndex);
                    } else {
                        setFocusBar(undefined);
                    }
                }}
            >
                <Tooltip
                    cursor={false}
                    content={(props) => (
                        <CustomTooltip
                            props={props}
                            currencyA={currencyA}
                            currencyB={currencyB}
                            currentPrice={currentPrice}
                        />
                    )}
                />

                <XAxis
                    reversed={true}
                    tick={(props) => {
                        if (!props?.payload || props.index % 2 === 0) return <text></text>;

                        return (
                            <text
                                x={props.x}
                                y={isMobile ? props.y + 8 : props.y + 10}
                                fill="black"
                                textAnchor="middle"
                                fontSize={isMobile ? "10px" : "12px"}
                                width={isMobile ? "10px" : "12px"}
                                fontFamily="FraktionMono-Bold"
                            >
                                {props.payload.value.toFixed(3)}
                            </text>
                        );
                    }}
                    dataKey={isSorted ? "price0" : "price1"}
                    interval={zoom == 10 ? 10 : 6}
                    offset={0}
                    tickLine={false}
                    tickFormatter={(v) => v.toFixed(3)}
                    stroke="black"
                />

                <Bar
                    dataKey="activeLiquidity"
                    fill="#11A3FB"
                    isAnimationActive={false}
                    shape={(props) => {
                        const price = props[isSorted ? "price0" : "price1"];
                        let percent = 0;
                        if (
                            price === +Number(leftPrice).toFixed(8) ||
                            price === +Number(rightPrice).toFixed(8)
                        ) {
                            const currentPriceIdx = formattedData.findIndex(
                                (v: any) => v.isCurrent,
                            );
                            const currentPriceRealIndex = formattedData[currentPriceIdx].index;
                            percent =
                                (props.payload.index < currentPriceRealIndex ? -1 : 1) *
                                ((Math.max(props.payload.index, currentPriceRealIndex) -
                                    Math.min(props.payload.index, currentPriceRealIndex)) /
                                    currentPriceRealIndex) *
                                100;
                        }

                        return (
                            <CustomBar
                                height={props.height}
                                width={props.width}
                                x={props.x}
                                y={isMobile ? props.y - 6 : props.y - 8}
                                fill={props.fill}
                                percent={percent}
                                isCurrent={props.isCurrent}
                            />
                        );
                    }}
                >
                    {formattedData?.map((entry: any, index: number) => {
                        let fill = "#D9D9D9";

                        const value = isSorted ? entry.price0 : entry.price1;

                        if (focusBar === index) {
                            fill = "#000";
                        } else if (entry.isCurrent) {
                            fill = "#FF6B00";
                        } else if (leftPrice && rightPrice) {
                            if (
                                Number(value) >= Number(leftPrice) &&
                                Number(value) <= Number(rightPrice)
                            ) {
                                fill = "url(#colorUv)";
                            }
                        }

                        return <Cell key={`cell-${index}`} fill={fill} />;
                    })}
                </Bar>
            </BarChart>
        </ResponsiveContainer>
    );
}



================================================
File: src/components/create-position/LiquidityChart/index.tsx
================================================
import { useInfoTickData } from "@/hooks/pools/usePoolTickData";
import { useMintState } from "@/state/mintStore";
import { Presets } from "@/types/presets";
import {
    CurrencyAmount,
    INITIAL_POOL_FEE,
    Pool,
    Token,
    TickMath,
    Price,
    Currency,
} from "@glyph-exchange/integral-sdk";
import { useEffect, useMemo, useState } from "react";
import { Chart } from "./chart";
import { Skeleton } from "@/components/ui/skeleton";
import { MAX_UINT128 } from "@/constants/max-uint128";

interface LiquidityChartProps {
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    currentPrice: number | undefined;
    priceLower: Price<Token, Token> | undefined;
    priceUpper: Price<Token, Token> | undefined;
    className?: string;
    height?: number;
}

// const ZOOM_STEP = 5

const LiquidityChart = ({
    currencyA,
    currencyB,
    currentPrice,
    priceLower,
    priceUpper,
    className,
    height,
}: LiquidityChartProps) => {
    const { preset } = useMintState();

    const [processedData, setProcessedData] = useState<any>(null);

    const [zoom, setZoom] = useState(50);

    const {
        fetchTicksSurroundingPrice: { ticksResult, fetchTicksSurroundingPrice },
    } = useInfoTickData();

    useEffect(() => {
        if (!currencyA || !currencyB) return;
        fetchTicksSurroundingPrice(currencyA, currencyB);
    }, [currencyA, currencyB]);

    useEffect(() => {
        if (!ticksResult || !ticksResult.ticksProcessed) return;

        async function processTicks() {
            if (!ticksResult) return;

            const _data = await Promise.all(
                ticksResult.ticksProcessed.map(async (t, i) => {
                    const active = t.tickIdx === ticksResult.activeTickIdx;
                    const sqrtPriceX96 = TickMath.getSqrtRatioAtTick(t.tickIdx);
                    const mockTicks = [
                        {
                            index: Number(t.tickIdx) - Number(ticksResult.tickSpacing),
                            liquidityGross: t.liquidityGross.toString(),
                            liquidityNet: (t.liquidityNet * -1n).toString(),
                        },
                        {
                            index: t.tickIdx,
                            liquidityGross: t.liquidityGross.toString(),
                            liquidityNet: t.liquidityNet.toString(),
                        },
                    ];
                    const pool =
                        currencyA && currencyB
                            ? new Pool(
                                  currencyA.wrapped,
                                  currencyB.wrapped,
                                  INITIAL_POOL_FEE,
                                  sqrtPriceX96,
                                  t.liquidityActive.toString(),
                                  t.tickIdx,
                                  ticksResult.tickSpacing,
                                  mockTicks,
                              )
                            : undefined;

                    const nextSqrtX96 = ticksResult.ticksProcessed[i - 1]
                        ? TickMath.getSqrtRatioAtTick(ticksResult.ticksProcessed[i - 1].tickIdx)
                        : undefined;

                    const maxAmountToken0 = currencyA
                        ? CurrencyAmount.fromRawAmount(currencyA.wrapped, MAX_UINT128.toString())
                        : undefined;

                    const outputRes0 =
                        pool && maxAmountToken0
                            ? await pool.getOutputAmount(maxAmountToken0, nextSqrtX96)
                            : undefined;

                    const token1Amount = outputRes0?.[0] as CurrencyAmount<Token> | undefined;

                    const amount0 = token1Amount
                        ? parseFloat(token1Amount.toExact()) * parseFloat(t.price1)
                        : 0;
                    const amount1 = token1Amount ? parseFloat(token1Amount.toExact()) : 0;

                    return {
                        index: i,
                        isCurrent: active,
                        activeLiquidity: parseFloat(t.liquidityActive.toString()),
                        price0: parseFloat(t.price0),
                        price1: parseFloat(t.price1),
                        tvlToken0: amount0,
                        tvlToken1: amount1,
                    };
                }),
            );
            setProcessedData(_data);
        }

        processTicks();
    }, [ticksResult]);

    useEffect(() => {
        if (preset === null) return;
        switch (preset) {
            case Presets.FULL:
                setZoom(10);
                break;
            case Presets.NORMAL:
                setZoom(25);
                break;
            case Presets.RISK:
                setZoom(30);
                break;
            case Presets.SAFE:
                setZoom(15);
                break;
            case Presets.STABLE:
                setZoom(40);
                break;
        }
    }, [preset]);

    const formattedData = useMemo(() => {
        if (!processedData) return undefined;
        if (processedData && processedData.length === 0) return undefined;

        const middle = Math.round(processedData.length / 2);
        const chunkLength = Math.round(processedData.length / zoom);

        const slicedData = processedData.slice(middle - chunkLength, middle + chunkLength);

        return slicedData.reverse();
    }, [processedData, zoom]);

    const isSorted = currencyA && currencyB && currencyA?.wrapped.sortsBefore(currencyB?.wrapped);

    const leftPrice = useMemo(() => {
        return isSorted ? priceLower?.toSignificant(18) : priceUpper?.invert().toSignificant(18);
    }, [isSorted, priceLower, priceUpper]);

    const rightPrice = useMemo(() => {
        return isSorted ? priceUpper?.toSignificant(18) : priceLower?.invert().toSignificant(18);
    }, [isSorted, priceLower, priceUpper]);

    // const isZoomMin = zoom - ZOOM_STEP <= 10
    // const isZoomMax = zoom + ZOOM_STEP > 40

    // const handleZoomIn = () => setZoom((zoom) => zoom + ZOOM_STEP)
    // const handleZoomOut = () => setZoom((zoom) => zoom - ZOOM_STEP)

    return (
        <div className="flex w-full">
            {formattedData ? (
                <Chart
                    formattedData={formattedData}
                    leftPrice={leftPrice}
                    rightPrice={rightPrice}
                    currentPrice={currentPrice}
                    isSorted={isSorted}
                    zoom={zoom}
                    currencyA={currencyA}
                    currencyB={currencyB}
                    height={height}
                    className={className}
                />
            ) : (
                <LiquidityChartLoader className={className} />
            )}
        </div>
    );
};

const LiquidityChartLoader = ({ className }: { className?: string }) => (
    <div className={`flex h-[230px] w-full items-end gap-4 ${className}`}>
        <Skeleton className="h-[52%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[57%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[70%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[57%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[52%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[70%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[87%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[60%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[57%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[52%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[60%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[52%] w-[40px] bg-[#11A3FB]" />
        <Skeleton className="h-[83%] w-[40px] bg-[#11A3FB]" />
    </div>
);

export default LiquidityChart;



================================================
File: src/components/create-position/PresetTabs/index.tsx
================================================
import { useMemo } from "react";
import { Currency } from "@glyph-exchange/integral-sdk";
import { IDerivedMintInfo, useMintState, useMintActionHandlers } from "@/state/mintStore";
import { PresetProfits, Presets, PresetsArgs } from "@/types/presets";
import Checkbox from "@/components/common/Checkbox";

interface RangeSidebarProps {
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    mintInfo: IDerivedMintInfo;
}

const stablecoinsPreset = [
    {
        type: Presets.STABLE,
        title: `Stablecoins`,
        min: 0.984,
        max: 1.01,
        risk: PresetProfits.VERY_LOW,
        profit: PresetProfits.HIGH,
    },
];

const commonPresets = [
    {
        type: Presets.RISK,
        title: `Narrow`,
        min: 0.95,
        max: 1.1,
        risk: PresetProfits.HIGH,
        profit: PresetProfits.HIGH,
    },
    {
        type: Presets.NORMAL,
        title: `Common`,
        min: 0.9,
        max: 1.2,
        risk: PresetProfits.MEDIUM,
        profit: PresetProfits.MEDIUM,
    },
    {
        type: Presets.SAFE,
        title: `Wide`,
        min: 0.8,
        max: 1.4,
        risk: PresetProfits.LOW,
        profit: PresetProfits.LOW,
    },
    {
        type: Presets.FULL,
        title: `Full`,
        min: 0,
        max: Infinity,
        risk: PresetProfits.VERY_LOW,
        profit: PresetProfits.VERY_LOW,
    },
];

const PresetTabs = ({ currencyA, currencyB, mintInfo }: RangeSidebarProps) => {
    const {
        preset,
        actions: { updateSelectedPreset, setFullRange },
    } = useMintState();

    const { onLeftRangeInput, onRightRangeInput } = useMintActionHandlers(mintInfo.noLiquidity);

    const isStablecoinPair = useMemo(() => {
        if (!currencyA || !currencyB) return false;

        // const stablecoins = [USDC.address, USDT.address, DAI.address];
        const stablecoins = ["", ""];

        return (
            stablecoins.includes(currencyA.wrapped.address.toLowerCase()) &&
            stablecoins.includes(currencyB.wrapped.address.toLowerCase())
        );
    }, [currencyA, currencyB]);

    const price = useMemo(() => {
        if (!mintInfo.price) return;

        return mintInfo.invertPrice
            ? mintInfo.price.invert().toSignificant(5)
            : mintInfo.price.toSignificant(5);
    }, [mintInfo]);

    function handlePresetRangeSelection(preset: any | null) {
        if (!price) return;

        updateSelectedPreset(preset ? preset.type : null);

        if (preset && preset.type === Presets.FULL) {
            setFullRange();
        } else {
            onLeftRangeInput(preset ? String(+price * preset.min) : "");
            onRightRangeInput(preset ? String(+price * preset.max) : "");
        }
    }

    const presets = isStablecoinPair ? stablecoinsPreset : commonPresets;

    function onPresetSelect(range: PresetsArgs) {
        if (preset == range.type) {
            handlePresetRangeSelection(null);
        } else {
            handlePresetRangeSelection(range);
        }
    }

    return (
        <div className="flex h-fit items-center gap-[24px] m:gap-[20px]">
            {presets.map((range) => (
                <Checkbox
                    key={`preset-range-${range.title}`}
                    checked={preset === range.type}
                    onClick={() => onPresetSelect(range)}
                >
                    {range.title}
                </Checkbox>
                /*{ <Button
                    variant={preset === range.type ? 'iconActive' : 'icon'}
                    size={'sm'}
                    key={`preset-range-${range.title}`}
                    onClick={() => onPresetSelect(range)}
                >{range.title}
                </Button> }*/
            ))}
        </div>
    );
};

export default PresetTabs;



================================================
File: src/components/create-position/RangeSelector/index.tsx
================================================
import { IDerivedMintInfo } from "@/state/mintStore";
import { Bound, Currency, Price, Token } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import RangeSelectorPart from "../RangeSelectorPart";

export interface RangeSelectorProps {
    priceLower: Price<Token, Token> | undefined;
    priceUpper: Price<Token, Token> | undefined;
    onLeftRangeInput: (typedValue: string) => void;
    onRightRangeInput: (typedValue: string) => void;
    getDecrementLower: () => string;
    getIncrementLower: () => string;
    getDecrementUpper: () => string;
    getIncrementUpper: () => string;
    currencyA: Currency | null | undefined;
    currencyB: Currency | null | undefined;
    disabled: boolean;
    mintInfo: IDerivedMintInfo;
}

const RangeSelector = ({
    priceLower,
    priceUpper,
    onLeftRangeInput,
    onRightRangeInput,
    getDecrementLower,
    getIncrementLower,
    getDecrementUpper,
    getIncrementUpper,
    currencyA,
    currencyB,
    disabled,
    mintInfo,
}: RangeSelectorProps) => {
    const tokenA = (currencyA ?? undefined)?.wrapped;
    const tokenB = (currencyB ?? undefined)?.wrapped;

    const isSorted = useMemo(() => {
        return tokenA && tokenB && tokenA.sortsBefore(tokenB);
    }, [tokenA, tokenB]);

    const leftPrice = useMemo(() => {
        return isSorted ? priceLower : priceUpper?.invert();
    }, [isSorted, priceLower, priceUpper]);

    const rightPrice = useMemo(() => {
        return isSorted ? priceUpper : priceLower?.invert();
    }, [isSorted, priceUpper, priceLower]);

    return (
        <>
            <div className="flex w-[100%] flex-wrap items-center gap-[20px] m:gap-[10px]">
                <RangeSelectorPart
                    value={
                        mintInfo.ticksAtLimit[Bound.LOWER] ? "0" : leftPrice?.toSignificant(5) ?? ""
                    }
                    onUserInput={onLeftRangeInput}
                    // width="100%"
                    decrement={isSorted ? getDecrementLower : getIncrementUpper}
                    increment={isSorted ? getIncrementLower : getDecrementUpper}
                    decrementDisabled={mintInfo.ticksAtLimit[Bound.LOWER]}
                    incrementDisabled={mintInfo.ticksAtLimit[Bound.LOWER]}
                    label={leftPrice ? `${currencyB?.symbol}` : "-"}
                    initialPrice={mintInfo.price}
                    disabled={disabled}
                    title={"Min price"}
                />
                <RangeSelectorPart
                    value={
                        mintInfo.ticksAtLimit[Bound.UPPER]
                            ? "∞"
                            : rightPrice?.toSignificant(5) ?? ""
                    }
                    onUserInput={onRightRangeInput}
                    decrement={isSorted ? getDecrementUpper : getIncrementLower}
                    increment={isSorted ? getIncrementUpper : getDecrementLower}
                    incrementDisabled={mintInfo.ticksAtLimit[Bound.UPPER]}
                    decrementDisabled={mintInfo.ticksAtLimit[Bound.UPPER]}
                    label={rightPrice ? `${currencyB?.symbol}` : "-"}
                    initialPrice={mintInfo.price}
                    disabled={disabled}
                    title={`Max price`}
                />
            </div>
        </>
    );
};

export default RangeSelector;



================================================
File: src/components/create-position/RangeSelectorPart/index.tsx
================================================
import { useCallback, useEffect, useState } from "react";
import { Price, Token } from "@glyph-exchange/integral-sdk";
import { useMintState } from "@/state/mintStore";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import tw, { styled, theme } from "twin.macro";
import Image from "@/components/common/Image";

const _RangeBtn = styled.div<{ $disabled?: boolean }>`
    width: 36px;
    height: 36px;
    padding: 8px;
    border: 1px solid #000;
    background: #fff;
    cursor: ${(props) => (props.$disabled ? "not-allowed" : "pointer")};
    box-sizing: border-box;
    ${() => tw`flex items-center justify-center font-bold`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        width: 33px;
        height: 33px;
        padding: 8px 8px 7px 7px;
    }
`;
export interface RangeSelectorPartProps {
    value: string;
    onUserInput: (value: string) => void;
    decrement: () => string;
    increment: () => string;
    decrementDisabled?: boolean;
    incrementDisabled?: boolean;
    label?: string;
    width?: string;
    locked?: boolean;
    initialPrice: Price<Token, Token> | undefined;
    disabled: boolean;
    title: string;
}

const RangeSelectorPart = ({
    value,
    decrement,
    increment,
    decrementDisabled = false,
    incrementDisabled = false,
    locked,
    onUserInput,
    disabled,
    title,
}: RangeSelectorPartProps) => {
    const [localUSDValue, setLocalUSDValue] = useState("");
    const [localTokenValue, setLocalTokenValue] = useState("");

    const {
        initialTokenPrice,
        actions: { updateSelectedPreset },
    } = useMintState();

    const handleOnBlur = useCallback(() => {
        onUserInput(localTokenValue);
    }, [localTokenValue, localUSDValue, onUserInput]);

    const handleDecrement = useCallback(() => {
        onUserInput(decrement());
    }, [decrement, onUserInput]);

    const handleIncrement = useCallback(() => {
        onUserInput(increment());
    }, [increment, onUserInput]);

    useEffect(() => {
        if (value) {
            setLocalTokenValue(value);
            if (value === "∞") {
                setLocalUSDValue(value);
                return;
            }
        } else if (value === "") {
            setLocalTokenValue("");
            setLocalUSDValue("");
        }
    }, [initialTokenPrice, value]);

    useEffect(() => {
        return () => updateSelectedPreset(null);
    }, []);

    return (
        <div className="flex flex-1 flex-col items-start gap-[8px] m:gap-[12px]">
            <div className="font-[FraktionMono-Bold] text-[14px] font-bold leading-[1] text-[#000] m:text-[12px]">
                {title.toUpperCase()}
            </div>
            <div className="relative flex items-center">
                <_RangeBtn
                    onClick={handleDecrement}
                    $disabled={decrementDisabled || disabled}
                    className="[border-radius:4px_0px_0px_4px]"
                >
                    <div className="flex h-[18px] w-[18px] items-center justify-center">
                        <Image width={18} height={18} src="/minus.svg" />
                    </div>
                </_RangeBtn>
                {/* <Button 
                    variant={'ghost'}
                    size={'sm'}
                    onClick={handleDecrement} 
                    disabled={decrementDisabled || disabled}
                    className="border border-card-border rounded-xl rounded-r-none"    
                >
                    -
                </Button> */}

                <Input
                    type={"text"}
                    value={localTokenValue}
                    id={title}
                    onBlur={handleOnBlur}
                    disabled={disabled || locked}
                    onUserInput={(v) => {
                        setLocalTokenValue(v);
                        updateSelectedPreset(null);
                    }}
                    placeholder={"0.00"}
                    className="h-[36px] flex-1 rounded-none border-x-0 border-y border-[#000] bg-[#E8E8E8] font-[Geneva] text-[14px] leading-[1.2] text-[#000] m:h-[33px] m:text-[12px]"
                />

                <_RangeBtn
                    onClick={handleIncrement}
                    $disabled={incrementDisabled || disabled}
                    className="[border-radius:0px_4px_4px_0px]"
                >
                    <div className="flex h-[18px] w-[18px] items-center justify-center">
                        <Image width={18} height={18} src="/plus.svg" />
                    </div>
                </_RangeBtn>

                {/* <Button 
                    variant={'ghost'}
                  size={'sm'}
                    onClick={handleIncrement} 
                    disabled={incrementDisabled || disabled} 
                    className="border border-card-border rounded-xl rounded-l-none">
                    +
                </Button> */}
            </div>
        </div>
    );
};

export default RangeSelectorPart;



================================================
File: src/components/create-position/SelectRange/index.tsx
================================================
import { IDerivedMintInfo, useMintState, useRangeHopCallbacks, useMintActionHandlers } from "@/state/mintStore";
import { Bound, Currency } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import RangeSelector from "../RangeSelector";

interface SelectRangeProps {
    currencyA: Currency | null | undefined;
    currencyB: Currency | null | undefined;
    mintInfo: IDerivedMintInfo;
    isCompleted: boolean;
    additionalStep: boolean;
    disabled: boolean;
    backStep: number;
}

const SelectRange = ({ currencyA,
    currencyB,
    mintInfo, }: SelectRangeProps) => {

    const {
        startPriceTypedValue,
    } = useMintState();

    const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = useMemo(() => {
        return mintInfo.ticks;
    }, [mintInfo]);

    const { [Bound.LOWER]: priceLower, [Bound.UPPER]: priceUpper } =
        useMemo(() => {
            return mintInfo.pricesAtTicks;
        }, [mintInfo]);

    const {
        getDecrementLower,
        getIncrementLower,
        getDecrementUpper,
        getIncrementUpper,
    } = useRangeHopCallbacks(
        currencyA ?? undefined,
        currencyB ?? undefined,
        mintInfo.tickSpacing,
        tickLower,
        tickUpper,
        mintInfo.pool
    );

    const { onLeftRangeInput, onRightRangeInput } = useMintActionHandlers(
        mintInfo.noLiquidity
    );

    // const tokenA = (currencyA ?? undefined)?.wrapped;
    // const tokenB = (currencyB ?? undefined)?.wrapped;

    // const isSorted = useMemo(() => {
    //     return tokenA && tokenB && tokenA.sortsBefore(tokenB);
    // }, [tokenA, tokenB, mintInfo]);

    // const leftPrice = useMemo(() => {
    //     return isSorted ? priceLower : priceUpper?.invert();
    // }, [isSorted, priceLower, priceUpper, mintInfo]);

    // const rightPrice = useMemo(() => {
    //     return isSorted ? priceUpper : priceLower?.invert();
    // }, [isSorted, priceUpper, priceLower, mintInfo]);

    // const price = useMemo(() => {
    //     if (!mintInfo.price) return;

    //     return mintInfo.invertPrice
    //         ? mintInfo.price.invert().toSignificant(5)
    //         : mintInfo.price.toSignificant(5);
    // }, [mintInfo]);


    return (
        <div className="flex flex-col">
            <div className="mb-1">
                <RangeSelector
                    priceLower={priceLower}
                    priceUpper={priceUpper}
                    getDecrementLower={getDecrementLower}
                    getIncrementLower={getIncrementLower}
                    getDecrementUpper={getDecrementUpper}
                    getIncrementUpper={getIncrementUpper}
                    onLeftRangeInput={onLeftRangeInput}
                    onRightRangeInput={onRightRangeInput}
                    currencyA={currencyA}
                    currencyB={currencyB}
                    mintInfo={mintInfo}
                    disabled={!startPriceTypedValue && !mintInfo.price}
                />
            </div>
            {mintInfo.outOfRange && (
                <div>Out of range</div>
            )}
            {mintInfo.invalidRange && (
                <div>Invalid range</div>
            )}
        </div>
    );

}

export default SelectRange


================================================
File: src/components/create-position/TokenRatio/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import { cn } from "@/lib/utils";
import { IDerivedMintInfo } from "@/state/mintStore";
import { useMemo } from "react";
import { PositionManager } from "@/types/position-state";
import { Field } from "@glyph-exchange/integral-sdk";

interface TokenRatioProps {
    mintInfo: IDerivedMintInfo;
    className?: string;
    gammaAmounts?: IDerivedMintInfo["parsedAmounts"];
}

const TokenRatio = ({ className, mintInfo, gammaAmounts }: TokenRatioProps) => {
    const {
        currencies: { CURRENCY_A: currencyA, CURRENCY_B: currencyB },
        ticksAtLimit,
    } = mintInfo;

    const { LOWER: tickLowerAtLimit, UPPER: tickUpperAtLimit } = ticksAtLimit;

    const [token0Ratio, token1Ratio] = useMemo(() => {
        if (mintInfo.positionManager === PositionManager.ALGEBRA) {
            const currentPrice = mintInfo.price?.toSignificant(5);

            const left = mintInfo.lowerPrice?.toSignificant(5);
            const right = mintInfo.upperPrice?.toSignificant(5);

            if (tickUpperAtLimit) return ["50", "50"];

            if (!currentPrice) return ["0", "0"];

            if (!left && !right) return ["0", "0"];

            if (!left && right) return ["0", "100"];

            if (!right && left) return ["100", "0"];

            if (mintInfo.depositADisabled) {
                return ["0", "100"];
            }

            if (mintInfo.depositBDisabled) {
                return ["100", "0"];
            }

            if (left && right && currentPrice) {
                const leftRange = +currentPrice - +left;
                const rightRange = +right - +currentPrice;

                const totalSum = +leftRange + +rightRange;

                const leftRate = (+leftRange * 100) / totalSum;
                const rightRate = (+rightRange * 100) / totalSum;

                if (mintInfo.invertPrice) {
                    return [String(leftRate), String(rightRate)];
                } else {
                    return [String(rightRate), String(leftRate)];
                }
            }
        } else if (mintInfo.positionManager === PositionManager.GAMMA && gammaAmounts) {
            const left = Number(gammaAmounts[Field.CURRENCY_A]?.toSignificant(5));
            const right = Number(gammaAmounts[Field.CURRENCY_B]?.toSignificant(5));

            if (left && right) {
                const totalSum = left + right;
                const leftRange = (left / totalSum) * 100;
                const rightRange = 100 - leftRange;
                return [String(leftRange), String(rightRange)];
            }

            return ["50", "50"];
        }

        return ["0", "0"];
    }, [mintInfo, tickLowerAtLimit, tickUpperAtLimit, gammaAmounts]);

    return (
        <div
            className={cn(
                "relative flex h-[24px] overflow-hidden rounded-full font-[FraktionMono-Bold] text-[14px] text-black b1 m:text-[12px]",
                className,
            )}
        >
            <div className="flex h-full w-full">
                {Number(token0Ratio) > 0 && (
                    <div
                        className={`flex h-full items-center justify-end border border-[#D9D9D9] bg-[#D9D9D9] px-[8px] duration-300 ${Number(token0Ratio) === 100 ? "rounded-2xl" : "rounded-l-2xl"}`}
                        style={{ width: `${token0Ratio}%` }}
                    >
                        <CurrencyLogo
                            currency={currencyA}
                            size={20}
                            className="absolute left-[2px]"
                        />
                        {`${Number(token0Ratio).toFixed()}%`}
                    </div>
                )}
                {Number(token1Ratio) > 0 && (
                    <div
                        className={`flex h-full items-center border border-[#B8B8B8] border-l-black bg-[#B8B8B8] px-[8px] duration-300 ${Number(token1Ratio) === 100 ? "rounded-2xl" : "rounded-r-2xl"}`}
                        style={{ width: `${token1Ratio}%` }}
                    >
                        {`${Number(token1Ratio).toFixed()}%`}
                        <CurrencyLogo
                            currency={currencyB}
                            size={20}
                            className="absolute right-[2px]"
                        />
                    </div>
                )}
            </div>
        </div>
    );
};

export default TokenRatio;



================================================
File: src/components/farming/ActiveFarming/index.tsx
================================================
import { useCallback, useEffect, useState } from "react";
import { SelectPositionFarmModal } from "@/components/modals/SelectPositionFarmModal";
import { isSameRewards } from "@/utils/farming/isSameRewards";
import { Deposit } from "@/graphql/generated/graphql";
import { Farming } from "@/types/farming-info";
import { formatUnits } from "viem";
import { getFarmingRewards } from "@/utils/farming/getFarmingRewards";
import { FormattedPosition } from "@/types/formatted-position";
import CurrencyLogo from "@/components/common/CurrencyLogo";
import { useCurrency } from "@/hooks/common/useCurrency";
import { useAccount } from "wagmi";
import { useFarmHarvestAll } from "@/hooks/farming/useFarmHarvest";
import Loader from "@/components/common/Loader";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import { useRewardEarnedUSD } from "@/hooks/farming/useRewardEarnedUSD";
import { useFarmingAPR } from "@/hooks/farming/useFarmingAPR";
import tw, { styled, theme } from "twin.macro";
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import Image from "@/components/common/Image";
import FloatingButton from "@/components/common/FloatingButton";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

const _MyFarmingPanelBase = styled(PanelBase)`
    ${() => tw`mt-[20px] items-start bg-[#F2E9FF]`}
`;

const _RewardsInfo = styled.div`
    padding: 24px 23px 20px;
    border-bottom: 1px solid #000;

    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 1;

    ${() => tw`flex w-full flex-col items-start gap-[12px]`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        padding: 16px 24px;
        font-size: 10px;
        ${() => tw`gap-[8px]`}
    }
`;

const _LabelBox = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 1;

    > .value {
        font-size: 24px;
        line-height: 1.2;
    }

    ${() => tw`flex flex-col items-start gap-[16px]`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 10px;
        > .value {
            font-size: 14px;
        }

        ${() => tw`gap-[8px]`}
    }
`;

interface ActiveFarmingProps {
    farming: Farming;
    deposits: Deposit[];
    positionsData: FormattedPosition[];
}

const ActiveFarming = ({ farming, deposits, positionsData }: ActiveFarmingProps) => {
    const isMobile = useMediaQuery("mobile");
    const { address: account } = useAccount();

    const [rewardEarned, setRewardEarned] = useState<bigint>(0n);
    const [bonusRewardEarned, setBonusRewardEarned] = useState<bigint>(0n);
    const [rewardsActionLoading, setRewardsActionLoading] = useState(false);

    const APR = useFarmingAPR({ farmingId: farming.farming.id });

    const isSameReward = isSameRewards(
        farming.farming.rewardToken,
        farming.farming.bonusRewardToken,
    );

    const formattedRewardEarned = Number(formatUnits(rewardEarned, farming.rewardToken.decimals));

    const formattedBonusRewardEarned = Number(
        formatUnits(bonusRewardEarned, farming.bonusRewardToken?.decimals),
    );

    const rewardEarnedUSD = useRewardEarnedUSD({
        token: farming.rewardToken,
        reward: rewardEarned,
    });

    const bonusRewardEarnedUSD = useRewardEarnedUSD({
        token: farming.bonusRewardToken,
        reward: bonusRewardEarned,
    });

    const farmingRewards = (rewardEarnedUSD + bonusRewardEarnedUSD).toFixed(4);

    const rewardTokenCurrency = useCurrency(farming.farming.rewardToken);
    const bonusRewardTokenCurrency = useCurrency(farming.farming.bonusRewardToken);

    const TVL = deposits.reduce((acc, deposit) => {
        const currentFormattedPosition = positionsData.find(
            (position) => Number(position.id) === Number(deposit.id),
        );
        if (deposit.eternalFarming !== null && currentFormattedPosition) {
            return acc + currentFormattedPosition.liquidityUSD;
        } else {
            return acc;
        }
    }, 0);

    const formattedTVL = TVL.toFixed(2);

    const rewardRatePerDay =
        Number(formatUnits(farming.farming.rewardRate, farming.rewardToken.decimals)) *
        60 *
        60 *
        24;

    const bonusRewardRatePerDay =
        Number(formatUnits(farming.farming.bonusRewardRate, farming.bonusRewardToken?.decimals)) *
        60 *
        60 *
        24;

    const { isLoading, onHarvestAll, isSuccess } = useFarmHarvestAll(
        {
            rewardToken: farming.farming.rewardToken,
            bonusRewardToken: farming.farming.bonusRewardToken,
            pool: farming.farming.pool,
            nonce: farming.farming.nonce,
            account: account ?? ADDRESS_ZERO,
        },
        deposits,
    );

    const handleHarvestAll = useCallback(async () => {
        try {
            if (rewardsActionLoading || !onHarvestAll) return;
            setRewardsActionLoading(true);
            await onHarvestAll();
        } catch (e) {
            setRewardsActionLoading(false);
            console.log(e, ":call handleHarvestAll error");
        }
    }, [rewardsActionLoading, onHarvestAll]);

    useEffect(() => {
        setRewardsActionLoading(isLoading);
    }, [isLoading]);

    useEffect(() => {
        const promises: Promise<{
            reward: bigint;
            bonusReward: bigint;
        }>[] = [];
        deposits.forEach((deposit) => {
            if (deposit.eternalFarming !== null) {
                promises.push(
                    getFarmingRewards({
                        rewardToken: farming.farming.rewardToken,
                        bonusRewardToken: farming.farming.bonusRewardToken,
                        pool: farming.farming.pool,
                        nonce: farming.farming.nonce,
                        tokenId: BigInt(deposit.id),
                    }),
                );
            }
        });
        if (promises.length === 0) return;
        Promise.all(promises).then((rewards) => {
            setRewardEarned(0n);
            setBonusRewardEarned(0n);
            rewards.forEach((reward) => {
                setRewardEarned((prev) => prev + reward.reward);
                setBonusRewardEarned((prev) => prev + reward.bonusReward);
            });
        });
    }, [deposits, farming, isSuccess]);

    return (
        <_MyFarmingPanelBase>
            <PanelTitle className="bg-[#FFF]" title="FARMING" />

            <div className="flex w-full flex-wrap items-start gap-[48px] p-[24px] [border-bottom:1px_solid_#000] m:flex-col m:gap-[11px] m:[padding:16px_24px]">
                <div className="flex items-center gap-[48px] m:gap-[20px]">
                    <Image
                        width={isMobile ? 36 : 64}
                        height={isMobile ? 36 : 64}
                        src="/farming_pool_coin.svg"
                    />
                    <_LabelBox>
                        <span>APR</span>
                        <span className="value">{APR ? APR : "0"}%</span>
                    </_LabelBox>
                    <_LabelBox className="m:ml-[7px]">
                        <span>TVL</span>
                        <span className="value">${formattedTVL}</span>
                    </_LabelBox>
                </div>

                <_LabelBox className="m:ml-[56px]">
                    <span>EARNED</span>
                    <div className="value flex items-start gap-[24px] m:gap-[28px]">
                        {/* <span className="m:text-[#9747FF]">${farmingRewards}</span> */}
                        <div className="flex flex-col items-start gap-[8px] !text-[14px] m:!text-[12px]">
                            {farmingRewards !== "0.0000" ? (
                                <>
                                    <span>
                                        <span className="m:text-[#9747FF]">
                                            {formattedRewardEarned.toFixed(2) === "0.00"
                                                ? "<0.01"
                                                : formattedRewardEarned.toFixed(2)}{" "}
                                        </span>
                                        {farming.rewardToken.symbol}
                                    </span>
                                    {!isSameReward && (
                                        <span>
                                            <span className="m:text-[#9747FF]">
                                                {formattedBonusRewardEarned.toFixed(2) === "0.00"
                                                    ? "<0.01"
                                                    : formattedBonusRewardEarned.toFixed(2)}{" "}
                                            </span>
                                            {farming.bonusRewardToken?.symbol}
                                        </span>
                                    )}
                                </>
                            ) : (
                                "0"
                            )}
                        </div>
                    </div>
                </_LabelBox>

                {/* <CardInfo
                    additional={
                        !isSameReward && farmingRewards !== '0.0000'
                            ? `${
                                    formattedRewardEarned.toFixed(2) ===
                                    '0.00'
                                        ? '<0.01'
                                        : formattedRewardEarned.toFixed(2)
                                } ${farming.rewardToken.symbol} + ${
                                    formattedBonusRewardEarned.toFixed(2) ===
                                    '0.00'
                                        ? '<0.01'
                                        : formattedBonusRewardEarned.toFixed(
                                            2
                                        )
                                } ${farming.bonusRewardToken?.symbol}`
                            : ''
                    }
                    className="w-full"
                    title="EARNED"
                >
                    <p className="text-cyan-300">${farmingRewards}</p>
                </CardInfo> */}
            </div>

            <_RewardsInfo>
                <span>TOTAL DAILY REWARD</span>
                <div className="flex w-full items-center gap-[6px] m:gap-[4px]">
                    {isSameReward ? (
                        <>
                            <CurrencyLogo
                                size={isMobile ? 16 : 24}
                                currency={rewardTokenCurrency}
                            />
                            <span className="!text-[24px] !leading-[1.2] m:!text-[14px]">
                                {`${(rewardRatePerDay + bonusRewardRatePerDay).toFixed(2)} ${
                                    farming.rewardToken.symbol
                                }`}
                            </span>
                        </>
                    ) : (
                        <div className="flex w-full items-center gap-[16px] m:gap-[13px]">
                            <div className="flex flex-1 items-center gap-[6px] m:gap-[4px]">
                                <CurrencyLogo
                                    size={isMobile ? 16 : 24}
                                    currency={rewardTokenCurrency}
                                />
                                <span className="text-left font-[FraktionMono-Bold] !text-[20px] font-bold !leading-[1.2] text-[#000] m:!text-[14px]">
                                    {`${
                                        rewardRatePerDay.toFixed(2) === "0.00"
                                            ? "<0.01"
                                            : rewardRatePerDay.toFixed(2)
                                    } ${farming.rewardToken.symbol}`}
                                </span>
                            </div>
                            {bonusRewardRatePerDay > 0 && (
                                <div className="flex flex-1 items-center gap-[6px] m:gap-[4px]">
                                    <CurrencyLogo
                                        size={isMobile ? 16 : 24}
                                        currency={bonusRewardTokenCurrency}
                                    />
                                    <span className="text-left font-[FraktionMono-Bold] !text-[20px] font-bold !leading-[1.2] text-[#000] m:!text-[14px]">
                                        {`${
                                            bonusRewardRatePerDay.toFixed(2) === "0.00"
                                                ? "<0.01"
                                                : bonusRewardRatePerDay.toFixed(2)
                                        } ${farming.bonusRewardToken?.symbol}`}
                                    </span>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </_RewardsInfo>

            {/* <CardInfo title="Rewards">
                <div className="flex gap-12 min-h-12">
                    <div className="flex gap-4 items-center">
                        {isSameReward ? (
                            <>
                                <CurrencyLogo
                                    size={32}
                                    currency={rewardTokenCurrency}
                                />
                                <p>
                                    {`${(
                                        rewardRatePerDay +
                                        bonusRewardRatePerDay
                                    ).toFixed(2)} ${
                                        farming.rewardToken.symbol
                                    } / day`}
                                </p>
                            </>
                        ) : (
                            <div className="flex w-full gap-4 max-md:flex-col">
                                <div className="flex w-fit h-fit gap-4 items-center">
                                    <CurrencyLogo
                                        className="h-fit"
                                        size={32}
                                        currency={rewardTokenCurrency}
                                    />
                                    <p>
                                        {`${
                                            rewardRatePerDay.toFixed(2) ===
                                            '0.00'
                                                ? '<0.01'
                                                : rewardRatePerDay.toFixed(
                                                        2
                                                    )
                                        } ${
                                            farming.rewardToken.symbol
                                        } / day`}
                                    </p>
                                </div>
                                {bonusRewardRatePerDay > 0 && (
                                    <div className="flex w-fit h-fit gap-4 items-center">
                                        <CurrencyLogo
                                            className="h-fit"
                                            size={32}
                                            currency={
                                                bonusRewardTokenCurrency
                                            }
                                        />
                                        <p>
                                            {`${
                                                bonusRewardRatePerDay.toFixed(
                                                    2
                                                ) === '0.00'
                                                    ? '<0.01'
                                                    : bonusRewardRatePerDay.toFixed(
                                                            2
                                                        )
                                            } ${
                                                farming.bonusRewardToken
                                                    ?.symbol
                                            } / day`}
                                        </p>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            </CardInfo> */}

            <div className="flex w-full items-center gap-[16px] [padding:24px_24px_32px] m:flex-col m:gap-[12px] m:[padding:16px_20px]">
                <FloatingButton
                    disabled={
                        (rewardEarnedUSD === 0 && bonusRewardEarnedUSD === 0) ||
                        rewardsActionLoading
                    }
                    onClick={handleHarvestAll}
                    innerStyle={{
                        background:
                            (rewardEarnedUSD === 0 && bonusRewardEarnedUSD === 0) ||
                            rewardsActionLoading
                                ? "#BBB"
                                : "#9747FF",
                    }}
                    className="flex-1 m:h-[48px] m:w-full m:flex-[unset]"
                >
                    {rewardsActionLoading ? <Loader /> : "Collect Rewards"}
                </FloatingButton>
                <SelectPositionFarmModal
                    isHarvestLoading={rewardsActionLoading}
                    positions={deposits}
                    farming={farming}
                    positionsData={positionsData}
                />
            </div>
        </_MyFarmingPanelBase>
    );
};

export default ActiveFarming;



================================================
File: src/components/farming/FarmingPositionCard/index.tsx
================================================
import { Deposit } from "@/graphql/generated/graphql";
import { cn } from "@/lib/utils";
import PositionNFT from "@/components/position/PositionNFT";

interface FarmingPositionCardProps {
    position: Deposit;
    status: string;
    className?: string;
    onClick?: () => void;
}

const FarmingPositionCard = ({
    position,
    status,
    className,
    onClick,
}: FarmingPositionCardProps) => {
    return (
        <div
            onClick={onClick}
            className={cn(
                "flex w-fit cursor-pointer items-center gap-[32px] bg-[#FFF] transition-all duration-200 ease-in-out [border:1px_solid_#979797] [padding:16px_24px_22px] hover:![border:1px_solid_#000] m:gap-[24px] m:[padding:11px_15px]",
                className,
            )}
        >
            <PositionNFT
                className="h-[89px] w-[52px] shrink-0 m:h-[65px] m:w-[38px]"
                positionId={Number(position.id)}
            />
            {/* <FarmingPositionImg positionId={BigInt(position.id)} size={12} /> */}
            <div className="flex flex-col items-start gap-[8px]">
                <span className="font-[FraktionMono-Bold] text-[16px] font-bold leading-[1] text-[#000]">
                    Position #{position.id}
                </span>
                <div
                    className={cn(
                        "flex items-center gap-[8px] font-[Geneva] text-[12px] leading-[1.2]",
                        status === "In range" ? "text-[#40B883]" : "text-[#FD375B]",
                    )}
                >
                    <div
                        className={cn(
                            "h-[4px] w-[4px] rounded-full",
                            status === "In range" ? "bg-[#40B883]" : "bg-[#FD375B]",
                        )}
                    ></div>
                    <span>{status}</span>
                </div>
            </div>
        </div>
    );
};

export default FarmingPositionCard;



================================================
File: src/components/farming/FarmingPositionImg/index.tsx
================================================
import { useAlgebraPositionManagerTokenUri } from "@/generated";
import { cn } from "@/lib/utils";
import { useEffect, useRef } from "react";

export const FarmingPositionImg = ({
    positionId,
    size,
    className,
}: {
    positionId: bigint;
    size: number;
    className?: string;
}) => {
    const { data: uri } = useAlgebraPositionManagerTokenUri({
        args: [positionId],
    });

    const imgRef = useRef<any>();

    const json = uri && JSON.parse(atob(uri.slice("data:application/json;base64,".length)));

    useEffect(() => {
        if (!imgRef?.current || !json) return;

        imgRef.current.src = json.image;
    }, [imgRef, json]);

    return (
        <div
            className={cn(
                "flex items-center justify-center overflow-hidden rounded-full",
                className,
            )}
            style={{
                background: "linear-gradient(181.1deg, #686EFF 0.93%, #141520 99.07%)",
                width: `${size}px`,
            }}
        >
            {json ? <img ref={imgRef} className="scale-[2]" /> : <p>{positionId.toString()}</p>}
        </div>
    );
};



================================================
File: src/components/modals/IncreaseLiquidityModal/index.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import AmountsSection from "@/components/create-position/AmountsSection";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import { IDerivedMintInfo } from "@/state/mintStore";
import { ManageLiquidity } from "@/types/manage-liquidity";
import { Currency } from "@glyph-exchange/integral-sdk";
import { memo, useState } from "react";

interface IncreaseLiquidityModalProps {
    tokenId: number;
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    mintInfo: IDerivedMintInfo;
}

export const IncreaseLiquidityModal = memo(
    ({ tokenId, currencyA, currencyB, mintInfo }: IncreaseLiquidityModalProps) => {
        const [isOpen, setIsOpen] = useState(false);

        const handleCloseModal = () => {
            setIsOpen(false);
        };

        return (
            <Credenza open={isOpen} onOpenChange={setIsOpen}>
                <CredenzaTrigger asChild>
                    <FloatingButton>Add Liquidity</FloatingButton>
                </CredenzaTrigger>
                <CredenzaContent
                    onInteractOutside={() => setIsOpen(false)}
                    onEscapeKeyDown={() => setIsOpen(false)}
                >
                    <PanelTitle title="ADD LIQUIDITY" />
                    <CredenzaClose onClick={() => setIsOpen(false)} />
                    <PanelContainer>
                        <AmountsSection
                            handleCloseModal={handleCloseModal}
                            tokenId={tokenId}
                            currencyA={currencyA}
                            currencyB={currencyB}
                            mintInfo={mintInfo}
                            manageLiquidity={ManageLiquidity.INCREASE}
                        />
                    </PanelContainer>
                    <PanelFooter />
                </CredenzaContent>
            </Credenza>
        );
    },
);



================================================
File: src/components/modals/RemoveLiquidityModal/index.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import { Slider } from "@/components/ui/slider";
import {
    useGammaHypervisorWithdraw,
    usePrepareAlgebraPositionManagerMulticall,
    usePrepareGammaHypervisorWithdraw,
    useGammaHypervisorBalanceOf,
} from "@/generated";
import { farmingClient } from "@/graphql/clients";
import { Deposit } from "@/graphql/generated/graphql";
import { useTransactionAwait } from "@/hooks/common/useTransactionAwait";
import { usePosition, usePositions, useUserGammaPositions } from "@/hooks/positions/usePositions";
import { useBurnActionHandlers, useBurnState, useDerivedBurnInfo } from "@/state/burnStore";
import { useMintState } from "@/state/mintStore";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { useUserState } from "@/state/userStore";
import { PositionManager } from "@/types/position-state";
import { NonfungiblePositionManager, Percent } from "@glyph-exchange/integral-sdk";
import { memo, useEffect, useMemo, useState } from "react";
import tw, { styled } from "twin.macro";
import { Address, useAccount, useContractWrite } from "wagmi";

interface RemoveLiquidityModalProps {
    positionId: number;
}

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    ${() => tw`m:text-[12px]`}
`;

const _SliderValue = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 40px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw`mt-[24px] m:mt-[14px] m:text-[32px]`}
`;

const _Button = styled.button`
    color: #000;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    &.active {
        background-color: black;
        color: white;
    }

    ${() => tw`rounded-[6px] bg-white p-[10px_16px] duration-200 b1 m:p-[9px_12px] m:text-[12px]`}
`;

const AlgebraModal: FCProps<RemoveLiquidityModalProps> = memo(({ positionId }) => {
    const [sliderValue, setSliderValue] = useState([50]);

    const { txDeadline } = useUserState();
    const { address: account } = useAccount();

    const { refetch: refetchAllPositions } = usePositions();

    const { position, refetch: refetchPosition } = usePosition(positionId);

    const { percent } = useBurnState();

    const { onPercentSelect } = useBurnActionHandlers();

    const derivedInfo = useDerivedBurnInfo(position, false);

    const { position: positionSDK, liquidityPercentage, feeValue0, feeValue1 } = derivedInfo;

    const { calldata, value } = useMemo(() => {
        if (
            !positionSDK ||
            !positionId ||
            !liquidityPercentage ||
            !feeValue0 ||
            !feeValue1 ||
            !account ||
            percent === 0
        )
            return { calldata: undefined, value: undefined };

        return NonfungiblePositionManager.removeCallParameters(positionSDK, {
            tokenId: String(positionId),
            liquidityPercentage,
            slippageTolerance: new Percent(2, 100),
            deadline: Date.now() + txDeadline * 1000,
            collectOptions: {
                expectedCurrencyOwed0: feeValue0,
                expectedCurrencyOwed1: feeValue1,
                recipient: account,
            },
        });
    }, [
        positionId,
        positionSDK,
        txDeadline,
        feeValue0,
        feeValue1,
        liquidityPercentage,
        account,
        percent,
    ]);

    const { config: removeLiquidityConfig } = usePrepareAlgebraPositionManagerMulticall({
        args: calldata && [calldata as `0x${string}`[]],
        value: BigInt(value || 0),
        enabled: Boolean(calldata),
    });

    const {
        data: removeLiquidityData,
        write: removeLiquidity,
        isLoading: isConfirmLoading,
    } = useContractWrite(removeLiquidityConfig);

    const { isLoading: isRemoveLoading, isSuccess } = useTransactionAwait(
        removeLiquidityData?.hash,
        {
            title: "Removing liquidity",
            tokenA: position?.token0 as Address,
            tokenB: position?.token1 as Address,
            type: TransactionType.POOL,
        },
    );

    const isDisabled = sliderValue[0] === 0 || isRemoveLoading || !removeLiquidity;

    useEffect(() => {
        onPercentSelect(sliderValue[0]);
    }, [sliderValue]);

    const [isOpen, setIsOpen] = useState(false);

    useEffect(() => {
        if (!isSuccess) return;
        let interval: NodeJS.Timeout;

        /* pool positions refetch */
        Promise.all([refetchPosition(), refetchAllPositions()])

            /* farming deposits refetch */
            .then(() => {
                setIsOpen(false);
                if (sliderValue[0] !== 100) return;
                interval = setInterval(
                    () =>
                        farmingClient.refetchQueries({
                            include: ["Deposits"],
                            onQueryUpdated: (query, { result: diff }) => {
                                const currentPos = diff.deposits.find(
                                    (deposit: Deposit) =>
                                        deposit.id.toString() === positionId.toString(),
                                );
                                if (!currentPos) return;

                                if (currentPos.eternalFarming === null) {
                                    clearInterval(interval);
                                } else {
                                    query.refetch().then();
                                }
                            },
                        }),
                    2000,
                );
            });

        return () => clearInterval(interval);
    }, [isSuccess]);

    return (
        <Credenza open={isOpen} onOpenChange={setIsOpen}>
            <CredenzaTrigger asChild>
                <FloatingButton>Remove Liquidity</FloatingButton>
            </CredenzaTrigger>
            <CredenzaContent
                onInteractOutside={() => setIsOpen(false)}
                onEscapeKeyDown={() => setIsOpen(false)}
            >
                <PanelTitle title="REMOVE LIQUIDITY" />
                <CredenzaClose onClick={() => setIsOpen(false)} />
                <PanelContainer>
                    <div className="p-[24px_24px_42px] m:p-[20px_20px_32px]">
                        <_Title>You Remove Liquidity</_Title>

                        <_SliderValue>{sliderValue}%</_SliderValue>

                        <div className="mt-[28px] flex gap-[12px] m:mt-[22px]">
                            {[25, 50, 75, 100].map((v) => (
                                <_Button
                                    key={`liquidity-percent-${v}`}
                                    disabled={isRemoveLoading}
                                    onClick={() => setSliderValue([v])}
                                    className={sliderValue[0] == v ? "active" : ""}
                                >
                                    {v}%
                                </_Button>
                            ))}
                        </div>

                        <Slider
                            value={sliderValue}
                            id="liquidity-percent"
                            max={100}
                            defaultValue={sliderValue}
                            step={1}
                            onValueChange={(v) => setSliderValue(v)}
                            className="mt-[20px] m:mt-[16px]"
                            aria-label="Liquidity Percent"
                            disabled={isRemoveLoading}
                        />

                        <FloatingButton
                            className="mt-[40px] m:mt-[36px]"
                            disabled={isDisabled || isRemoveLoading || isConfirmLoading}
                            onClick={() => removeLiquidity && removeLiquidity()}
                        >
                            {isRemoveLoading || isConfirmLoading ? <Loader /> : "Remove Liquidity"}
                        </FloatingButton>
                    </div>
                </PanelContainer>
                <PanelFooter />
            </CredenzaContent>
        </Credenza>
    );
});

const GammaModal: FCProps = memo(() => {
    const hypervisor = useMintState((state) => state.hypervisor);
    const [sliderValue, setSliderValue] = useState([50]);

    const { address: account } = useAccount();

    const { data: balance } = useGammaHypervisorBalanceOf({
        address: hypervisor.address,
        args: [account as Address],
        watch: true,
    });

    const withdrawAmount = useMemo(
        () => (balance ? (balance * BigInt(sliderValue[0])) / 100n : 0n),
        [balance, sliderValue],
    );

    const { refetch: refetchAllPositions } = useUserGammaPositions();

    const calldata = useMemo(
        () =>
            withdrawAmount && account
                ? ([withdrawAmount, account, account, [0n, 0n, 0n, 0n]] as const)
                : undefined,
        [withdrawAmount, account],
    );

    const { config: removeLiquidityConfig } = usePrepareGammaHypervisorWithdraw({
        address: hypervisor.address,
        args: calldata,
        enabled: !!calldata,
    });

    const {
        data: removeLiquidityData,
        write: removeLiquidity,
        isLoading: isConfirmLoading,
    } = useGammaHypervisorWithdraw(removeLiquidityConfig);

    const { isLoading: isRemoveLoading, isSuccess } = useTransactionAwait(
        removeLiquidityData?.hash,
        {
            title: "Removing liquidity",
            tokenA: hypervisor.token0 as Address,
            tokenB: hypervisor.token1 as Address,
            type: TransactionType.POOL,
        },
    );

    const isDisabled = sliderValue[0] === 0 || isRemoveLoading || !removeLiquidity;

    const [isOpen, setIsOpen] = useState(false);

    useEffect(() => {
        if (!isSuccess) return;

        refetchAllPositions().then(() => setIsOpen(false));
    }, [isSuccess, refetchAllPositions]);

    return (
        <Credenza open={isOpen} onOpenChange={setIsOpen}>
            <CredenzaTrigger asChild>
                <FloatingButton>Remove Liquidity</FloatingButton>
            </CredenzaTrigger>
            <CredenzaContent
                onInteractOutside={() => setIsOpen(false)}
                onEscapeKeyDown={() => setIsOpen(false)}
            >
                <PanelTitle title="REMOVE LIQUIDITY" />
                <CredenzaClose onClick={() => setIsOpen(false)} />
                <PanelContainer>
                    <div className="p-[24px_24px_42px] m:p-[20px_20px_32px]">
                        <_Title>You Remove Liquidity</_Title>

                        <_SliderValue>{sliderValue}%</_SliderValue>

                        <div className="mt-[28px] flex gap-[12px] m:mt-[22px]">
                            {[25, 50, 75, 100].map((v) => (
                                <_Button
                                    key={`liquidity-percent-${v}`}
                                    disabled={isRemoveLoading}
                                    onClick={() => setSliderValue([v])}
                                    className={sliderValue[0] == v ? "active" : ""}
                                >
                                    {v}%
                                </_Button>
                            ))}
                        </div>

                        <Slider
                            value={sliderValue}
                            id="liquidity-percent"
                            max={100}
                            defaultValue={sliderValue}
                            step={1}
                            onValueChange={(v) => setSliderValue(v)}
                            className="mt-[20px] m:mt-[16px]"
                            aria-label="Liquidity Percent"
                            disabled={isRemoveLoading}
                        />

                        <FloatingButton
                            className="mt-[40px] m:mt-[36px]"
                            disabled={isDisabled || isRemoveLoading || isConfirmLoading}
                            onClick={() => removeLiquidity && removeLiquidity()}
                        >
                            {isRemoveLoading || isConfirmLoading ? <Loader /> : "Remove Liquidity"}
                        </FloatingButton>
                    </div>
                </PanelContainer>
                <PanelFooter />
            </CredenzaContent>
        </Credenza>
    );
});

const RemoveLiquidityModal = ({ positionId }: RemoveLiquidityModalProps) => {
    const positionManager = useMintState((state) => state.positionManager);

    if (positionManager === PositionManager.ALGEBRA)
        return <AlgebraModal positionId={positionId} />;
    else if (positionManager === PositionManager.GAMMA) return <GammaModal />;
};

RemoveLiquidityModal.whyDidYouRender = true;

export default RemoveLiquidityModal;



================================================
File: src/components/modals/SelectPositionFarmModal/index.tsx
================================================
import Loader from "@/components/common/Loader";
import FarmingPositionCard from "@/components/farming/FarmingPositionCard";
import { Deposit } from "@/graphql/generated/graphql";
import { useFarmApprove } from "@/hooks/farming/useFarmApprove";
import { useFarmCheckApprove } from "@/hooks/farming/useFarmCheckApprove";
import { cn } from "@/lib/utils";
import { Farming } from "@/types/farming-info";
import { FormattedPosition } from "@/types/formatted-position";
import { useCallback, useEffect, useState } from "react";
import { useFarmStake } from "@/hooks/farming/useFarmStake";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import FloatingButton from "@/components/common/FloatingButton";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";

interface SelectPositionFarmModalProps {
    positions: Deposit[];
    farming: Farming;
    positionsData: FormattedPosition[];
    isHarvestLoading: boolean;
    className?: string;
}

export function SelectPositionFarmModal({
    positions,
    farming,
    positionsData,
    isHarvestLoading,
    className,
}: SelectPositionFarmModalProps) {
    const isMobile = useMediaQuery("mobile");
    const [isOpen, setIsOpen] = useState(false);
    const [approveActionLoading, setApproveActionLoading] = useState(false);
    const [stakeActionLoading, setStakeActionLoading] = useState(false);
    const [fetchStakeResult, setFetchStakeResult] = useState(false);

    const [selectedPosition, setSelectedPosition] = useState<Deposit | null>();
    const tokenId = selectedPosition ? BigInt(selectedPosition.id) : 0n;

    const { approved, isLoading: isApproving } = useFarmCheckApprove(tokenId);

    const { isLoading: isApproveLoading, onApprove } = useFarmApprove(tokenId);

    const { isLoading: isStakeLoading, onStake } = useFarmStake({
        tokenId,
        rewardToken: farming.farming.rewardToken,
        bonusRewardToken: farming.farming.bonusRewardToken,
        pool: farming.farming.pool,
        nonce: farming.farming.nonce,
    });

    const handleApprove = useCallback(async () => {
        try {
            if (approved || !onApprove) return;
            setApproveActionLoading(true);
            await onApprove();
        } catch (e) {
            setApproveActionLoading(false);
            console.log(e, ":call handleApprove error");
        }
    }, [approved, onApprove]);

    const handleStake = useCallback(async () => {
        try {
            if (!approved || !onStake) return;
            if (stakeActionLoading || approveActionLoading) return;
            setStakeActionLoading(true);
            await onStake();
            setFetchStakeResult(true);
        } catch (e) {
            setStakeActionLoading(false);
            console.log(e, ":call handleStake error");
        }
    }, [stakeActionLoading, approveActionLoading, approved, onStake]);

    const handleSelectPosition = (position: Deposit) => {
        if (stakeActionLoading || approveActionLoading || isApproving) return;
        setSelectedPosition(position);
    };

    useEffect(() => {
        setApproveActionLoading(isApproveLoading);
    }, [isApproveLoading]);

    useEffect(() => {
        setStakeActionLoading(isStakeLoading);
        if (fetchStakeResult && !isStakeLoading) {
            setSelectedPosition(undefined);
            setFetchStakeResult(false);
        }
    }, [isStakeLoading, fetchStakeResult]);

    const availablePositions = positions.filter(
        (position) => position.eternalFarming === null && position.liquidity > 0n,
    );

    return (
        <Credenza className={className} open={isOpen}>
            <CredenzaTrigger asChild>
                <FloatingButton
                    disabled={isHarvestLoading}
                    onClick={() => setIsOpen(true)}
                    className="flex-1 m:h-[48px] m:w-full m:flex-[unset]"
                >
                    Deposit
                </FloatingButton>
            </CredenzaTrigger>
            <CredenzaContent
                className="w-full md:!max-w-[659px]"
                // style={{ borderRadius: '32px' }}
                onInteractOutside={() => setIsOpen(false)}
                onEscapeKeyDown={() => setIsOpen(false)}
            >
                <PanelTitle title="SELECT A POSITION" />
                <CredenzaClose onClick={() => setIsOpen(false)} />
                <PanelContainer
                    className="!max-h-[318px] bg-[#F5F5F5] m:!max-h-[339px]"
                    alwayDisplayScroll={true}
                    scrollContentClassName={isMobile ? "p-[20px]" : "p-[22px]"}
                >
                    <div>
                        <ul className="grid min-h-[127px] grid-cols-1 gap-[15px] md:grid-cols-2 m:min-h-[89px] m:gap-[16px]">
                            {availablePositions.length > 0 ? (
                                availablePositions.map((position) => {
                                    const currentFormattedPosition = positionsData.find(
                                        (fposition) => Number(fposition.id) === Number(position.id),
                                    );
                                    if (!currentFormattedPosition) return;
                                    return (
                                        <FarmingPositionCard
                                            key={position.id}
                                            className={cn(
                                                "col-span-1 row-span-1 w-full",
                                                selectedPosition?.id === position.id
                                                    ? "[border:1px_solid_#000]"
                                                    : "",
                                            )}
                                            onClick={() => handleSelectPosition(position)}
                                            position={position}
                                            status={
                                                currentFormattedPosition.outOfRange
                                                    ? "Out of range"
                                                    : "In range"
                                            }
                                        />
                                    );
                                })
                            ) : (
                                <div className="col-span-2 flex w-full items-center justify-center text-center font-[FraktionMono-Bold] text-[14px] font-bold leading-[1] text-[#000] m:col-span-1 m:text-[12px]">
                                    You don't have available positions for this pool
                                </div>
                            )}
                        </ul>
                    </div>
                </PanelContainer>

                <PanelContainer
                    className="bt1"
                    scrollContentClassName="h-[108px] m:h-[auto] flex m:flex-col items-center px-[24px] m:p-[20px] gap-[18px] m:gap-[16px]"
                >
                    {isApproving ? (
                        <FloatingButton disabled className="w-full">
                            Checking Approval...
                        </FloatingButton>
                    ) : selectedPosition && availablePositions.length > 0 ? (
                        <>
                            <FloatingButton
                                disabled={approved || approveActionLoading}
                                className="w-1/2 m:w-full"
                                onClick={handleApprove}
                            >
                                {approved ? (
                                    <span>1. Approved</span>
                                ) : approveActionLoading ? (
                                    <Loader />
                                ) : (
                                    <span>1. Approve</span>
                                )}
                            </FloatingButton>
                            <FloatingButton
                                disabled={!approved || stakeActionLoading}
                                className="w-1/2 m:w-full"
                                onClick={handleStake}
                            >
                                {stakeActionLoading ? <Loader /> : "2. Deposit"}
                            </FloatingButton>
                        </>
                    ) : (
                        <FloatingButton disabled className="w-full">
                            Select Position
                        </FloatingButton>
                    )}
                </PanelContainer>

                <PanelFooter />
            </CredenzaContent>
        </Credenza>
    );
}



================================================
File: src/components/modals/TokenSelectorModal/index.tsx
================================================
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import { TokenSelector } from "@/components/common/TokenSelector";
import {
    Credenza,
    CredenzaClose,
    CredenzaContent,
    CredenzaTrigger,
} from "@/components/ui/credenza";
import { Currency } from "@glyph-exchange/integral-sdk";
import { memo } from "react";

interface ITokenSelectorModal {
    isOpen: boolean;
    setIsOpen: (state: boolean) => void;
    onSelect: (currency: Currency) => void;
    otherCurrency: Currency | null | undefined;
    children: React.ReactNode;
    showNativeToken?: boolean;
}

const TokenSelectorModal = ({
    isOpen,
    setIsOpen,
    onSelect,
    otherCurrency,
    children,
    showNativeToken,
}: ITokenSelectorModal) => {
    return (
        <Credenza open={isOpen}>
            <CredenzaTrigger asChild>{children}</CredenzaTrigger>
            <CredenzaContent
                onInteractOutside={() => setIsOpen(false)}
                onEscapeKeyDown={() => setIsOpen(false)}
            >
                <PanelTitle title="SELECT A TOKEN" />
                <CredenzaClose onClick={() => setIsOpen(false)} />
                <TokenSelector
                    showNativeToken={showNativeToken}
                    onSelect={onSelect}
                    otherCurrency={otherCurrency}
                />
                <PanelFooter />
            </CredenzaContent>
        </Credenza>
    );
};

export default memo(TokenSelectorModal);



================================================
File: src/components/pool/FilterPopover/index.tsx
================================================
import { Switch } from "@/components/ui/switch";
import { Popover, PopoverTrigger, PopoverContent } from "@/components/ui/popover";
import React, { useCallback, useState } from "react";
import { PositionsStatus } from "@/types/position-filter-status";
import { usePositionFilterStore } from "@/state/positionFilterStore";
import tw, { styled, theme } from "twin.macro";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { useMintState } from "@/state/mintStore";
import { PositionManager } from "@/types/position-state";

const _PoolPopoverContent = styled(PopoverContent)`
    border: 1px solid #000;

    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 14px;
    font-style: normal;
    font-weight: 700;
    line-height: 1;
    padding: unset;

    ${() => tw`w-[205px] rounded-[2px] bg-[#FFF] shadow-[unset]`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 12px;
    }
`;

const _PopoverContentLabelBox = styled.div`
    padding: 8px 16px 10px;
    border-bottom: 1px dashed #000;

    &:last-child {
        border-bottom: unset;
    }

    ${() => tw`flex w-full items-center justify-between`}
`;

const FilterPopover = ({
    children,
    changeStatus,
    popoverTriggerClassName,
}: {
    children: React.ReactNode;
    changeStatus?: (open: boolean) => void;
    popoverTriggerClassName?: string;
}) => {
    const isMobile = useMediaQuery("mobile");
    const [isOpen, setIsOpen] = useState<boolean>(false);
    const {
        filterStatus,
        actions: { setFilterStatus },
    } = usePositionFilterStore();

    const { positionManager } = useMintState();

    const OpenChange = useCallback(
        (open: boolean) => {
            setIsOpen(open);
            changeStatus && changeStatus(open);
        },
        [changeStatus],
    );

    return (
        <Popover open={isOpen} onOpenChange={OpenChange}>
            <PopoverTrigger asChild>
                <div
                    className={`h-fit w-fit cursor-pointer ${isOpen && "!bg-[#000]"} ${popoverTriggerClassName}`}
                >
                    {children}
                </div>
                {/* <Button
                    variant={'ghost'}
                    size={'md'}
                    className={cn(
                        'bg-transparent border border-card-border/60',
                        isOpen && 'bg-card'
                    )}
                    aria-label="Update dimensions"
                >
                    {children}
                </Button> */}
            </PopoverTrigger>
            <_PoolPopoverContent sideOffset={isMobile ? 12 : 5} align={isMobile ? "start" : "end"}>
                <div className="flex flex-col items-start">
                    {positionManager !== PositionManager.GAMMA && (
                        <>
                            <_PopoverContentLabelBox>
                                Open
                                <Switch
                                    id="Open"
                                    checked={Boolean(filterStatus[PositionsStatus.OPEN])}
                                    onCheckedChange={() => setFilterStatus(PositionsStatus.OPEN)}
                                />
                            </_PopoverContentLabelBox>
                            <_PopoverContentLabelBox>
                                On Farming
                                <Switch
                                    id="On Farming"
                                    checked={Boolean(filterStatus[PositionsStatus.ON_FARMING])}
                                    onCheckedChange={() =>
                                        setFilterStatus(PositionsStatus.ON_FARMING)
                                    }
                                />
                            </_PopoverContentLabelBox>
                            <_PopoverContentLabelBox>
                                Closed
                                <Switch
                                    id="Closed"
                                    checked={Boolean(filterStatus[PositionsStatus.CLOSED])}
                                    onCheckedChange={() => setFilterStatus(PositionsStatus.CLOSED)}
                                />
                            </_PopoverContentLabelBox>
                        </>
                    )}

                    {positionManager === PositionManager.GAMMA && (
                        <_PopoverContentLabelBox>
                            On Gamma
                            <Switch
                                id="On Gamma"
                                checked={Boolean(filterStatus[PositionsStatus.ON_GAMMA])}
                                onCheckedChange={() => setFilterStatus(PositionsStatus.ON_GAMMA)}
                            />
                        </_PopoverContentLabelBox>
                    )}
                </div>
            </_PoolPopoverContent>
        </Popover>
    );
};

export default FilterPopover;



================================================
File: src/components/pool/MyPositions/index.tsx
================================================
import { myPositionsColumns } from "@/components/common/Table/myPositionsColumns";
import { Address } from "wagmi";
import { FormattedPosition } from "@/types/formatted-position";
import MyPositionsTable from "@/components/common/Table/myPositionsTable";

interface MyPositionsProps {
    positions: FormattedPosition[];
    poolId: Address | undefined;
    selectedPosition: number | undefined;
    selectPosition: (positionId: number | null) => void;
}

const MyPositions = ({ positions, selectedPosition, selectPosition }: MyPositionsProps) => {
    return (
        <div className="flex min-h-[297px] w-full flex-col [border-top:1px_solid_#000] m:max-h-[275px] m:min-h-[275px]">
            <MyPositionsTable
                defaultSortingID="liquidityUSD"
                columns={myPositionsColumns}
                data={positions}
                action={selectPosition}
                selectedRow={selectedPosition}
                showPagination={false}
            />
        </div>
    );
};

export default MyPositions;



================================================
File: src/components/pool/MyPositionsToolbar/index.tsx
================================================
import { FormattedPosition } from "@/types/formatted-position";
import { formatUSD } from "@/utils/common/formatUSD";
import { Link } from "react-router-dom";
import { Address } from "viem";
import FilterPopover from "../FilterPopover";
import tw, { styled, theme } from "twin.macro";
import Image from "@/components/common/Image";
import { useState } from "react";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { PositionManager } from "@/types/position-state";
import { useMintState } from "@/state/mintStore";

const _MyPositionsToolbar = styled.div`
    padding: 20px 23px 17px;
    border-bottom: 1px solid #000;
    ${() => tw`mb-[3px] flex w-full flex-row items-center justify-between m:flex-col`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        padding: 27px 20px 14px;
        border-bottom: unset;
        ${() => tw`mb-[unset] items-start`}
    }
`;

const _LabelStyle = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 10px;
    font-weight: 400;
    line-height: 120%;

    > .value {
        font-family: FraktionMono-Bold;
        font-size: 14px;
        font-weight: 700;
    }

    ${() => tw`flex flex-col items-start gap-[10px]`}
`;

const _CreatePositionBtn = styled.div`
    border-radius: 6px;
    border: 1px solid #000;
    background: #000;
    display: inline-flex;
    padding: 0 16px;
    justify-content: center;
    align-items: center;
    cursor: pointer;

    color: #fff;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 35px;
    ${() => tw``}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 12px;
        padding: 0 12px;
        line-height: 31px;
        box-sizing: border-box;
    }
`;

interface MyPositionsToolbar {
    positionsData: FormattedPosition[];
    poolId: Address;
}

const MyPositionsToolbar = ({ positionsData, poolId }: MyPositionsToolbar) => {
    const isMobile = useMediaQuery("mobile");
    const { positionManager } = useMintState();
    const [myLiquidityUSD, myFeesUSD] = positionsData
        ? positionsData.reduce(
              (acc, { liquidityUSD, feesUSD }) => [acc[0] + liquidityUSD, acc[1] + feesUSD],
              [0, 0],
          )
        : [];
    const [isFilterPopoverOpen, setIsFilterPopoverOpen] = useState<boolean>(false);

    return (
        <div className="flex w-full flex-col items-center bg-[#F5F5F5]">
            <_MyPositionsToolbar>
                <div className="flex flex-wrap items-center gap-[33px]">
                    <_LabelStyle>
                        <span>Position</span>
                        <span className="value">{positionsData?.length}</span>
                    </_LabelStyle>

                    <_LabelStyle>
                        <span>TVL</span>
                        <span className="value">{`${formatUSD.format(myLiquidityUSD || 0)}`}</span>
                    </_LabelStyle>

                    {positionManager !== PositionManager.GAMMA && (
                        <_LabelStyle>
                            <span>Fees</span>
                            <span className="value !text-[#F7931A]">{`${formatUSD.format(
                                myFeesUSD || 0,
                            )}`}</span>
                        </_LabelStyle>
                    )}
                </div>
                <div className="flex items-center gap-[12px] m:mt-[12px] m:w-full">
                    <FilterPopover
                        changeStatus={setIsFilterPopoverOpen}
                        popoverTriggerClassName={
                            "!w-[34px] !h-[34px] m:!w-[33px] m:!h-[33px] rounded-[2px] m:rounded-[6px]"
                        }
                    >
                        {!isFilterPopoverOpen && (
                            <Image
                                width={isMobile ? 33 : 34}
                                height={isMobile ? 33 : 34}
                                src={
                                    isMobile
                                        ? "/my_position_selector_mobile_icon.svg"
                                        : "/my_position_selector_icon.svg"
                                }
                            ></Image>
                        )}
                        {isFilterPopoverOpen && (
                            <Image
                                width={isMobile ? 33 : 34}
                                height={isMobile ? 33 : 34}
                                src={
                                    isMobile
                                        ? "/my_position_selector_mobile_icon_black.svg"
                                        : "/my_position_selector_icon_black.svg"
                                }
                            ></Image>
                        )}
                        {/* <SlidersHorizontal size={20} /> */}
                    </FilterPopover>

                    <Link to={`/pool/${poolId}/new-position`}>
                        <_CreatePositionBtn>Create Position</_CreatePositionBtn>
                    </Link>
                </div>
            </_MyPositionsToolbar>
            {isMobile && <div className="mb-[3px] h-[1px] w-[calc(100%-8px)] bg-[#000]"></div>}
        </div>
    );
};

export default MyPositionsToolbar;



================================================
File: src/components/pool/PoolHeader/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import FloatingButton from "@/components/common/FloatingButton";
import Image from "@/components/common/Image";
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import { Skeleton } from "@/components/ui/skeleton";
import { useCurrency } from "@/hooks/common/useCurrency";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { useExplorer } from "@/hooks/common/useWeb3";
import { formatPercent } from "@/utils/common/formatPercent";
import { Pool } from "@glyph-exchange/integral-sdk";
import { useNavigate } from "react-router-dom";
import tw, { styled } from "twin.macro";
import { theme } from "twin.macro";
import { Address } from "viem";

const _BackBtn = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-weight: 700;
    line-height: 1;
    ${() => tw`flex cursor-pointer items-center gap-[10px]`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 12px;
        ${() => tw`gap-[8px]`}
    }
`;

const _PoolFeeBox = styled.div`
    border-radius: 4px;
    background: #000;
    display: flex;
    padding: 0 4px;
    justify-content: center;
    align-items: center;

    color: #fff;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 17px;

    ${() => tw`mx-[8px] shrink-0`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 8px;
        line-height: 14px;
    }
`;

const _TokenSymbolType = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 24px;
    font-weight: 700;
    line-height: 1.2;

    ${() => tw`truncate`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        margin-left: 8px;
        font-size: 16px;
    }
`;

interface PoolHeaderProps {
    pool: Pool | null;
    poolAddress?: string;
}

const PoolHeader = ({ pool, poolAddress }: PoolHeaderProps) => {
    const isMobile = useMediaQuery("mobile");
    const [token0, token1] = pool ? [pool.token0, pool.token1] : [];

    const currencyA = useCurrency(token0?.address as Address, true);
    const currencyB = useCurrency(token1?.address as Address, true);

    const poolFee = pool && formatPercent.format(pool.fee / 10_00000);
    const { toAddress } = useExplorer();
    const navigate = useNavigate();

    return (
        <PanelBase className="flex w-full">
            <PanelTitle title="POOL DETAIL" />
            <div className="flex w-full flex-col items-start gap-[19px] [padding:24px_24px_26px_24px] m:[padding:16px_20px_16px_20px]">
                <_BackBtn onClick={() => navigate(`/pools`)}>
                    <Image
                        width={isMobile ? 16 : 20}
                        height={isMobile ? 16 : 20}
                        src="/icon_left_arrow_black.svg"
                    ></Image>
                    Back
                </_BackBtn>
                <div className="flex w-full items-center justify-between">
                    <div className="flex min-w-[0] items-center">
                        <div className="flex w-[72px] shrink-0 items-center m:w-[40px]">
                            <CurrencyLogo currency={currencyA} size={isMobile ? 24 : 36} />
                            <CurrencyLogo
                                currency={currencyB}
                                size={isMobile ? 24 : 36}
                                className="-ml-2"
                            />
                        </div>

                        {currencyA && currencyB ? (
                            <>
                                <_TokenSymbolType>{`${currencyA.symbol}-${currencyB.symbol}`}</_TokenSymbolType>
                                <_PoolFeeBox>{`${poolFee}`}</_PoolFeeBox>
                            </>
                        ) : (
                            <Skeleton className="h-[40px] w-[200px] bg-[#999] m:ml-[8px] m:h-[24px] m:w-[100px]" />
                        )}
                    </div>

                    <FloatingButton
                        type="small"
                        width="24px"
                        height="24px"
                        innerStyle={{ padding: "3px" }}
                        onClick={() => {
                            poolAddress && toAddress(poolAddress);
                        }}
                        className="shrink-0"
                    >
                        <Image width={18} src="/link.svg" alt="" />
                    </FloatingButton>
                </div>
            </div>
        </PanelBase>
    );
};

export default PoolHeader;



================================================
File: src/components/pools/PoolsList/blacklistPools.ts
================================================
import { Environment } from "@/types/common";

const VITE_ENVIRONMENT =
    import.meta.env?.VITE_ENVIRONMENT ?? process.env?.VITE_ENVIRONMENT ?? Environment.PROD;

const BLACKLIST_POOLS_ENV: BlacklistPoolsEnv = {
    [Environment.PROD]: [
        "0x240c340b3e098c445af4aeade78d901b6e4b56eb", // CORE-GP
        "0xa28403c7afc7ec4743b9fd7198faa532e11e814a", // CORE-dualCORE-LP-points
        "0xa58eb27f080b834c8ff624f7edd152b348c00071", // CORE-vltCORE
        // "0x33a1d3b3cde14047d8675789c093bb68d260a3bc", // aBTC-COREBTC
        // "0xf5797f7701dbc003e44c66756edabf84471fd580", // aBTC-BTCB
        // "0x3126457f085226707b8e8bde1f8cc0f9a2c44b82", // CORE-aBTC
        // "0x6f4fd16ae2d1cb1788e2feae1ddc169e81dd593b", // aBTC-PT-dualBTC
    ],
    [Environment.DEV]: ["0x843f351694bd097db124ba751cb688acf7c3aaeb"],
};

export const BLACKLIST_POOLS = BLACKLIST_POOLS_ENV[VITE_ENVIRONMENT];



================================================
File: src/components/pools/PoolsList/index.tsx
================================================
import { poolsColumns } from "@/components/common/Table/poolsColumns";
import { useActiveFarmingsQuery, usePoolsListQuery } from "@/graphql/generated/graphql";
import { useMemo } from "react";
import { Address } from "viem";
import { ETERNAL_FARMINGS_API, POOL_AVG_APR_API, POOL_MAX_APR_API, fetcher } from "@/constants/api";
import useSWR from "swr";
import PoolsTable from "@/components/common/Table/poolsTable";
import { usePositions } from "@/hooks/positions/usePositions";
import { farmingClient } from "@/graphql/clients";
import { BLACKLIST_POOLS } from "./blacklistPools";
import { useGammaUserData, useHypervisorsData } from "@/hooks/common/useGamma";
import { CORE_IGNITION_POOLS, RAINBOW_POOLS } from "./pluginPools";
import { useAccount } from "wagmi";

const PoolsList = () => {
    const { address: account } = useAccount();
    const { data: pools, loading: isPoolsListLoading } = usePoolsListQuery();

    const { data: activeFarmings, loading: isFarmingsLoading } = useActiveFarmingsQuery({
        client: farmingClient,
    });
    const { positions, loading: isPositionsLoading } = usePositions();
    const { data: userData } = useGammaUserData(account, !!account);

    // const { data: poolsMaxApr, isLoading: isPoolsMaxAprLoading } = useSWR(
    //     POOL_MAX_APR_API,
    //     fetcher,
    // );
    const { data: poolsAvgApr, isLoading: isPoolsAvgAprLoading } = useSWR(
        POOL_AVG_APR_API,
        fetcher,
    );
    const { data: farmingsAPR, isLoading: isFarmingsAPRLoading } = useSWR(
        ETERNAL_FARMINGS_API,
        fetcher,
    );

    const { data: hypervisors } = useHypervisorsData(true);

    const isLoading =
        isPoolsListLoading ||
        // isPoolsMaxAprLoading ||
        isPoolsAvgAprLoading ||
        isPositionsLoading ||
        isFarmingsLoading ||
        isFarmingsAPRLoading;

    const formattedPools = useMemo(() => {
        if (isLoading || !pools) return [];

        let allPools = pools.pools
            .map(({ id, token0, token1, fee, totalValueLockedUSD, poolDayData }) => {
                const currentPool = poolDayData[0];
                const lastDate = currentPool ? currentPool.date * 1000 : 0;
                const currentDate = new Date().getTime();

                /* time difference calculations here to ensure that the graph provides information for the last 24 hours */
                const timeDifference = currentDate - lastDate;
                const msIn24Hours = 24 * 60 * 60 * 1000;

                const openPositions = positions?.filter(
                    (position) => position.pool.toLowerCase() === id.toLowerCase(),
                );
                const activeFarming = activeFarmings?.eternalFarmings.find(
                    (farming) => farming.pool === id,
                );

                // const poolMaxApr =
                //     poolsMaxApr && poolsMaxApr[id] ? Number(poolsMaxApr[id].toFixed(2)) : 0;
                const poolAvgApr =
                    poolsAvgApr && poolsAvgApr[id] ? Number(poolsAvgApr[id].toFixed(2)) : 0;
                const farmApr =
                    activeFarming && farmingsAPR && farmingsAPR[activeFarming.id] > 0
                        ? farmingsAPR[activeFarming.id]
                        : 0;

                const avgApr = farmApr + poolAvgApr;

                const isRainBow = RAINBOW_POOLS.includes(id.toLowerCase() as Address);
                const isCoreIgnition = CORE_IGNITION_POOLS.includes(id.toLowerCase() as Address);

                return {
                    id: id as Address,
                    associatePool: id as Address,
                    pair: {
                        token0,
                        token1,
                    },
                    fee: Number(fee) / 10_000,
                    tvlUSD: Number(totalValueLockedUSD),
                    volume24USD: timeDifference <= msIn24Hours ? currentPool.volumeUSD : 0,
                    fees24USD: timeDifference <= msIn24Hours ? currentPool.feesUSD : 0,
                    poolMaxApr: 0,
                    poolAvgApr,
                    farmApr,
                    avgApr,
                    isMyPool: Boolean(openPositions?.length),
                    hasActiveFarming: Boolean(activeFarming),
                    isGamma: false,
                    isRainBow,
                    isCoreIgnition,
                };
            })
            .filter(({ id }) => !BLACKLIST_POOLS.includes(id.toLowerCase() as Address));

        if (hypervisors) {
            let currUserData = undefined;
            if (account && userData) {
                currUserData = userData[account.toLowerCase()];
            }

            const gammaPools = Object.entries(hypervisors)
                .map(([poolAddress, item]) => {
                    const avgApr = Number((item.returns.allTime.feeApr * 100).toFixed(2));
                    const token0Addr = item.token0.toLowerCase();
                    const token1Addr = item.token1.toLowerCase();

                    const matchedItem = allPools.find(
                        (item) =>
                            item.pair.token0.id === token0Addr &&
                            item.pair.token1.id === token1Addr,
                    );

                    if (!matchedItem) return null;

                    let curUserPositionData;
                    if (currUserData) {
                        curUserPositionData = currUserData[poolAddress as Address];
                    }

                    return {
                        id: poolAddress as Address,
                        associatePool: matchedItem.id,
                        pair: matchedItem.pair,
                        fee: matchedItem.fee,
                        tvlUSD: Number(item.tvlUSD),
                        volume24USD: 0,
                        fees24USD: 0,
                        poolMaxApr: 0,
                        poolAvgApr: avgApr,
                        farmApr: 0,
                        avgApr,
                        isMyPool: curUserPositionData?.shares ? true : false,
                        hasActiveFarming: false,
                        isGamma: true,
                        isRainBow: matchedItem.isRainBow,
                        isCoreIgnition: matchedItem.isCoreIgnition,
                    };
                })
                .filter((item): item is NonNullable<typeof item> => item !== null);

            if (gammaPools?.length) {
                allPools = [...gammaPools, ...allPools];
            }

            allPools = allPools.sort((a, b) => {
                // if (a.isGamma) return -1;
                // if (b.isGamma) return 1;
                return b.tvlUSD - a.tvlUSD;
            });
        }
        return allPools;
    }, [
        isLoading,
        pools,
        hypervisors,
        positions,
        activeFarmings,
        poolsAvgApr,
        farmingsAPR,
        userData,
        account,
        // poolMaxApr
    ]);

    return (
        <div className="flex flex-col">
            <PoolsTable
                columns={poolsColumns}
                data={formattedPools}
                // defaultSortingID={"tvlUSD"}
                link={"pool"}
                showPagination={true}
                loading={isLoading}
            />
        </div>
    );
};

export default PoolsList;



================================================
File: src/components/pools/PoolsList/pluginPools.ts
================================================
import { Environment } from "@/types/common";

const VITE_ENVIRONMENT =
    import.meta.env?.VITE_ENVIRONMENT ?? process.env?.VITE_ENVIRONMENT ?? Environment.PROD;

const RAINBOW_POOLS_ENV: PluginPoolsEnv = {
    [Environment.PROD]: [],
    [Environment.DEV]: [],
};

const CORE_IGNITION_POOLS_ENV: PluginPoolsEnv = {
    [Environment.PROD]: [
        "0x396895a08dfec54dc5773a14a7f0888c4e1a11b6", //CORE-USDT
        "0xd8f1c33d35cb471681385598d456d49c56ed2d51", //USDT-USDC
        "0x574bb920e7b70b9ba793b8db9b88d58d9a671c82", //CORE-COLEND
        "0xa7e8685727df3cdb40927e817c8b7ce6e91c56bb", //CORE-stCORE
        "0x6e8968558f45937df63106ad23a7203eb1c6ddc2", //stCORE-USDT
    ],
    [Environment.DEV]: [],
};

export const RAINBOW_POOLS = RAINBOW_POOLS_ENV[VITE_ENVIRONMENT];
export const CORE_IGNITION_POOLS = CORE_IGNITION_POOLS_ENV[VITE_ENVIRONMENT];



================================================
File: src/components/position/ActiveFarmingCard/index.tsx
================================================
import { useEffect, useState } from "react";
import { Farming } from "@/types/farming-info";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import { useFarmHarvest } from "@/hooks/farming/useFarmHarvest";
import { useFarmUnstake } from "@/hooks/farming/useFarmStake";
import { useAccount } from "wagmi";
import { getFarmingRewards } from "@/utils/farming/getFarmingRewards";
import { Button2 } from "@/components/ui/button";
import Loader from "@/components/common/Loader";
import { Deposit } from "@/graphql/generated/graphql";
import { useRewardEarnedUSD } from "@/hooks/farming/useRewardEarnedUSD";
import tw, { styled } from "twin.macro";
import FloatingButton from "@/components/common/FloatingButton";

interface ActiveFarmingCardProps {
    farming: Farming;
    selectedPosition: Deposit;
}

const _ActiveFarmingCard = styled.div`
    ${() => tw`flex flex-col`}
`;

const _InfoReact = styled.div`
    padding: 18px 24px;

    ${() => tw`flex w-full items-center justify-between bg-[#F2E9FF] by1`}
`;

const _Label = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-transform: uppercase;

    ${() => tw`text-left m:text-[10px]`}
`;

const _Value = styled.div`
    color: #9747ff;
    font-family: FraktionMono-Bold;
    font-size: 28px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw`w-full truncate text-left m:text-[16px]`}
`;

const ActiveFarmingCard = ({ farming, selectedPosition }: ActiveFarmingCardProps) => {
    const { address: account } = useAccount();

    const [rewardEarned, setRewardEarned] = useState<bigint>(0n);
    const [bonusRewardEarned, setBonusRewardEarned] = useState<bigint>(0n);

    const rewardEarnedUSD = useRewardEarnedUSD({
        token: farming.rewardToken,
        reward: rewardEarned,
    });

    const bonusRewardEarnedUSD = useRewardEarnedUSD({
        token: farming.bonusRewardToken,
        reward: bonusRewardEarned,
    });

    const farmingRewards = (rewardEarnedUSD + bonusRewardEarnedUSD).toFixed(4);

    const farmingArgs = {
        tokenId: BigInt(selectedPosition.id),
        rewardToken: farming.farming.rewardToken,
        bonusRewardToken: farming.farming.bonusRewardToken,
        pool: farming.farming.pool,
        nonce: farming.farming.nonce,
        account: account ?? ADDRESS_ZERO,
    };

    const {
        onHarvest,
        isLoading: isHarvesting,
        isSuccess: isHarvested,
    } = useFarmHarvest(farmingArgs);

    const { onUnstake, isLoading: isUnstaking } = useFarmUnstake(farmingArgs);

    const handleUnstake = async () => {
        if (!account) return;
        if (!onUnstake) return;
        onUnstake();
    };

    const handleHarvest = async () => {
        if (!account) return;
        if (!onHarvest) return;
        onHarvest();
    };

    useEffect(() => {
        if (!account) return;
        getFarmingRewards(farmingArgs).then((rewards) => {
            setRewardEarned(rewards.reward);
            setBonusRewardEarned(rewards.bonusReward);
        });
    }, [farming, account, selectedPosition, isHarvested]);

    return (
        <_ActiveFarmingCard>
            <_InfoReact>
                <div className="text-left">
                    <_Label>EARNED REWARDS</_Label>
                    <_Value className="m:mt-[6px]">
                        <span>${farmingRewards}</span>
                    </_Value>
                </div>
                <Button2 disabled={isHarvesting || isUnstaking} onClick={handleHarvest}>
                    {isHarvesting ? <Loader /> : "Collect"}
                </Button2>
            </_InfoReact>
            <div className="p-[28px_24px_36px] m:p-[20px_20px_28px]">
                <FloatingButton onClick={handleUnstake} disabled={isUnstaking || isHarvesting}>
                    {isUnstaking ? <Loader /> : "Exit From Farming"}
                </FloatingButton>
            </div>
        </_ActiveFarmingCard>
    );
};

export default ActiveFarmingCard;



================================================
File: src/components/position/ClosedFarmingCard/index.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import { EternalFarming } from "@/graphql/generated/graphql";
import { useFarmUnstake } from "@/hooks/farming/useFarmStake";
import { FormattedPosition } from "@/types/formatted-position";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import { useAccount } from "wagmi";

interface ClosedFarmingCardProps {
    positionInEndedFarming: EternalFarming;
    selectedPosition: FormattedPosition;
    className?: string;
}

const ClosedFarmingCard = ({
    positionInEndedFarming,
    selectedPosition,
    className,
}: ClosedFarmingCardProps) => {
    const { address: account } = useAccount();

    const farmingArgs = {
        tokenId: BigInt(selectedPosition.id ?? 0),
        rewardToken: positionInEndedFarming.rewardToken,
        bonusRewardToken: positionInEndedFarming.bonusRewardToken,
        pool: positionInEndedFarming.pool,
        nonce: positionInEndedFarming.nonce,
        account: account ?? ADDRESS_ZERO,
    };

    const { onUnstake, isLoading: isUnstaking } = useFarmUnstake(farmingArgs);

    return (
        <FloatingButton className={className} disabled={isUnstaking} onClick={onUnstake}>
            {isUnstaking ? <Loader /> : "Exit From Farming"}
        </FloatingButton>
    );
};

export default ClosedFarmingCard;



================================================
File: src/components/position/CollectFees/index.tsx
================================================
import Loader from "@/components/common/Loader";
import { Button2 } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { usePrepareAlgebraPositionManagerMulticall } from "@/generated";
import { useTransactionAwait } from "@/hooks/common/useTransactionAwait";
import { usePositionFees } from "@/hooks/positions/usePositionFees";
import { IDerivedMintInfo } from "@/state/mintStore";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { NonfungiblePositionManager } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import tw, { styled } from "twin.macro";
import { Address, useAccount, useContractWrite } from "wagmi";

interface CollectFeesProps {
    mintInfo: IDerivedMintInfo;
    positionFeesUSD: string | undefined;
    positionId: number;
}

const _CollectFees = styled.div`
    padding: 18px 24px;
    ${() => tw`flex w-full items-center justify-between bg-[#FFEBCE] by1`}
`;

const _Label = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-transform: uppercase;

    ${() => tw`text-left m:text-[10px]`}
`;

const _Value = styled.div`
    color: #f7931a;
    font-family: FraktionMono-Bold;
    font-size: 28px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw`w-full truncate text-left m:text-[16px]`}
`;

const CollectFees = ({ mintInfo, positionFeesUSD, positionId }: CollectFeesProps) => {
    const { address: account } = useAccount();

    const pool = mintInfo.pool;

    const { amount0, amount1 } = usePositionFees(pool ?? undefined, positionId, false);

    const zeroRewards = amount0?.equalTo("0") && amount1?.equalTo("0");

    const { calldata, value } = useMemo(() => {
        if (!account || !amount0 || !amount1) return { calldata: undefined, value: undefined };

        return NonfungiblePositionManager.collectCallParameters({
            tokenId: positionId.toString(),
            expectedCurrencyOwed0: amount0,
            expectedCurrencyOwed1: amount1,
            recipient: account,
        });
    }, [positionId, amount0, amount1, account]);

    const { config: collectConfig } = usePrepareAlgebraPositionManagerMulticall({
        args: calldata && [calldata as `0x${string}`[]],
        value: BigInt(value || 0),
    });

    const {
        data: collectData,
        write: collect,
        isLoading: isConfirmLoading,
    } = useContractWrite(collectConfig);

    const { isLoading } = useTransactionAwait(collectData?.hash, {
        title: "Collect fees",
        tokenA: mintInfo.currencies.CURRENCY_A?.wrapped.address as Address,
        tokenB: mintInfo.currencies.CURRENCY_B?.wrapped.address as Address,
        type: TransactionType.POOL,
    });

    const collectedFees = positionFeesUSD === "$0" && !zeroRewards ? "< $0.001" : positionFeesUSD;

    return (
        <_CollectFees>
            <div className="min-w-0">
                <_Label>EARNED FEES</_Label>
                <_Value className="m:mt-[6px]">
                    {collectedFees ? (
                        <span>{collectedFees}</span>
                    ) : (
                        <Skeleton className="h-[30px] w-[100px] m:h-[19px] m:w-full" />
                    )}
                </_Value>
            </div>
            <Button2
                disabled={!collect || zeroRewards || isLoading || isConfirmLoading}
                onClick={() => collect && collect()}
            >
                {isLoading || isConfirmLoading ? <Loader /> : "Collect Fees"}
            </Button2>
        </_CollectFees>
    );
};

export default CollectFees;



================================================
File: src/components/position/IncreaseLiquidityButton/index.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import { ALGEBRA_POSITION_MANAGER } from "@/constants/addresses";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import {
    useGammaUniProxyDeposit,
    usePrepareAlgebraPositionManagerMulticall,
    usePrepareGammaUniProxyDeposit,
} from "@/generated";
import { useApprove } from "@/hooks/common/useApprove";
import { useTransactionAwait } from "@/hooks/common/useTransactionAwait";
import { usePosition, usePositions, useUserGammaPositions } from "@/hooks/positions/usePositions";
import { IDerivedMintInfo } from "@/state/mintStore";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { useUserState } from "@/state/userStore";
import { ApprovalState } from "@/types/approve-state";
import {
    Currency,
    Field,
    NonfungiblePositionManager,
    Percent,
    ZERO,
} from "@glyph-exchange/integral-sdk";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import JSBI from "jsbi";
import { useCallback, useEffect, useMemo, useState } from "react";
import { Address, useAccount, useContractWrite } from "wagmi";
import { waitForTransaction } from "@wagmi/core";
import { useParams } from "react-router-dom";
import { PositionManager } from "@/types/position-state";
import { WrapState } from "@/types/gamma-state";
import { useNativeWrap } from "@/hooks/common/useGamma";

interface IncreaseLiquidityButtonProps {
    baseCurrency: Currency | undefined | null;
    quoteCurrency: Currency | undefined | null;
    mintInfo: IDerivedMintInfo;
    tokenId?: number;
    handleCloseModal?: () => void;
}

const ZERO_PERCENT = new Percent("0");
const DEFAULT_ADD_IN_RANGE_SLIPPAGE_TOLERANCE = new Percent(50, 10_000);

export const IncreaseLiquidityButton = ({
    mintInfo,
    tokenId,
    baseCurrency,
    quoteCurrency,
    handleCloseModal,
}: IncreaseLiquidityButtonProps) => {
    const { pool: poolAddress } = useParams<{ pool: Address }>();

    const { address: account } = useAccount();

    const { open } = useWeb3Modal();

    const { selectedNetworkId } = useWeb3ModalState();

    const { txDeadline } = useUserState();

    const { refetch: refetchAllPositions } = usePositions(
        mintInfo.positionManager === PositionManager.ALGEBRA,
    );

    const { refetch: refetchPosition } = usePosition(tokenId);

    const { refetch: refetchGammaAllPositions } = useUserGammaPositions(
        mintInfo.positionManager === PositionManager.GAMMA,
    );

    const [startIncrease, setStartIncrease] = useState(false);

    const useNative = baseCurrency?.isNative
        ? baseCurrency
        : quoteCurrency?.isNative
          ? quoteCurrency
          : undefined;

    /* const nativeCurrency = mintInfo.parsedAmounts[Field.CURRENCY_A]?.currency.isNative
        ? mintInfo.parsedAmounts[Field.CURRENCY_A]
        : mintInfo.parsedAmounts[Field.CURRENCY_B]?.currency.isNative
          ? mintInfo.parsedAmounts[Field.CURRENCY_B]
          : undefined; */

    const { calldata: algebraCallData, value } = useMemo(() => {
        if (!account || !mintInfo.position || JSBI.EQ(mintInfo.position.liquidity, ZERO))
            return { calldata: undefined, value: undefined };

        return NonfungiblePositionManager.addCallParameters(mintInfo.position, {
            tokenId: tokenId || 0,
            slippageTolerance: mintInfo.outOfRange
                ? ZERO_PERCENT
                : DEFAULT_ADD_IN_RANGE_SLIPPAGE_TOLERANCE,
            deadline: Date.now() + txDeadline,
            useNative,
        });
    }, [mintInfo, account, tokenId, txDeadline, useNative]);

    const spender = useMemo(
        () =>
            (mintInfo.positionManager === PositionManager.GAMMA
                ? poolAddress // NOT GAMMA_UNIPROXY
                : ALGEBRA_POSITION_MANAGER) as Address,
        [poolAddress, mintInfo.positionManager],
    );

    const { approvalState: approvalStateA, approvalCallback: approvalCallbackA } = useApprove(
        mintInfo.parsedAmounts[Field.CURRENCY_A],
        spender,
    );
    const { approvalState: approvalStateB, approvalCallback: approvalCallbackB } = useApprove(
        mintInfo.parsedAmounts[Field.CURRENCY_B],
        spender,
    );

    /* const { wrapState, wrapCallback } = useNativeWrap(
        nativeCurrency,
        mintInfo.positionManager === PositionManager.GAMMA,
    ); */

    const showApproveA =
        approvalStateA === ApprovalState.NOT_APPROVED || approvalStateA === ApprovalState.PENDING;

    const showApproveB =
        approvalStateB === ApprovalState.NOT_APPROVED || approvalStateB === ApprovalState.PENDING;

    // const showWrap = wrapState === WrapState.NOT_WRAPPED || wrapState === WrapState.PENDING;

    const isReady = useMemo(() => {
        const condition =
            (mintInfo.depositADisabled ? true : approvalStateA === ApprovalState.APPROVED) &&
            (mintInfo.depositBDisabled ? true : approvalStateB === ApprovalState.APPROVED) &&
            !mintInfo.errorMessage &&
            !mintInfo.invalidRange;

        return Boolean(
            /* mintInfo.positionManager === PositionManager.GAMMA
                ? wrapState === WrapState.WRAPPED && condition
                :  */ condition,
        );
    }, [mintInfo, approvalStateA, approvalStateB /* , wrapState */]);

    const { config: algebraConfig } = usePrepareAlgebraPositionManagerMulticall({
        args: algebraCallData && [algebraCallData as `0x${string}`[]],
        value: BigInt(value || 0),
        enabled:
            mintInfo.positionManager === PositionManager.ALGEBRA &&
            Boolean(algebraCallData && isReady && tokenId),
    });

    const {
        data: algebraData,
        write: algebraIncrease,
        isLoading: algebraConfirmLoading,
    } = useContractWrite(algebraConfig);

    const gammaCallData = useMemo(() => {
        const amountA = mintInfo.parsedAmounts[Field.CURRENCY_A]?.numerator.toString();
        const amountB = mintInfo.parsedAmounts[Field.CURRENCY_B]?.numerator.toString();

        if (amountA && amountB && account && poolAddress) {
            return [
                BigInt(amountA),
                BigInt(amountB),
                account,
                poolAddress,
                [0n, 0n, 0n, 0n],
            ] as const;
        }
        return undefined;
    }, [mintInfo, account, poolAddress]);

    const { config: gammaConfig } = usePrepareGammaUniProxyDeposit({
        args: gammaCallData,
        enabled:
            mintInfo.positionManager === PositionManager.GAMMA && Boolean(gammaCallData && isReady),
    });

    const {
        data: gammaData,
        write: gammaIncrease,
        isLoading: gammaConfirmLoading,
    } = useGammaUniProxyDeposit(gammaConfig);

    const increaseLiquidityData = useMemo(
        () => (mintInfo.positionManager === PositionManager.GAMMA ? gammaData : algebraData),
        [mintInfo.positionManager, gammaData, algebraData],
    );

    const [increaseLiquidity, callable] = useMemo(
        () =>
            mintInfo.positionManager === PositionManager.GAMMA
                ? [gammaIncrease, !!gammaConfig.request]
                : [algebraIncrease, true], // !!algebraConfig.request realtime update
        [
            mintInfo.positionManager,
            gammaIncrease,
            gammaConfig.request,
            algebraIncrease,
            // algebraConfig.request,
        ],
    );

    const isConfirmLoading = useMemo(
        () =>
            mintInfo.positionManager === PositionManager.GAMMA
                ? gammaConfirmLoading
                : algebraConfirmLoading,
        [mintInfo.positionManager, gammaConfirmLoading, algebraConfirmLoading],
    );

    const { isLoading: isIncreaseLiquidityLoading, isSuccess } = useTransactionAwait(
        increaseLiquidityData?.hash,
        {
            title: `Add Liquidity to #${tokenId}`,
            tokenA: baseCurrency?.wrapped.address as Address,
            tokenB: quoteCurrency?.wrapped.address as Address,
            type: TransactionType.POOL,
        },
    );

    useEffect(() => {
        if (!isSuccess) return;
        if (mintInfo.positionManager === PositionManager.GAMMA) {
            Promise.all([refetchGammaAllPositions()]).then(() => handleCloseModal?.());
        } else {
            Promise.all([refetchPosition(), refetchAllPositions()]).then(() =>
                handleCloseModal?.(),
            );
        }
    }, [isSuccess, mintInfo.positionManager]);

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    /* const handleWrap = useCallback(async () => {
        if (showWrap) {
            const tx = await wrapCallback?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        setStartIncrease(true);
    }, [wrapCallback, showWrap]); */

    const handleApproval = useCallback(async () => {
        if (showApproveA) {
            const tx = await approvalCallbackA?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        if (showApproveB) {
            const tx = await approvalCallbackB?.();
            if (tx) await waitForTransaction({ hash: tx.hash, confirmations: 1 });
        }

        // if (showWrap) {
        //     handleWrap();
        // } else {
        setStartIncrease(true);
        // }
    }, [
        approvalCallbackA,
        approvalCallbackB,
        showApproveA,
        showApproveB /* , showWrap, handleWrap */,
    ]);

    useEffect(() => {
        try {
            if (startIncrease && increaseLiquidity) {
                setStartIncrease(false);
                increaseLiquidity();
            }
        } catch (error) {
            new Error(`Increase Failed ${error}`);
        }
    }, [startIncrease, increaseLiquidity]);

    if (!account) return <FloatingButton onClick={() => open()}>Connect Wallet</FloatingButton>;

    if (isWrongChain)
        return (
            <FloatingButton
                onClick={() => open({ view: "Networks" })}
            >{`Connect to ${DEFAULT_CHAIN_NAME}`}</FloatingButton>
        );

    if (mintInfo.errorMessage)
        return <FloatingButton disabled>{mintInfo.errorMessage}</FloatingButton>;

    if (showApproveA || showApproveB)
        return (
            <div className="flex w-full gap-[16px]">
                <FloatingButton
                    disabled={
                        approvalStateA === ApprovalState.PENDING ||
                        approvalStateB === ApprovalState.PENDING
                    }
                    onClick={() => handleApproval()}
                >
                    {approvalStateA === ApprovalState.PENDING ||
                    approvalStateB === ApprovalState.PENDING ? (
                        <Loader />
                    ) : (
                        <>
                            Approve {showApproveA && mintInfo.currencies.CURRENCY_A?.symbol}{" "}
                            {showApproveA && showApproveB && " & "}{" "}
                            {showApproveB && mintInfo.currencies.CURRENCY_B?.symbol}
                        </>
                    )}
                </FloatingButton>

                {/* {showApproveA && (
                    <FloatingButton
                        disabled={approvalStateA === ApprovalState.PENDING}
                        onClick={() => approvalCallbackA && approvalCallbackA()}
                    >
                        {approvalStateA === ApprovalState.PENDING ? (
                            <Loader />
                        ) : (
                            `Approve ${mintInfo.currencies.CURRENCY_A?.symbol}`
                        )}
                    </FloatingButton>
                )}
                {showApproveB && (
                    <FloatingButton
                        disabled={approvalStateB === ApprovalState.PENDING}
                        onClick={() => approvalCallbackB && approvalCallbackB()}
                    >
                        {approvalStateB === ApprovalState.PENDING ? (
                            <Loader />
                        ) : (
                            `Approve ${mintInfo.currencies.CURRENCY_B?.symbol}`
                        )}
                    </FloatingButton>
                )} */}
            </div>
        );

    /* if (showWrap) {
        return (
            <FloatingButton disabled={wrapState === WrapState.PENDING} onClick={() => handleWrap()}>
                {wrapState === WrapState.PENDING ? <Loader /> : "Wrap CORE"}
            </FloatingButton>
        );
    } */

    return (
        <FloatingButton
            disabled={!isReady || isIncreaseLiquidityLoading || isConfirmLoading || !callable}
            onClick={() => increaseLiquidity && increaseLiquidity()}
        >
            {isIncreaseLiquidityLoading || isConfirmLoading ? <Loader /> : "Add Liquidity"}
        </FloatingButton>
    );
};

export default IncreaseLiquidityButton;



================================================
File: src/components/position/PositionCard/GammaManager.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import Image from "@/components/common/Image";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { Currency } from "@glyph-exchange/integral-sdk";
import { memo } from "react";
import tw, { styled } from "twin.macro";

const _Label = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    margin-top: 44px;

    ${() => tw`text-left m:mt-[36px] m:text-[10px]`}
`;

const _Manager = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;
    margin-top: 4px;
    ${() => tw`flex items-center m:text-[14px]`}
`;

const _GammaManager = styled.div`
    ${() => tw`flex flex-col items-start justify-between`}
`;
const GammaManager: FCProps<{ currencyA?: Currency; currencyB?: Currency }> = ({
    className,
    style,
    currencyA,
    currencyB,
}) => {
    const isMobile = useMediaQuery("mobile");

    return (
        <_GammaManager className={className} style={style}>
            <div className="flex items-end">
                <CurrencyLogo currency={currencyA} size={isMobile ? 48 : 64} />
                <CurrencyLogo
                    className="ml-[-24px]"
                    currency={currencyB}
                    size={isMobile ? 48 : 64}
                />
                <Image
                    className="ml-[-28px] m:ml-[-20px]"
                    width={isMobile ? 20 : 28}
                    height={isMobile ? 20 : 28}
                    src="/gamma-icon.svg"
                />
            </div>

            <div>
                <_Label>Manager</_Label>
                <_Manager>
                    GAMMA{" "}
                    <Image
                        className="ml-[4px]"
                        width={isMobile ? 12 : 16}
                        height={isMobile ? 12 : 16}
                        src="/gamma-icon.svg"
                    />
                </_Manager>
            </div>
        </_GammaManager>
    );
};

export default memo(GammaManager);



================================================
File: src/components/position/PositionCard/index.tsx
================================================
import { usePool } from "@/hooks/pools/usePool";
import { usePosition, usePositionInFarming } from "@/hooks/positions/usePositions";
import { CurrencyAmount, Field, INITIAL_POOL_FEE, Position } from "@glyph-exchange/integral-sdk";
import PositionNFT from "../PositionNFT";
import { FormattedPosition } from "@/types/formatted-position";
import { formatUSD } from "@/utils/common/formatUSD";
import { Skeleton } from "@/components/ui/skeleton";
import PositionRangeChart from "../PositionRangeChart";
import TokenRatio from "@/components/create-position/TokenRatio";
import { useDerivedMintInfo, useMintState } from "@/state/mintStore";
import CollectFees from "../CollectFees";
import RemoveLiquidityModal from "@/components/modals/RemoveLiquidityModal";
import { Farming } from "@/types/farming-info";
import { EternalFarming } from "@/graphql/generated/graphql";
import ActiveFarmingCard from "../ActiveFarmingCard";
import ClosedFarmingCard from "../ClosedFarmingCard";
import { IncreaseLiquidityModal } from "@/components/modals/IncreaseLiquidityModal";
import { useCurrency } from "@/hooks/common/useCurrency";
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import tw, { styled } from "twin.macro";
import { memo, useMemo } from "react";
import { PositionManager } from "@/types/position-state";
import { Address, parseUnits } from "viem";
import GammaManager from "./GammaManager";

interface PositionCardProps {
    selectedPosition: FormattedPosition | undefined;
    farming?: Farming | null;
    closedFarmings?: EternalFarming[] | null;
}

const _PositionCard = styled(PanelBase)`
    ${() => tw`animate-fade-in text-black`}
`;

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 24px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-transform: uppercase;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;

    ${() => tw`w-full text-left m:text-[16px]`}
`;

const _Label = styled.div`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw`m:text-[10px]`}
`;
const _Value = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() => tw`w-full truncate text-left m:text-[14px]`}
`;

const _RatioValue = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 14px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-transform: uppercase;

    ${() => tw`mt-[5px] m:text-[12px]`}
`;

const AlgebraCard = ({ selectedPosition, farming, closedFarmings }: PositionCardProps) => {
    const { loading, position } = usePosition(selectedPosition?.id);

    const positionInFarming = usePositionInFarming(selectedPosition?.id);

    const positionInEndedFarming = closedFarmings?.filter(
        (closedFarming) => closedFarming.id === positionInFarming?.eternalFarming,
    )[0];

    const token0 = position?.token0;
    const token1 = position?.token1;

    const currencyA = useCurrency(token0, true);
    const currencyB = useCurrency(token1, true);

    const [, pool] = usePool(position?.pool);
    const positionEntity =
        pool &&
        position &&
        new Position({
            pool,
            liquidity: position.liquidity.toString(),
            tickLower: Number(position.tickLower),
            tickUpper: Number(position.tickUpper),
        });

    const mintInfo = useDerivedMintInfo(
        currencyA,
        currencyB,
        position?.pool,
        INITIAL_POOL_FEE,
        currencyA,
        positionEntity || undefined,
    );

    const [positionLiquidityUSD, positionFeesUSD, positionAPR] = selectedPosition
        ? [
              formatUSD.format(selectedPosition.liquidityUSD),
              formatUSD.format(selectedPosition.feesUSD),
              `${selectedPosition.apr.toFixed(2)}%`,
          ]
        : [];

    if (!selectedPosition || loading) return;

    return (
        <_PositionCard>
            <PanelTitle title="POSITION DETAILS" />

            <div className="flex items-center p-[28px_24px] m:p-[24px_24px_20px]">
                <PositionNFT
                    className="shrink-0 m:h-[169px] m:w-[98px]"
                    positionId={selectedPosition.id}
                />
                <div className="ml-[48px] flex min-w-0 flex-col items-start m:ml-[28px]">
                    <_Title>{`Position #${selectedPosition?.id}`}</_Title>
                    <div className="mt-[36px] flex w-full flex-col items-start gap-[4px] m:mt-[20px]">
                        <_Label>Liquidity</_Label>
                        <_Value>
                            {positionLiquidityUSD ? (
                                <span>{positionLiquidityUSD}</span>
                            ) : (
                                <Skeleton className="h-[30px] w-[100px] m:h-[17px] m:w-full" />
                            )}
                        </_Value>
                    </div>
                    <div className="mt-[12px] flex w-full flex-col items-start gap-[4px]">
                        <_Label>APR</_Label>
                        <_Value>
                            {positionAPR ? (
                                <span className="text-[#F7931A]">{positionAPR}</span>
                            ) : (
                                <Skeleton className="h-[30px] w-[100px] m:h-[17px] m:w-full" />
                            )}
                        </_Value>
                    </div>
                </div>
            </div>

            <CollectFees
                positionFeesUSD={positionFeesUSD}
                mintInfo={mintInfo}
                positionId={selectedPosition.id}
            />

            <div className="p-[40px_24px_36px] m:p-[20px_24px_24px]">
                <TokenRatio mintInfo={mintInfo} />
                {positionEntity && (
                    <div className="flex justify-between">
                        <_RatioValue>{`${positionEntity.amount0.toFixed(2)} ${currencyA?.symbol}`}</_RatioValue>
                        <_RatioValue>{`${positionEntity.amount1.toFixed(2)} ${currencyB?.symbol}`}</_RatioValue>
                    </div>
                )}

                {pool && positionEntity && (
                    <PositionRangeChart pool={pool} position={positionEntity} />
                )}

                {positionEntity && (
                    <div className="mt-[24px] m:mt-[20px]">
                        <IncreaseLiquidityModal
                            tokenId={Number(selectedPosition.id)}
                            currencyA={currencyA}
                            currencyB={currencyB}
                            mintInfo={mintInfo}
                        />
                    </div>
                )}
                {positionEntity && Number(positionEntity.liquidity) > 0 && (
                    <div className="mt-[20px] m:mt-[12px]">
                        <RemoveLiquidityModal positionId={selectedPosition.id} />
                    </div>
                )}

                {positionInEndedFarming && (
                    <ClosedFarmingCard
                        className="mt-[28px] m:mt-[20px]"
                        positionInEndedFarming={positionInEndedFarming}
                        selectedPosition={selectedPosition}
                    />
                )}
            </div>

            {positionInFarming && farming && !positionInEndedFarming && (
                <ActiveFarmingCard farming={farming} selectedPosition={positionInFarming} />
            )}
        </_PositionCard>
    );
};

const GammaCard: FCProps<PositionCardProps> = memo(({ selectedPosition }) => {
    const {
        id: positionId,
        hypervisor,
        userPositionData,
        liquidityUSD,
        feesUSD,
        apr,
        associatePoolId,
        positionEntity,
    } = useMemo(() => selectedPosition!, [selectedPosition]);

    const [positionLiquidityUSD, positionFeesUSD, positionAPR] = selectedPosition
        ? [formatUSD.format(liquidityUSD), formatUSD.format(feesUSD), `${apr.toFixed(2)}%`]
        : [];

    const token0 = hypervisor?.token0 as Address;
    const token1 = hypervisor?.token1 as Address;

    const currencyA = useCurrency(token0, true, true);
    const currencyB = useCurrency(token1, true, true);

    const currencyAmountA = useMemo(
        () =>
            currencyA &&
            userPositionData &&
            CurrencyAmount.fromRawAmount(
                currencyA,
                parseUnits(userPositionData.balance0.toString(), currencyA.decimals).toString(),
            ),
        [currencyA, userPositionData],
    );
    const currencyAmountB = useMemo(
        () =>
            currencyB &&
            userPositionData &&
            CurrencyAmount.fromRawAmount(
                currencyB,
                parseUnits(userPositionData.balance1.toString(), currencyB.decimals).toString(),
            ),
        [currencyB, userPositionData],
    );

    const [, pool] = usePool(associatePoolId);
    const gammaAmounts = useMemo(
        () => ({ [Field.CURRENCY_A]: currencyAmountA, [Field.CURRENCY_B]: currencyAmountB }),
        [currencyAmountA, currencyAmountB],
    );

    const mintInfo = useDerivedMintInfo(
        currencyA,
        currencyB,
        selectedPosition?.hypervisor?.address as Address,
        INITIAL_POOL_FEE,
        currencyA,
        undefined,
    );

    if (!selectedPosition) return;

    return (
        <_PositionCard>
            <PanelTitle title="POSITION DETAILS" />

            <div className="flex p-[28px_24px] m:p-[24px_24px_20px]">
                <GammaManager className="shrink-0" currencyA={currencyA} currencyB={currencyB} />

                <div className="ml-[65px] flex min-w-0 flex-col items-start m:ml-[48px]">
                    <_Title>{`Position #${positionId}`}</_Title>
                    <div className="mt-[36px] flex w-full flex-col items-start gap-[4px] m:mt-[20px]">
                        <_Label>Liquidity</_Label>
                        <_Value>
                            {positionLiquidityUSD ? (
                                <span>{positionLiquidityUSD}</span>
                            ) : (
                                <Skeleton className="h-[30px] w-[100px] m:h-[17px] m:w-full" />
                            )}
                        </_Value>
                    </div>
                    <div className="mt-[12px] flex w-full flex-col items-start gap-[4px]">
                        <_Label>APR</_Label>
                        <_Value>
                            {positionAPR ? (
                                <span className="text-[#F7931A]">{positionAPR}</span>
                            ) : (
                                <Skeleton className="h-[30px] w-[100px] m:h-[17px] m:w-full" />
                            )}
                        </_Value>
                    </div>
                </div>
            </div>

            <div className="p-[40px_24px_36px] m:p-[20px_24px_24px]">
                <TokenRatio mintInfo={mintInfo} gammaAmounts={gammaAmounts} />
                {userPositionData && (
                    <div className="flex justify-between">
                        <_RatioValue>{`${userPositionData.balance0.toFixed(2)} ${currencyA?.symbol}`}</_RatioValue>
                        <_RatioValue>{`${userPositionData.balance1.toFixed(2)} ${currencyB?.symbol}`}</_RatioValue>
                    </div>
                )}

                {pool && positionEntity && (
                    <PositionRangeChart pool={pool} position={positionEntity} />
                )}

                {userPositionData && (
                    <div className="mt-[24px] m:mt-[20px]">
                        <IncreaseLiquidityModal
                            tokenId={positionId}
                            currencyA={currencyA}
                            currencyB={currencyB}
                            mintInfo={mintInfo}
                        />
                    </div>
                )}
                {userPositionData && userPositionData.shareOfSupply > 0 && (
                    <div className="mt-[20px] m:mt-[12px]">
                        <RemoveLiquidityModal positionId={positionId} />
                    </div>
                )}
            </div>
        </_PositionCard>
    );
});

const PositionCard: FCProps<PositionCardProps> = memo(
    ({ selectedPosition, farming, closedFarmings }) => {
        const positionManager = useMintState((state) => state.positionManager);
        if (!selectedPosition) return;

        if (positionManager === PositionManager.ALGEBRA)
            return (
                <AlgebraCard
                    selectedPosition={selectedPosition}
                    farming={farming}
                    closedFarmings={closedFarmings}
                />
            );
        else if (positionManager === PositionManager.GAMMA)
            return <GammaCard selectedPosition={selectedPosition} />;
    },
);

export default PositionCard;



================================================
File: src/components/position/PositionNFT/index.tsx
================================================
import { ALGEBRA_POSITION_MANAGER } from "@/constants/addresses";
import { useAlgebraPositionManagerTokenUri } from "@/generated";
import { cn } from "@/lib/utils";
import { ExternalLinkIcon } from "lucide-react";
import { useEffect, useRef } from "react";

interface PositionNFTProps {
    positionId: number;
    className?: string;
}

const PositionNFT = ({ className, positionId }: PositionNFTProps) => {
    const { data: uri } = useAlgebraPositionManagerTokenUri({
        args: positionId ? [BigInt(positionId)] : undefined,
    });

    const imgRef = useRef<any>();

    const json = uri && JSON.parse(atob(uri.slice("data:application/json;base64,".length)));

    // const openSeaLink = `https://testnets.opensea.io/assets/holesky/${ALGEBRA_POSITION_MANAGER}/${positionId}`;

    useEffect(() => {
        if (!imgRef?.current || !json) return;

        imgRef.current.src = json.image;
    }, [imgRef, json]);

    return (
        <div className={cn("relative inline-block h-[210px] w-[121px] overflow-hidden", className)}>
            {json ? <img ref={imgRef} /> : <div className="h-full w-full bg-white/10"></div>}
            {/* {json && (
                <div className="absolute flex h-full w-full items-center justify-center bg-black/40 opacity-0 duration-200 hover:opacity-100">
                    <a
                        href={openSeaLink}
                        target={"_blank"}
                        rel={"noreferrer noopener"}
                        className="inline-flex gap-2 rounded-xl p-2 hover:bg-gray-600/60"
                    >
                        <span className="font-semibold">OpenSea</span>
                        <ExternalLinkIcon />
                    </a>
                </div>
            )} */}
        </div>
    );
};

export default PositionNFT;



================================================
File: src/components/position/PositionRangeChart/index.tsx
================================================
import LiquidityChart from "@/components/create-position/LiquidityChart";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { Pool, Position, tickToPrice } from "@glyph-exchange/integral-sdk";

interface PositionRangeChartProps {
    pool: Pool;
    position: Position;
}

const PositionRangeChart = ({ pool, position }: PositionRangeChartProps) => {
    const isMobile = useMediaQuery("mobile");
    const price = pool && tickToPrice(pool.token0, pool.token1, pool.tickCurrent).toSignificant();

    return (
        <LiquidityChart
            currencyA={pool.token0}
            currencyB={pool.token1}
            currentPrice={price ? parseFloat(price) : undefined}
            priceLower={position.token0PriceLower}
            priceUpper={position.token0PriceUpper}
            height={isMobile ? 179 : undefined}
            className="m:mt-[24px] m:!h-[179px]"
        />
    );
};

export default PositionRangeChart;



================================================
File: src/components/swap/SwitchBar.tsx
================================================
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { useSwapActionHandlers } from "@/state/swapStore";
import { memo } from "react";
import SeparateBar from "../common/SeparateBar";
import FloatingButton from "../common/FloatingButton";
import Image from "../common/Image";

const SwitchBar: FCProps = (props) => {
    const isMobile = useMediaQuery("mobile");
    const { onSwitchTokens } = useSwapActionHandlers();

    return (
        <SeparateBar
            {...props}
            middleElement={
                <FloatingButton
                    type="small"
                    width={isMobile ? "16px" : "24px"}
                    height={isMobile ? "16px" : "24px"}
                    innerStyle={{ padding: isMobile ? "2px" : "3px" }}
                    onClick={onSwitchTokens}
                >
                    <Image width={12} height={12} src="/switch.svg" alt="" />
                </FloatingButton>
            }
        />
    );
};

export default memo(SwitchBar);



================================================
File: src/components/swap/AggregatorPanel/SwapButton.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import { useApprove } from "@/hooks/common/useApprove";
import { useAggregatorSwapCallback } from "@/hooks/swap/useSwapCallback";
import { useAggregatorWrap, WrapType } from "@/hooks/swap/useWrapCallback";
import { useAggregatorSwapInfo } from "@/state/swapStore";
import { ApprovalState } from "@/types/approve-state";
import { SwapField } from "@/types/swap-field";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import { useCallback, useEffect, useState } from "react";
import { useAccount } from "wagmi";
import { waitForTransaction } from "@wagmi/core";
import { ICECREAM_SWAPROUTER } from "@/constants/addresses";

const SwapButton = () => {
    const { open } = useWeb3Modal();

    const { selectedNetworkId } = useWeb3ModalState();

    const { address: account } = useAccount();

    const {
        payAmount,
        receiveAmount,
        currencies,
        inputError: swapInputError,
        aggregatorData,
        isDataFetching,
    } = useAggregatorSwapInfo();

    const { approvalState, approvalCallback } = useApprove(
        payAmount,
        aggregatorData?.tx.to || ICECREAM_SWAPROUTER,
    );

    const showApproveFlow =
        !swapInputError &&
        (approvalState === ApprovalState.NOT_APPROVED || approvalState === ApprovalState.PENDING);

    const wrapType = useAggregatorWrap(payAmount?.currency, receiveAmount?.currency);
    const showWrap = wrapType !== WrapType.NOT_APPLICABLE;

    const { isSwapLoading, isSwapConfirmLoading, swapCallback } = useAggregatorSwapCallback(
        aggregatorData,
        payAmount,
        receiveAmount,
        wrapType,
        approvalState,
    );

    const [startSwap, setStartSwap] = useState(false);

    const handleApproval = useCallback(async () => {
        const tx = await approvalCallback?.();
        if (tx) {
            await waitForTransaction({ hash: tx.hash, confirmations: 3 });
            setStartSwap(true);
        }
    }, [approvalCallback]);

    const handleSwap = useCallback(async () => {
        if (!swapCallback) return;
        try {
            await swapCallback();
        } catch (error) {
            return new Error(`Swap Failed ${error}`);
        }
    }, [swapCallback]);

    useEffect(() => {
        try {
            if (startSwap && swapCallback) {
                setStartSwap(false);
                swapCallback();
            }
        } catch (error) {
            new Error(`Swap Failed ${error}`);
        }
    }, [startSwap, swapCallback]);

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    if (!account) return <FloatingButton onClick={() => open()}>Connect Wallet</FloatingButton>;

    if (isWrongChain)
        return (
            <FloatingButton
                onClick={() => open({ view: "Networks" })}
            >{`Switch to ${DEFAULT_CHAIN_NAME}`}</FloatingButton>
        );

    if (showApproveFlow)
        return (
            <FloatingButton
                disabled={approvalState !== ApprovalState.NOT_APPROVED}
                onClick={() => handleApproval()}
            >
                {approvalState === ApprovalState.PENDING ? (
                    <Loader />
                ) : approvalState === ApprovalState.APPROVED ? (
                    "Approved"
                ) : (
                    `Approve ${currencies[SwapField.INPUT]?.symbol}`
                )}
            </FloatingButton>
        );

    return (
        <>
            <FloatingButton
                onClick={() => handleSwap()}
                disabled={
                    !!swapInputError ||
                    isSwapConfirmLoading ||
                    isDataFetching ||
                    isSwapLoading ||
                    !swapCallback
                }
            >
                {isSwapConfirmLoading || isDataFetching || isSwapLoading ? (
                    <Loader />
                ) : swapInputError ? (
                    swapInputError
                ) : showWrap ? (
                    wrapType === WrapType.WRAP ? (
                        "Wrap"
                    ) : (
                        "Unwrap"
                    )
                ) : (
                    "Swap"
                )}
            </FloatingButton>
        </>
    );
};

export default SwapButton;



================================================
File: src/components/swap/AggregatorPanel/SwapPair.tsx
================================================
import { useUSDCValue } from "@/hooks/common/useUSDCValue";
import { useAggregatorSwapInfo, useSwapActionHandlers, useSwapState } from "@/state/swapStore";
import { SwapField, SwapFieldType } from "@/types/swap-field";
import {
    Currency,
    CurrencyAmount,
    maxAmountSpend,
    tryParseAmount,
} from "@glyph-exchange/integral-sdk";
import { memo, useCallback, useMemo } from "react";
import TokenCard from "../TokenCard";
import { useAggregatorWrap, WrapType } from "@/hooks/swap/useWrapCallback";
import tw, { styled } from "twin.macro";
import SwitchBar from "../SwitchBar";

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-align: left;
    margin-bottom: 12px;
    ${() => tw`m:text-[12px]`}
`;

const SwapPair = () => {
    const { currencyBalances, currencies, payAmount, receiveAmount } = useAggregatorSwapInfo();

    const baseCurrency = currencies[SwapField.INPUT];
    const quoteCurrency = currencies[SwapField.OUTPUT];

    const { typedValue } = useSwapState();
    const independentField = SwapField.INPUT;
    const dependentField: SwapFieldType = SwapField.OUTPUT;

    const { onCurrencySelection, onUserInput } = useSwapActionHandlers();

    const handleInputSelect = useCallback(
        (inputCurrency: Currency) => {
            onCurrencySelection(SwapField.INPUT, inputCurrency);
        },
        [onCurrencySelection],
    );

    const handleOutputSelect = useCallback(
        (outputCurrency: Currency) => {
            onCurrencySelection(SwapField.OUTPUT, outputCurrency);
        },
        [onCurrencySelection],
    );

    const handleTypeInput = useCallback(
        (value: string) => {
            onUserInput(SwapField.INPUT, value);
        },
        [onUserInput],
    );

    const wrapType = useAggregatorWrap(payAmount?.currency, receiveAmount?.currency);

    const showWrap = wrapType !== WrapType.NOT_APPLICABLE;

    const parsedAmounts = useMemo(
        () =>
            showWrap
                ? {
                      [SwapField.INPUT]: payAmount,
                      [SwapField.OUTPUT]: payAmount,
                  }
                : {
                      [SwapField.INPUT]: payAmount,
                      [SwapField.OUTPUT]: receiveAmount,
                  },
        [showWrap, payAmount, receiveAmount],
    );

    const maxInputAmount: CurrencyAmount<Currency> | undefined = maxAmountSpend(
        currencyBalances[SwapField.INPUT],
    );
    const showMaxButton = Boolean(
        maxInputAmount?.greaterThan(0) && !parsedAmounts[SwapField.INPUT]?.equalTo(maxInputAmount),
    );

    const handleMaxInput = useCallback(() => {
        maxInputAmount && onUserInput(SwapField.INPUT, maxInputAmount.toExact());
    }, [maxInputAmount, onUserInput]);

    const { formatted: fiatValueInputFormatted } = useUSDCValue(
        tryParseAmount(
            parsedAmounts[SwapField.INPUT]?.toSignificant(
                (parsedAmounts[SwapField.INPUT]?.currency.decimals || 6) / 2,
            ),
            baseCurrency,
        ),
    );
    const { formatted: fiatValueOutputFormatted } = useUSDCValue(
        tryParseAmount(
            parsedAmounts[SwapField.OUTPUT]?.toSignificant(
                (parsedAmounts[SwapField.OUTPUT]?.currency.decimals || 6) / 2,
            ),
            quoteCurrency,
        ),
    );

    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: showWrap
            ? (parsedAmounts[independentField]?.toExact() ?? "")
            : (parsedAmounts[dependentField]?.toFixed(
                  (parsedAmounts[dependentField]?.currency.decimals || 6) / 2,
              ) ?? ""),
    };

    return (
        <div className="relative">
            <_Title>
                You{" "}
                {showWrap ? <span className="capitalize">{wrapType.toLowerCase()}</span> : "Pay"}{" "}
            </_Title>
            <TokenCard
                value={formattedAmounts[SwapField.INPUT] || ""}
                currency={baseCurrency}
                otherCurrency={quoteCurrency}
                handleTokenSelection={handleInputSelect}
                handleValueChange={handleTypeInput}
                handleMaxValue={handleMaxInput}
                fiatValue={fiatValueInputFormatted ?? undefined}
                showMaxButton={showMaxButton}
                showBalance={true}
            />
            <SwitchBar className="mb-[12px] mt-[24px] m:mt-[12px]" />
            <_Title>You Receive</_Title>
            <TokenCard
                value={formattedAmounts[SwapField.OUTPUT] || ""}
                currency={quoteCurrency}
                otherCurrency={baseCurrency}
                handleTokenSelection={handleOutputSelect}
                fiatValue={fiatValueOutputFormatted ?? undefined}
                showBalance={true}
                disabled
            />
        </div>
    );
};

export default memo(SwapPair);



================================================
File: src/components/swap/AggregatorPanel/index.tsx
================================================
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import { SettingModal } from "@/components/common/Settings";
import { memo } from "react";
import tw, { styled } from "twin.macro";
import SwapPair from "./SwapPair";
import SwapButton from "./SwapButton";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PoweredByAggregator from "@/components/common/PoweredBy/Aggregator";

const _AggregatorPanel = styled.div`
    ${() => tw``}
`;
const AggregatorPanel: FCProps = ({ className, style }) => {
    return (
        <_AggregatorPanel className={className} style={style}>
            <PanelBase>
                <PanelTitle title="Aggregator" />
                <PanelContainer>
                    <div className="[padding:20px_24px_42px] m:[padding:16px_20px_36px]">
                        <SettingModal inAggregator />

                        <div className="mt-[14px]">
                            <SwapPair />
                        </div>
                        <div className="mt-[40px] m:mt-[28px]">
                            <SwapButton />
                        </div>
                    </div>
                </PanelContainer>
                <PanelFooter />
            </PanelBase>

            <PoweredByAggregator className="mt-[24px] m:mt-[20px]" />
        </_AggregatorPanel>
    );
};

export default memo(AggregatorPanel);



================================================
File: src/components/swap/IntegralPools/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo"
import Loader from "@/components/common/Loader"
import { DynamicFeePluginIcon } from "@/components/common/PluginIcons"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { PoolFieldsFragment, usePoolsListQuery } from "@/graphql/generated/graphql"
import { useCurrency } from "@/hooks/common/useCurrency"
import { usePoolPlugins } from "@/hooks/pools/usePoolPlugins"
import { useDerivedSwapInfo, useSwapState } from "@/state/swapStore"
import { SwapField } from "@/types/swap-field"
import { ChevronDownIcon } from "lucide-react"
import { memo, useState } from "react"
import { Address } from "wagmi"

const IntegralPools = () => {

    const { currencies, poolAddress } = useDerivedSwapInfo()

    const { [SwapField.INPUT]: currencyA, [SwapField.OUTPUT]: currencyB } = currencies

    const title = currencyA && currencyB && `${currencyA.symbol} / ${currencyB.symbol}`

    const { isLoading: isPluginsLoading, dynamicFeePlugin } = usePoolPlugins(poolAddress)

    const [isOpen, setIsOpen] = useState<boolean>(false)

    return <div className="relative flex flex-col w-full gap-2 py-2 pt-3 px-4 bg-card rounded-3xl border border-card-border">

        <div className="absolute text-sm font-semibold text-left -top-[10px] text-[#e97fff] bg-[#450174] w-fit px-2 pb-1 rounded-lg">
            Integral Pools
        </div>

        <div className="flex items-center justify-between">

            <Popover open={isOpen} >
                <PopoverTrigger
                    onMouseDown={() => setIsOpen(v => !v)}
                    className="flex items-center gap-4 w-fit py-2 px-4 rounded-2xl border-card-border duration-200">
                    <div className="flex">
                        <CurrencyLogo currency={currencyA} size={25} />
                        <CurrencyLogo currency={currencyB} size={25} style={{ marginLeft: '-8px' }} />
                    </div>
                    <div className="text-md md:text-lg font-semibold">{title}</div>
                    <div>
                        <ChevronDownIcon size={20} className={`duration-300 ${isOpen ? 'rotate-180' : ''}`} />
                    </div>
                </PopoverTrigger>

                <PopoverContent className="bg-card rounded-3xl border border-card-border" onPointerDownOutside={() => setTimeout(() => setIsOpen(false), 0)}>
                    <IntegralPoolsList poolAddress={poolAddress} onPoolSelect={() => setIsOpen(false)} />
                </PopoverContent>
            </Popover>

            <div>
                {isPluginsLoading ? <Loader size={16} /> : <div className="flex">
                    {dynamicFeePlugin && <DynamicFeePluginIcon />}
                </div>}
            </div>

        </div>
    </div>

}

const IntegralPoolsList = memo(({ poolAddress, onPoolSelect }: { poolAddress: Address | undefined, onPoolSelect: () => void }) => {

    const { data: pools, loading } = usePoolsListQuery()

    if (loading) return <span className="flex w-full justify-center text-white !min-w-[240px] m-auto"> <Loader /> </span>

    return <div className="flex flex-col gap-2">{pools?.pools.filter((pool) => poolAddress?.toLowerCase() !== pool.id.toLowerCase()).map((pool, idx) => <IntegralPoolsListItem key={`integral-pool-item-${idx}`} pool={pool} onPoolSelect={onPoolSelect} />)}</div>

})

const IntegralPoolsListItem = memo(({ pool, onPoolSelect }: { pool: PoolFieldsFragment, onPoolSelect: () => void }) => {

    const { isLoading: isPluginsLoading, dynamicFeePlugin } = usePoolPlugins(pool.id as Address)

    const { actions: { selectCurrency, typeInput } } = useSwapState()

    const currencyA = useCurrency(pool.token0.id as Address)
    const currencyB = useCurrency(pool.token1.id as Address)

    const selectPool = () => {
        typeInput(SwapField.INPUT, '')
        typeInput(SwapField.OUTPUT, '')
        selectCurrency(SwapField.INPUT, pool.token0.id)
        selectCurrency(SwapField.OUTPUT, pool.token1.id)
        onPoolSelect()
    }

    return <div className="flex items-center gap-4 min-h-[40px] text-white px-2 py-1 rounded-2xl whitespace-nowrap cursor-pointer hover:bg-card-hover duration-200" onClick={selectPool}>
        <div className="flex">
            <CurrencyLogo currency={currencyA} size={25} />
            <CurrencyLogo currency={currencyB} size={25} style={{marginLeft: '-8px'}} />
        </div>
        <div className="font-semibold">{currencyA && currencyB ? `${currencyA?.symbol} / ${currencyB?.symbol}` : ''}</div>
        <div className="ml-auto">
            {isPluginsLoading ? <Loader size={16} /> : <div className="flex">
                {dynamicFeePlugin && <DynamicFeePluginIcon />}
            </div>}
        </div>
    </div>
})

export default IntegralPools


================================================
File: src/components/swap/MarketDepthChart/index.tsx
================================================
import { MAX_UINT128 } from "@/constants/max-uint128";
import { useInfoTickData } from "@/hooks/pools/usePoolTickData";
import { useDerivedSwapInfo} from "@/state/swapStore";
import { formatCurrency } from "@/utils/common/formatCurrency";
import { CurrencyAmount, INITIAL_POOL_FEE, Pool, TickMath, Token } from "@glyph-exchange/integral-sdk"
import { ArrowDownIcon, ArrowRightIcon, ArrowUpIcon } from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import { Address } from "wagmi";

const NOT_SELECTED = Number.MAX_VALUE

const isAfterCurrent = (index: number) => {
    if (index === 0) {
        return Object.is(index, 0)
    }
    return index > 0
}

interface MarketDepthChartProps {
    currencyA: Token | undefined;
    currencyB: Token | undefined;
    poolAddress: Address | undefined;
    isOpen: boolean;
    close: () => void;
}

const MarketDepthChart = ({ currencyA, currencyB, isOpen, close }: MarketDepthChartProps) => {

    const { tickAfterSwap } = useDerivedSwapInfo();

    const [hoveredIndex, setHoveredIndex] = useState<number>(NOT_SELECTED)

    const [isTickOutside, setIsOutside] = useState(0)

    const [processedData, setProcessedData] = useState<any>(null)
    const {
        fetchTicksSurroundingPrice: { ticksResult, fetchTicksSurroundingPrice },
    } = useInfoTickData()

    useEffect(() => {
        if (!currencyA || !currencyB) return
        fetchTicksSurroundingPrice(currencyA, currencyB)
    }, [currencyA, currencyB])

    useEffect(() => {
        if (!ticksResult || !ticksResult.ticksProcessed) return

        async function processTicks() {

            if (!ticksResult) return

            const _data = await Promise.all(
                ticksResult.ticksProcessed.map(async (t, i) => {
                    const active = t.tickIdx === ticksResult.activeTickIdx
                    const sqrtPriceX96 = TickMath.getSqrtRatioAtTick(t.tickIdx)
                    const mockTicks = [
                        {
                            index: Number(t.tickIdx) - Number(ticksResult.tickSpacing),
                            liquidityGross: t.liquidityGross.toString(),
                            liquidityNet: (t.liquidityNet * -1n).toString(),
                        },
                        {
                            index: t.tickIdx,
                            liquidityGross: t.liquidityGross.toString(),
                            liquidityNet: t.liquidityNet.toString(),
                        },
                    ]
                    const pool =
                        currencyA && currencyB
                            ? new Pool(currencyA.wrapped, currencyB.wrapped, INITIAL_POOL_FEE, sqrtPriceX96, t.liquidityActive.toString(), t.tickIdx, ticksResult.tickSpacing, mockTicks)
                            : undefined

                    const nextSqrtX96 = ticksResult.ticksProcessed[i - 1]
                        ? TickMath.getSqrtRatioAtTick(ticksResult.ticksProcessed[i - 1].tickIdx)
                        : undefined

                    const maxAmountToken0 = currencyA ? CurrencyAmount.fromRawAmount(currencyA.wrapped, MAX_UINT128.toString()) : undefined


                    const outputRes0 =
                        pool && maxAmountToken0 ? await pool.getOutputAmount(maxAmountToken0, nextSqrtX96) : undefined

                    const token1Amount = outputRes0?.[0] as CurrencyAmount<Token> | undefined

                    const amount0 = token1Amount ? parseFloat(token1Amount.toExact()) * parseFloat(t.price1) : 0
                    const amount1 = token1Amount ? parseFloat(token1Amount.toExact()) : 0

                    return {
                        index: i,
                        isCurrent: active,
                        activeLiquidity: parseFloat(t.liquidityActive.toString()),
                        tick: t.tickIdx,
                        price0: parseFloat(t.price0),
                        price1: parseFloat(t.price1),
                        tvlToken0: amount0,
                        tvlToken1: amount1,
                    }
                })
            )
            setProcessedData(_data)
        }

        processTicks()
    }, [ticksResult])

    const [beforeCurrent, current, afterCurrent, maxLiquidity] = useMemo(() => {
        if (!processedData) return []
        if (processedData && processedData.length === 0) return []

        const middle = Math.round(processedData.length / 2)
        const chunkLength = Math.round(processedData.length / 50)

        const slicedData = processedData.slice(middle - chunkLength, middle + chunkLength).reverse()

        const currentIdx = slicedData.findIndex((v: any) => v.isCurrent)

        const maxLiquidity = slicedData.reduce((acc: any, v: any) => v.activeLiquidity > acc ? v.activeLiquidity : acc, 0)

        return [slicedData.slice(0, currentIdx), slicedData[currentIdx], slicedData.slice(currentIdx + 1), maxLiquidity]
    }, [processedData])

    const invertPrice = currencyA && currencyB && !currencyA.sortsBefore(currencyB)

    const tooltipY = useMemo(() => {

        if (hoveredIndex === NOT_SELECTED) return -9999

        const id = document.getElementById(isAfterCurrent(hoveredIndex) ? `before-current-${hoveredIndex}` : `after-current-${-hoveredIndex}`)

        return id?.offsetTop

    }, [hoveredIndex])

    const tooltipData = useMemo(() => {

        if (hoveredIndex === NOT_SELECTED || !beforeCurrent || !afterCurrent) return

        const summary = isAfterCurrent(hoveredIndex) ? beforeCurrent.slice(hoveredIndex) : afterCurrent.slice(0, -hoveredIndex + 1)

        return summary.reduce((acc: any, v: any) => ({
            price: acc.price + v.price0 / summary.length,
            amount: acc.amount + v.tvlToken0,
            total: acc.total + v.tvlToken1
        }), {
            price: 0,
            amount: 0,
            total: 0
        })

    }, [hoveredIndex, beforeCurrent, afterCurrent])

    const [highestTick, lowestTick] = beforeCurrent && afterCurrent ? [beforeCurrent[0].tick, afterCurrent[afterCurrent.length - 1].tick] : []

    useEffect(() => {

        const tick = tickAfterSwap

        if (!tick) return

        if (tick > highestTick) {
            setIsOutside(1)
        } else if (tick < lowestTick) {
            setIsOutside(-1)
        } else {
            setIsOutside(0)
        }

    }, [highestTick, lowestTick, tickAfterSwap])

    return <div className={`h-[100vh] lg:h-full bg-card fixed border-l border-card-border right-0 top-0 left-0 bottom-0 lg:left-[unset] overflow-x-hidden lg:overflow-x-visible duration-200 z-[99] ${isOpen ? 'w-[100vw] md:w-[380px]' : 'w-[0px]'}`}>

        <div className="flex flex-col lg:flex-row w-full h-full">

            <button
                className="h-full z-[99] p-1 bg-card-dark border-x border-card-border hover:bg-card-hover"
                onClick={close}
            >
                <ArrowRightIcon size={'20px'} className="rotate-180 lg:rotate-0" />
            </button>

            <div className="relative flex flex-col w-full h-full">

                <div className="flex justify-evenly text-sm py-2">
                    <div className="w-full text-left pl-4">{`Price (${currencyB?.symbol})`}</div>
                    <div className="w-full">{`Amount (${currencyA?.symbol})`}</div>
                    <div className="w-full text-right pr-4">{`Total (${currencyB?.symbol})`}</div>
                </div>

                <div className={`absolute lg:-left-[230px] z-[100]`} style={{ top: `${tooltipY}px` }}>
                    <MarketDepthChartTooltip currencyA={currencyA} currencyB={currencyB} tooltipData={tooltipData} />
                </div>

                <div className="relative flex flex-col items-end w-full h-full overflow-y-auto pl-16 text-sm select-none">
                    {isTickOutside === 1 && <div className="flex items-center gap-2 py-1 w-full bg-yellow-600 mb-2 pl-4" style={{ width: 'calc(100% + 4rem)' }}>
                        <ArrowUpIcon size={18} />
                        <span>Price is outside the scope</span>
                    </div>}
                    {
                        beforeCurrent ? beforeCurrent.map((v: any, idx: number) => <div id={`before-current-${idx}`} className={`relative flex items-center h-[25px] py-1 w-full`} onMouseOver={() => setHoveredIndex(idx)} onMouseOut={() => setHoveredIndex(NOT_SELECTED)} >
                            <div className={`absolute flex justify-evenly w-full`}>
                                <div className="w-full text-left -ml-12 text-red-500 font-semibold">{formatCurrency.format(invertPrice ? v.price1 : v.price0)}</div>
                                <div className="w-full">{formatCurrency.format(invertPrice ? v.tvlToken1 : v.tvlToken0)}</div>
                                <div className="w-full text-right pr-4">{formatCurrency.format(invertPrice ? v.tvlToken0 : v.tvlToken1)}</div>
                            </div>
                            <div
                                key={`before-price-${idx}`}
                                className={`h-[20px] rounded-l-lg ml-auto ${idx >= hoveredIndex && hoveredIndex >= 0 && isAfterCurrent(hoveredIndex) && hoveredIndex !== NOT_SELECTED ? 'bg-blue-500/80' : ((v.tick <= (tickAfterSwap || -NOT_SELECTED))) ? 'bg-yellow-600' : 'bg-red-800/40'}`}
                                style={{ width: `${v.activeLiquidity * 100 / maxLiquidity}%` }}></div>
                        </div>) : null
                    }
                    {current && <div className="relative flex items-center justify-between text-lg py-2 px-4 border-y border-card-border my-2 bg-card-dark" style={{ width: 'calc(100% + 4rem)' }}>
                        <div>{formatCurrency.format(invertPrice ? current.price1 : current.price0)}</div>
                        <div className="text-sm font-semibold">Current Price</div>
                    </div>}
                    {
                        afterCurrent ? afterCurrent.map((v: any, idx: number) => <div id={`after-current-${idx}`} className={`relative flex items-center h-[25px] py-1 w-full`} onMouseOver={() => setHoveredIndex(-idx)} onMouseOut={() => setHoveredIndex(NOT_SELECTED)}>
                            <div className="absolute flex justify-evenly w-full">
                                <div className="w-full text-left -ml-12 text-green-500 font-semibold">{formatCurrency.format(invertPrice ? v.price1 : v.price0)}</div>
                                <div className="w-full">{formatCurrency.format(invertPrice ? v.tvlToken1 : v.tvlToken0)}</div>
                                <div className="w-full text-right pr-4">{formatCurrency.format(invertPrice ? v.tvlToken0 : v.tvlToken1)}</div>
                            </div>
                            <div
                                key={`after-price-${idx}`}
                                className={`h-[20px] ${-idx >= hoveredIndex && hoveredIndex !== NOT_SELECTED ? 'bg-blue-500/80' : ((v.tick >= (tickAfterSwap || NOT_SELECTED))) ? 'bg-yellow-600' : 'bg-green-800/40'} rounded-l-lg ml-auto`}
                                style={{ width: `${v.activeLiquidity * 100 / maxLiquidity}%` }}></div>
                        </div>) : null
                    }
                    {isTickOutside === -1 && <div className="flex items-center gap-2 py-1 w-full bg-yellow-600 mt-2 pl-4" style={{ width: 'calc(100% + 4rem)' }}>
                        <ArrowDownIcon size={18} />
                        <span>Price is outside the scope</span>
                    </div>}
                </div>

            </div>

        </div>

    </div>
}

const MarketDepthChartTooltip = ({
    currencyA,
    currencyB,
    tooltipData
}: any) => {

    if (!tooltipData) return null

    return <div className="flex flex-col gap-2 p-4 rounded-2xl bg-card border border-card-border">
        <div className="flex gap-4 justify-between">
            <div>{`Average Price:`}</div>
            <div>{formatCurrency.format(tooltipData.price)}</div>
        </div>
        <div className="flex gap-4 justify-between">
            <div>{`Amount ${currencyA?.symbol}:`}</div>
            <div>{formatCurrency.format(tooltipData.amount)}</div>
        </div>
        <div className="flex gap-4 justify-between">
            <div>{`Total ${currencyB?.symbol}:`}</div>
            <div>{formatCurrency.format(tooltipData.total)}</div>
        </div>
    </div>
}

export default MarketDepthChart


================================================
File: src/components/swap/SwapChart/index.tsx
================================================
import { useDerivedSwapInfo } from "@/state/swapStore";
import { SwapChartPair, SwapChartPairType, SwapChartSpan, SwapChartSpanType, SwapChartView, SwapChartViewType } from "@/types/swap-chart";
import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import * as LightWeightCharts from "lightweight-charts";
import { useSwapChart } from "@/hooks/swap/useSwapChart";
import { BarChartHorizontalIcon, CandlestickChartIcon, ChevronDownIcon, LineChartIcon } from "lucide-react";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import CurrencyLogo from "@/components/common/CurrencyLogo";
import { Currency } from "@glyph-exchange/integral-sdk";
import { Button } from "@/components/ui/button";
import { formatCurrency } from "@/utils/common/formatCurrency";
import { Address } from "wagmi";
import { formatUSD } from "@/utils/common/formatUSD";
import { Skeleton } from "@/components/ui/skeleton";
import Loader from "@/components/common/Loader";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import MarketDepthChart from "../MarketDepthChart";

const getTokenTitle = (chartPair: SwapChartPairType, currencyA: Currency, currencyB: Currency) => {

    switch (chartPair) {
        case SwapChartPair.AB:
            return [
                <div className="flex">
                    <CurrencyLogo currency={currencyA} size={30} />
                    <CurrencyLogo currency={currencyB} size={30} style={{ marginLeft: '-8px' }} />
                </div>,
                `${currencyA.symbol} / ${currencyB.symbol}`,
            ];
        case SwapChartPair.BA:
            return [
                <div className="flex">
                    <CurrencyLogo currency={currencyB} size={30} />
                    <CurrencyLogo currency={currencyA} size={30} style={{ marginLeft: '-8px' }} />
                </div>,
                `${currencyB.symbol} / ${currencyA.symbol}`,
            ];
        case SwapChartPair.A:
            return [
                <CurrencyLogo currency={currencyA} size={30} />,
                `${currencyA.symbol}`
            ];
        case SwapChartPair.B:
            return [
                <CurrencyLogo currency={currencyB} size={30} />,
                `${currencyB.symbol}`
            ];
    }
}

const mainnetPoolsMapping: { [key: Address]: Address } = {
    ['0x89406233d4290f405eabb6f320fd648276b8b5b7']: '0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640',
    ['0x9367e79bbc401cec2545b4671a80892a26ae1cd9']: '0x9a772018fbd77fcd2d25657e5c547baff3fd7d16',
    ['0x9f032424a5a4b0effb7fe4912f3e325c105345bc']: '0x3416cf6c708da44db2624d63ea0aaef7113527c6'
}

const mainnetTokensMapping: { [key: Address]: Address } = {
    ['0x20b28b1e4665fff290650586ad76e977eab90c5d']: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    ['0x49a390a3dfd2d01389f799965f3af5961f87d228']: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
    ['0x5aefba317baba46eaf98fd6f381d07673bca6467']: '0xdac17f958d2ee523a2206206994597c13d831ec7',
    ['0xbc892d5f23d3733cff8986d011ca8ff1249d16ca']: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
}

const SwapChart = () => {

    const chartRef = useRef<HTMLDivElement>(null);

    const [chartType, setChartType] = useState<SwapChartViewType>(SwapChartView.LINE);
    const [chartSpan, setChartSpan] = useState<SwapChartSpanType>(SwapChartSpan.DAY);
    const [chartPair, setChartPair] = useState<SwapChartPairType>(SwapChartPair.AB);

    const { currencies, poolAddress: poolId } = useDerivedSwapInfo();

    const [tokenA, tokenB] = [currencies.INPUT?.wrapped, currencies.OUTPUT?.wrapped];

    const [chartCreated, setChart] = useState<any | undefined>();
    const [series, setSeries] = useState<LightWeightCharts.ISeriesApi<"Area" | "Candlestick"> | undefined>();

    const [displayValue, setDisplayValued] = useState<string>()
    const [displayDate, setDisplayDate] = useState(new Date().toLocaleDateString())

    const [chartData, setChartData] = useState<any | undefined>();

    const { fetchPoolPriceData, fetchTokenPriceData } = useSwapChart();

    const poolAddress = poolId ? mainnetPoolsMapping[poolId] : '';
    const tokenAddress = chartPair === SwapChartPair.A && tokenA ? mainnetTokensMapping[tokenA.address.toLowerCase() as Address] : tokenB ? mainnetTokensMapping[tokenB.address.toLowerCase() as Address] : '';

    const [isMarketDepthOpen, setIsMarketDepthOpen] = useState(false)
    const [isPoolSwitcherOpen, setIsPoolSwitcherOpen] = useState(false)


    useEffect(() => {
        setChart(undefined);

        if ((chartPair === SwapChartPair.AB || chartPair === SwapChartPair.BA) && !poolAddress) return

        if ((chartPair === SwapChartPair.A || chartPair === SwapChartPair.B) && !tokenAddress) return

        let fetchFn: () => Promise<any>;

        if (chartPair === SwapChartPair.AB || chartPair === SwapChartPair.BA) {
            fetchFn = fetchPoolPriceData.bind(null, poolAddress, chartSpan);
        } else {
            fetchFn = fetchTokenPriceData.bind(null, tokenAddress, chartSpan);
        }

        fetchFn().then((res) => {
            if (!res.data || res.error) return;

            setChartData(res.data);
        });
    }, [chartSpan, chartPair, poolAddress, tokenAddress, poolAddress]);

    const formattedData = useMemo(() => {
        if (!chartData || !tokenA || !tokenB) return;

        if (chartType === SwapChartView.CANDLES) {
            const isSorted = chartPair === SwapChartPair.AB;

            return chartData.map((d: any) => {
                return {
                    time: d.periodStartUnix,
                    open: parseFloat(isSorted ? d.open : String(1 / (d.open || 1))),
                    close: parseFloat(isSorted ? d.close : String(1 / (d.close || 1))),
                    high: parseFloat(isSorted ? d.high : String(1 / (d.high || 1))),
                    low: parseFloat(isSorted ? d.low : String(1 / (d.low || 1))),
                };
            });
        }

        if (chartPair === SwapChartPair.AB || chartPair === SwapChartPair.BA) {
            const [token0Price] = chartPair === SwapChartPair.AB ? ["token0Price", "token1Price"] : ["token1Price", "token0Price"];
            return chartData.map((d: any) => {
                return {
                    time: d.periodStartUnix,
                    value: +d[token0Price],
                };
            });
        }

        return chartData.map((d: any) => {
            return {
                time: d.periodStartUnix,
                value: Number(d.priceUSD),
            };
        });
    }, [chartType, chartData, tokenA, tokenB]);

    const handleResize = useCallback(() => {
        if (chartCreated && chartRef?.current?.parentElement) {
            chartCreated.resize(chartRef.current.offsetWidth - 32, chartRef.current.offsetHeight);
            chartCreated.timeScale().fitContent();
            chartCreated.timeScale().scrollToPosition(0, false);
        }
    }, [chartCreated, chartRef, chartRef]);

    const isClient = typeof window === "object";
    useEffect(() => {
        if (!isClient) {
            return;
        }
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
    }, [isClient, chartRef, handleResize]);

    useLayoutEffect(() => {
        if (!chartRef.current || !formattedData) return;

        if (chartRef.current.hasChildNodes()) chartRef.current.innerHTML = "";

        const chart = LightWeightCharts.createChart(chartRef.current, {
            width: chartRef.current.parentElement?.clientWidth,
            height: chartRef.current.parentElement?.clientHeight || 300,
            layout: {
                background: {
                    color: 'transparent'
                },
                textColor: "black",
            },
            grid: {
                vertLines: {
                    color: "rgba(197, 203, 206, 0.0)",
                },
                horzLines: {
                    color: "rgba(197, 203, 206, 0.0)",
                },
            },
            crosshair: {
                mode: LightWeightCharts.CrosshairMode.Magnet,
            },
            rightPriceScale: {
                visible: false,
                borderColor: "transparent",
            },
            timeScale: {
                visible: false,
                borderColor: "transparent",
            },
            handleScale: {
                mouseWheel: false,
            },
            handleScroll: {
                pressedMouseMove: false,
                vertTouchDrag: false,
                horzTouchDrag: false
            }
        });

        let series;

        if (chartType === SwapChartView.CANDLES) {
            series = chart?.addCandlestickSeries({
                upColor: "#00b124",
                downColor: "#F55755",
                borderDownColor: "#F55755",
                borderUpColor: "#00b124",
                wickDownColor: "#F55755",
                wickUpColor: "#00b124",
            });
        } else {
            series = chart?.addAreaSeries({
                topColor: "rgba(39, 151, 255, 0.6)",
                bottomColor: "rgba(39, 151, 255, 0)",
                lineColor: "rgba(39, 151, 255, 1)",
            });
        }

        series?.setData(formattedData);

        chart.timeScale().fitContent();

        setChart(chart);
        setSeries(series);
    }, [chartRef, chartType, formattedData]);

    const currentValue = useMemo(() => {
        if (!formattedData) return ''

        const value = formattedData[formattedData.length - 1].value;

        if (chartPair === SwapChartPair.AB || chartPair === SwapChartPair.BA) {
            return formatCurrency.format(value)
        }

        return formatUSD.format(value)
    }, [formattedData, chartPair])

    const displayValueCurrency = chartPair === SwapChartPair.AB ? currencies.OUTPUT?.symbol : chartPair === SwapChartPair.BA ? currencies.INPUT?.symbol : chartPair === SwapChartPair.A || chartPair === SwapChartPair.B ? '' : ''

    const crosshairMoveHandler = useCallback((param: any) => {
        if (param.point) {
            const formatter = chartPair === SwapChartPair.AB || chartPair === SwapChartPair.BA ? formatCurrency : formatUSD
            setDisplayValued(formatter.format(param.seriesData.get(series).value))
            setDisplayDate(new Date(param.time * 1000).toLocaleDateString())
        } else {
            setDisplayDate(new Date().toLocaleDateString())
            setDisplayValued(currentValue)
        }
    }, [series, currentValue, chartPair])

    useEffect(() => {
        if (!chartCreated) return
        chartCreated.subscribeCrosshairMove(crosshairMoveHandler)
        return () => chartCreated.unsubscribeCrosshairMove(crosshairMoveHandler)
    }, [chartCreated])

    useEffect(() => {
        setDisplayValued(currentValue)
    }, [currentValue])

    const [pairImage, pairTitle] = useMemo(() => {
        if (!currencies.INPUT || !currencies.OUTPUT) return [
            <Loader size={16} />,
            'Loading...'
        ];

        return getTokenTitle(chartPair, currencies.INPUT, currencies.OUTPUT)

    }, [currencies, chartPair]);

    const pairSelectorList = useMemo(() => {

        if (!currencies.INPUT || !currencies.OUTPUT) return

        return Object.keys(SwapChartPair).filter(v => v !== chartPair).map((pair: any) => ({
            pair,
            title: getTokenTitle(pair, currencies.INPUT!, currencies.OUTPUT!)
        }))
    }, [currencies.INPUT, currencies.OUTPUT, chartPair])

    return (<div className="flex flex-col gap-6 w-full h-full relative">

        <MarketDepthChart currencyA={tokenA} currencyB={tokenB} poolAddress={poolId} isOpen={isMarketDepthOpen} close={() => setIsMarketDepthOpen(false)} />

        <div className="flex flex-col md:flex-row gap-4 justify-between">

            <Popover open={isPoolSwitcherOpen}>
                <PopoverTrigger
                    onMouseDown={() => setIsPoolSwitcherOpen(v => !v)}
                    className="flex items-center justify-between w-fit min-w-[240px] py-2 px-4 rounded-3xl bg-card border border-card-border hover:bg-card-hover duration-200">
                    <div className="flex items-center gap-4 font-semibold">
                        <span className="flex">{pairImage}</span>
                        <span>{pairTitle}</span>
                    </div>
                    <div>
                        <ChevronDownIcon size={20} className={`duration-300 ${isPoolSwitcherOpen ? 'rotate-180' : ''}`} />
                    </div>
                </PopoverTrigger>

                <PopoverContent
                    onPointerDownOutside={() => setTimeout(() => setIsPoolSwitcherOpen(false), 0)}
                    className="bg-card rounded-3xl border border-card-border">
                    <div className="flex flex-col gap-2 text-white">
                        {
                            pairSelectorList?.map((item) => <div
                                key={`chart-pair-selector-item-${item.pair}`}
                                className="flex items-center gap-2 min-h-[40px] text-white font-semibold p-2 px-4 rounded-2xl cursor-pointer hover:bg-card-hover duration-200"
                                onClick={() => {
                                    setChartPair(item.pair)
                                    setIsPoolSwitcherOpen(false)
                                }}>{item.title}</div>)
                        }
                    </div>
                </PopoverContent>
            </Popover>
            <div className="flex gap-4 w-fit p-2 bg-card border border-card-border rounded-3xl">
                <div className="flex gap-2">
                    <Button variant={chartSpan === SwapChartSpan.DAY ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setChartSpan(SwapChartSpan.DAY)}>
                        1D
                    </Button>
                    <Button variant={chartSpan === SwapChartSpan.WEEK ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setChartSpan(SwapChartSpan.WEEK)}>
                        1W
                    </Button>
                    <Button variant={chartSpan === SwapChartSpan.MONTH ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setChartSpan(SwapChartSpan.MONTH)}>
                        1M
                    </Button>
                </div>
                <div className="self-center w-[1px] h-3/6 border border-card-border/40"></div>
                <div className="flex gap-2">
                    <Button variant={chartType === SwapChartView.LINE ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setChartType(SwapChartView.LINE)}>
                        <LineChartIcon size={20} />
                    </Button>
                    <HoverCard>
                        <HoverCardTrigger>
                            <Button variant={chartType === SwapChartView.CANDLES ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setChartType(SwapChartView.CANDLES)} disabled>
                                <CandlestickChartIcon size={20} />
                            </Button>
                        </HoverCardTrigger>
                        <HoverCardContent>
                            <div className="font-bold">Candlestick chart</div>
                            <div>Coming Soon</div>
                        </HoverCardContent>
                    </HoverCard>
                </div>
                <div className="self-center w-[1px] h-3/6 border border-card-border/40"></div>
                <HoverCard>
                    <HoverCardTrigger>
                        <Button variant={isMarketDepthOpen ? 'iconActive' : 'icon'} size={'icon'} onClick={() => setIsMarketDepthOpen(v => !v)}>
                            <BarChartHorizontalIcon size={20} />
                        </Button>
                    </HoverCardTrigger>
                    <HoverCardContent>
                        <div className="font-bold">Market Depth</div>
                    </HoverCardContent>
                </HoverCard>
            </div>
        </div>
        <div className={`flex items-center justify-center relative w-full h-[300px]`}>

            <div className="flex items-center justify-center w-full h-full" ref={chartRef}></div>

            <div className="absolute right-0 top-0 flex flex-col items-end w-full text-3xl text-right">
                {chartCreated ? <>
                    <div className="text-3xl font-bold">
                        <span>{displayValue ? displayValue : currentValue ? currentValue : <Loader size={18} />}</span>
                        <span className="ml-2">{displayValueCurrency && displayValueCurrency}</span>
                    </div>
                    <div className="text-[#b7b7b7] text-sm">
                        {displayValue ? displayDate : null}
                    </div>
                </> : <>
                    <Skeleton className="w-[150px] h-[38px] bg-card" />
                    <Skeleton className="w-[60px] h-[18px] bg-card mt-[2px]" />
                </>}
            </div>
            
            {!chartCreated ? (
                <div className="flex items-center justify-center absolute w-full h-full">
                    <Loader />
                </div>
            ) : null}

        </div>
    </div>
    );

}

export default SwapChart;


================================================
File: src/components/swap/SwapPair/index.tsx
================================================
import { useUSDCValue } from "@/hooks/common/useUSDCValue";
import { useDerivedSwapInfo, useSwapActionHandlers, useSwapState } from "@/state/swapStore";
import { SwapField, SwapFieldType } from "@/types/swap-field";
import {
    Currency,
    CurrencyAmount,
    maxAmountSpend,
    tryParseAmount,
} from "@glyph-exchange/integral-sdk";
import { memo, useCallback, useMemo } from "react";
import TokenCard from "../TokenCard";
import useWrapCallback, { WrapType } from "@/hooks/swap/useWrapCallback";
import tw, { styled } from "twin.macro";
import SwitchBar from "../SwitchBar";

const _Title = styled.div`
    color: #000;
    font-family: FraktionMono-Bold;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    text-align: left;
    margin-bottom: 12px;
    ${() => tw`m:text-[12px]`}
`;

const SwapPair = () => {
    const {
        toggledTrade: trade,
        currencyBalances,
        parsedAmount,
        currencies,
    } = useDerivedSwapInfo();

    const baseCurrency = currencies[SwapField.INPUT];
    const quoteCurrency = currencies[SwapField.OUTPUT];

    const { independentField, typedValue } = useSwapState();
    const dependentField: SwapFieldType =
        independentField === SwapField.INPUT ? SwapField.OUTPUT : SwapField.INPUT;

    const { onCurrencySelection, onUserInput } = useSwapActionHandlers();

    const handleInputSelect = useCallback(
        (inputCurrency: Currency) => {
            onCurrencySelection(SwapField.INPUT, inputCurrency);
        },
        [onCurrencySelection],
    );

    const handleOutputSelect = useCallback(
        (outputCurrency: Currency) => {
            onCurrencySelection(SwapField.OUTPUT, outputCurrency);
        },
        [onCurrencySelection],
    );

    const handleTypeInput = useCallback(
        (value: string) => {
            onUserInput(SwapField.INPUT, value);
        },
        [onUserInput],
    );
    const handleTypeOutput = useCallback(
        (value: string) => {
            onUserInput(SwapField.OUTPUT, value);
        },
        [onUserInput],
    );

    const { wrapType } = useWrapCallback(
        currencies[SwapField.INPUT],
        currencies[SwapField.OUTPUT],
        typedValue,
    );

    const showWrap: boolean = wrapType !== WrapType.NOT_APPLICABLE;

    const parsedAmountA = independentField === SwapField.INPUT ? parsedAmount : trade?.inputAmount;

    const parsedAmountB =
        independentField === SwapField.OUTPUT ? parsedAmount : trade?.outputAmount;

    const parsedAmounts = useMemo(
        () =>
            showWrap
                ? {
                      [SwapField.INPUT]: parsedAmount,
                      [SwapField.OUTPUT]: parsedAmount,
                  }
                : {
                      [SwapField.INPUT]: parsedAmountA,
                      [SwapField.OUTPUT]: parsedAmountB,
                  },
        [parsedAmount, showWrap, parsedAmountA, parsedAmountB],
    );

    const maxInputAmount: CurrencyAmount<Currency> | undefined = maxAmountSpend(
        currencyBalances[SwapField.INPUT],
    );
    const showMaxButton = Boolean(
        maxInputAmount?.greaterThan(0) && !parsedAmounts[SwapField.INPUT]?.equalTo(maxInputAmount),
    );

    const handleMaxInput = useCallback(() => {
        maxInputAmount && onUserInput(SwapField.INPUT, maxInputAmount.toExact());
    }, [maxInputAmount, onUserInput]);

    const { formatted: fiatValueInputFormatted } = useUSDCValue(
        tryParseAmount(
            parsedAmounts[SwapField.INPUT]?.toSignificant(
                (parsedAmounts[SwapField.INPUT]?.currency.decimals || 6) / 2,
            ),
            baseCurrency,
        ),
    );
    const { formatted: fiatValueOutputFormatted } = useUSDCValue(
        tryParseAmount(
            parsedAmounts[SwapField.OUTPUT]?.toSignificant(
                (parsedAmounts[SwapField.OUTPUT]?.currency.decimals || 6) / 2,
            ),
            quoteCurrency,
        ),
    );

    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: showWrap
            ? parsedAmounts[independentField]?.toExact() ?? ""
            : parsedAmounts[dependentField]?.toFixed(
                  (parsedAmounts[dependentField]?.currency.decimals || 6) / 2,
              ) ?? "",
    };

    return (
        <div className="relative">
            <_Title>
                You{" "}
                {showWrap ? <span className="capitalize">{wrapType.toLowerCase()}</span> : "Pay"}{" "}
            </_Title>
            <TokenCard
                value={formattedAmounts[SwapField.INPUT] || ""}
                currency={baseCurrency}
                otherCurrency={quoteCurrency}
                handleTokenSelection={handleInputSelect}
                handleValueChange={handleTypeInput}
                handleMaxValue={handleMaxInput}
                fiatValue={fiatValueInputFormatted ?? undefined}
                showMaxButton={showMaxButton}
                showBalance={true}
            />
            <SwitchBar className="mb-[12px] mt-[24px] m:mt-[12px]" />
            <_Title>You Receive</_Title>
            <TokenCard
                value={formattedAmounts[SwapField.OUTPUT] || ""}
                currency={quoteCurrency}
                otherCurrency={baseCurrency}
                handleTokenSelection={handleOutputSelect}
                handleValueChange={handleTypeOutput}
                fiatValue={fiatValueOutputFormatted ?? undefined}
                showBalance={true}
            />
        </div>
    );
};

export default memo(SwapPair);



================================================
File: src/components/swap/SwapParams/index.tsx
================================================
import Collapsible from "@/components/common/Collapsible";
import Image from "@/components/common/Image";
import InfoBase from "@/components/common/Info/InfoBase";
import InfoItem from "@/components/common/Info/InfoItem";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { usePoolPlugins } from "@/hooks/pools/usePoolPlugins";
import useWrapCallback, { WrapType } from "@/hooks/swap/useWrapCallback";
import { useDerivedSwapInfo, useSwapState } from "@/state/swapStore";
import { SwapField } from "@/types/swap-field";
import { computeRealizedLPFeePercent, warningSeverity } from "@/utils/swap/prices";
import { Currency, Percent, Trade, TradeType, unwrappedToken } from "@glyph-exchange/integral-sdk";
import { Fragment, useMemo, useState } from "react";

const SwapParams = () => {
    const {
        tradeState,
        toggledTrade: trade,
        allowedSlippage,
        poolAddress,
        currencies,
    } = useDerivedSwapInfo();
    const { typedValue } = useSwapState();

    const { wrapType } = useWrapCallback(
        currencies[SwapField.INPUT],
        currencies[SwapField.OUTPUT],
        typedValue,
    );

    const [isExpanded, toggleExpanded] = useState(false);

    const { dynamicFeePlugin } = usePoolPlugins(poolAddress);

    const isMobile = useMediaQuery("mobile");

    const adaptiveFee = useMemo(() => {
        if (!tradeState.fee) return;

        let p = 100;

        for (const fee of tradeState.fee) {
            p = p * (1 - Number(fee) / 1_000_000);
        }

        return 100 - p;
    }, [tradeState.fee]);

    const { realizedLPFee, priceImpact } = useMemo(() => {
        if (!trade) return { realizedLPFee: undefined, priceImpact: undefined };

        const realizedLpFeePercent = computeRealizedLPFeePercent(trade);
        const realizedLPFee = trade.inputAmount.multiply(realizedLpFeePercent);
        const priceImpact = trade.priceImpact.subtract(realizedLpFeePercent);
        return { priceImpact, realizedLPFee };
    }, [trade]);

    const LPFeeString = realizedLPFee
        ? `${realizedLPFee.toSignificant(4)} ${realizedLPFee.currency.symbol}`
        : "-";

    if (wrapType !== WrapType.NOT_APPLICABLE) return;

    return trade ? (
        <InfoBase className="-mt-[10px] !gap-0">
            <Collapsible
                expanded={isExpanded}
                toggleExpanded={toggleExpanded}
                triggerClassName="!w-full justify-between"
                arrowSize={isMobile ? 12 : 20}
                title={
                    <InfoItem
                        label={
                            <span className="flex items-center gap-[8px]">
                                {dynamicFeePlugin && (
                                    <Image
                                        src="/light.svg"
                                        width={isMobile ? 14 : 20}
                                        height={isMobile ? 14 : 20}
                                    />
                                )}
                                <span>{`${adaptiveFee?.toFixed(3)}% FEE`}</span>
                            </span>
                        }
                    />
                }
            >
                <div className="mt-[12px] flex flex-col gap-[8px]">
                    <InfoItem label="Order Routing" value={<SwapRoute trade={trade} />} />
                    <InfoItem
                        label={
                            trade.tradeType === TradeType.EXACT_INPUT ? "Min.received" : "Max.sent"
                        }
                        value={
                            trade.tradeType === TradeType.EXACT_INPUT
                                ? `${trade.minimumAmountOut(allowedSlippage).toSignificant(6)} ${trade.outputAmount.currency.symbol}`
                                : `${trade.maximumAmountIn(allowedSlippage).toSignificant(6)} ${trade.inputAmount.currency.symbol}`
                        }
                    />
                    <InfoItem label="LP Fee" value={LPFeeString} />
                    <InfoItem
                        label="Price Impact"
                        value={<PriceImpact priceImpact={priceImpact} />}
                    />
                    <InfoItem label="Slippage tolerance" value={allowedSlippage.toFixed(2) + "%"} />
                </div>
            </Collapsible>
        </InfoBase>
    ) : (
        <></>
    );
};

const SwapRoute = ({ trade }: { trade: Trade<Currency, Currency, TradeType> }) => {
    const path = trade.route.tokenPath;

    return (
        <span className="truncate">
            {path.map((token, idx, path) => (
                <Fragment key={`token-path-${idx}`}>
                    {unwrappedToken(token).symbol}
                    {idx === path.length - 1 ? null : " > "}
                </Fragment>
            ))}
        </span>
    );
};

const PriceImpact = ({ priceImpact }: { priceImpact: Percent | undefined }) => {
    const severity = warningSeverity(priceImpact);

    const color =
        severity === 3 || severity === 4
            ? "text-[#fd375b]"
            : severity === 2
              ? "text-[#F7931A]"
              : "text-black";

    return (
        <span className={color}>
            {priceImpact ? `${priceImpact.multiply(-1).toFixed(2)}%` : "-"}
        </span>
    );
};

export default SwapParams;



================================================
File: src/components/swap/TokenCard/index.tsx
================================================
import CurrencyLogo from "@/components/common/CurrencyLogo";
import Image from "@/components/common/Image";
import TokenSelectorModal from "@/components/modals/TokenSelectorModal";
import { Input } from "@/components/ui/input";
import { formatBalance } from "@/utils/common/formatBalance";
import { formatUSD } from "@/utils/common/formatUSD";
import { Currency, Percent } from "@glyph-exchange/integral-sdk";
import { memo, useCallback, useMemo, useState } from "react";
import tw, { styled } from "twin.macro";
import { Address, useAccount, useBalance } from "wagmi";

const _Card = styled.div<{ $focus: boolean }>`
    padding: 15px 16px;
    background-color: ${({ $focus }) => ($focus ? "#F5F5F5" : "#E8E8E8")};

    ${() => tw`w-full rounded-[4px] duration-200 b1 m:p-[15px_12px]`};
`;

const _CurrencyBtn = styled.button`
    border: 1px solid #000;
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    padding: 8px 12px;

    ${() =>
        tw`flex max-w-[60%] shrink-0 items-center gap-[8px] rounded-[4px] !bg-white m:gap-[6px] m:p-[6px_8px] m:text-[10px]`}
`;

const _Input = styled(Input)`
    color: #000;
    text-align: right;
    font-family: FraktionMono-Bold;
    font-size: 18px;
    font-style: normal;
    font-weight: 700;
    line-height: 120%;

    ${() =>
        tw`h-full max-w-[60%] rounded-none border-none p-0 disabled:cursor-not-allowed m:text-[16px]`}
`;

const _Row = styled.div`
    ${() => tw`flex min-w-0 items-center justify-between gap-[8px]`}
`;

const _Value = styled.div`
    color: #999;
    text-align: right;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;
    letter-spacing: -0.24px;

    ${() => tw`flex min-w-0 items-center m:text-[10px]`}
`;

const _MaxBtn = styled.button`
    color: #000;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    ${() => tw`uppercase m:text-[10px]`}
`;

interface TokenSwapCardProps {
    handleTokenSelection: (currency: Currency) => void;
    handleValueChange?: (value: string) => void;
    handleMaxValue?: () => void;
    value: string;
    currency: Currency | null | undefined;
    otherCurrency: Currency | null | undefined;
    fiatValue?: number;
    priceImpact?: Percent;
    showMaxButton?: boolean;
    showBalance?: boolean;
    showNativeToken?: boolean;
    disabled?: boolean;
}

const TokenCard = ({
    handleTokenSelection,
    handleValueChange,
    handleMaxValue,
    value,
    currency,
    otherCurrency,
    fiatValue,
    showMaxButton,
    showBalance = true,
    showNativeToken,
    disabled,
}: TokenSwapCardProps) => {
    const [isOpen, setIsOpen] = useState(false);
    const [focus, setFocus] = useState(false);

    const { address: account } = useAccount();

    const { data: balance, isLoading } = useBalance({
        address: account,
        token: currency?.isNative ? undefined : (currency?.wrapped.address as Address),
        // watch: true,
    });

    const balanceString = useMemo(() => {
        if (isLoading || !balance) return "Loading...";

        return formatBalance(balance.formatted);
    }, [balance, isLoading]);

    const handleInput = useCallback((value: string) => {
        if (value === ".") value = "0.";
        handleValueChange?.(value);
    }, []);

    const handleTokenSelect = useCallback(
        (newCurrency: Currency) => {
            setIsOpen(false);
            handleTokenSelection(newCurrency);
        },
        [handleTokenSelection],
    );

    return (
        <_Card $focus={focus}>
            <_Row>
                <TokenSelectorModal
                    showNativeToken={showNativeToken}
                    onSelect={handleTokenSelect}
                    isOpen={isOpen}
                    setIsOpen={setIsOpen}
                    otherCurrency={otherCurrency}
                >
                    <_CurrencyBtn onClick={() => setIsOpen(true)}>
                        <CurrencyLogo currency={currency} size={16} />
                        <span className="truncate">
                            {currency ? currency.symbol : "Select a token"}
                        </span>
                        <Image
                            className="shrink-0"
                            width={16}
                            height={16}
                            src="/icon_bottom_arrow.svg"
                        />
                    </_CurrencyBtn>
                </TokenSelectorModal>
                <_Input
                    onFocus={() => setFocus(true)}
                    onBlur={() => setFocus(false)}
                    disabled={disabled}
                    type={"text"}
                    value={value}
                    id={`amount-${currency?.symbol}`}
                    onUserInput={(v) => handleInput(v)}
                    placeholder={"0"}
                    maxDecimals={currency?.decimals}
                />
            </_Row>

            {showBalance && (
                <_Row className="mt-[12px] m:mt-[10px]">
                    {currency && (
                        <_Row className="max-w-[60%] !gap-[4px]">
                            <_Value>
                                <span className="truncate">
                                    Balance: {account ? balanceString : "-"}
                                </span>
                            </_Value>
                            {showMaxButton && <_MaxBtn onClick={handleMaxValue}>Max</_MaxBtn>}
                        </_Row>
                    )}
                    <_Value className="max-w-[60%]">
                        <span className="truncate">
                            {fiatValue && "~" + formatUSD.format(fiatValue)}
                        </span>
                    </_Value>
                </_Row>
            )}
        </_Card>
    );
};

export default memo(TokenCard);



================================================
File: src/components/swap/V4AMMPanel/SwapButton.tsx
================================================
import FloatingButton from "@/components/common/FloatingButton";
import Loader from "@/components/common/Loader";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import { useApproveCallbackFromTrade } from "@/hooks/common/useApprove";
import { useSwapCallback } from "@/hooks/swap/useSwapCallback";
import useWrapCallback, { WrapType } from "@/hooks/swap/useWrapCallback";
import { useDerivedSwapInfo, useSwapState } from "@/state/swapStore";
import { useUserState } from "@/state/userStore";
import { ApprovalState } from "@/types/approve-state";
import { SwapField } from "@/types/swap-field";
import { TradeState } from "@/types/trade-state";
import { computeRealizedLPFeePercent, warningSeverity } from "@/utils/swap/prices";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import { useCallback, useEffect, useMemo, useState } from "react";
import { useAccount } from "wagmi";
import { waitForTransaction } from "@wagmi/core";

const SwapButton = () => {
    const { open } = useWeb3Modal();

    const { selectedNetworkId } = useWeb3ModalState();

    const { address: account } = useAccount();

    const { isExpertMode } = useUserState();

    const { independentField, typedValue } = useSwapState();
    const {
        tradeState,
        toggledTrade: trade,
        allowedSlippage,
        parsedAmount,
        currencies,
        inputError: swapInputError,
    } = useDerivedSwapInfo();

    const {
        wrapType,
        execute: onWrap,
        loading: isWrapLoading,
        inputError: wrapInputError,
        confirmLoading: isWrapConfirmLoading,
    } = useWrapCallback(currencies[SwapField.INPUT], currencies[SwapField.OUTPUT], typedValue);

    const showWrap = wrapType !== WrapType.NOT_APPLICABLE;

    const parsedAmountA = independentField === SwapField.INPUT ? parsedAmount : trade?.inputAmount;

    const parsedAmountB =
        independentField === SwapField.OUTPUT ? parsedAmount : trade?.outputAmount;

    const parsedAmounts = useMemo(
        () => ({
            [SwapField.INPUT]: parsedAmountA,
            [SwapField.OUTPUT]: parsedAmountB,
        }),
        [parsedAmountA, parsedAmountB],
    );

    const userHasSpecifiedInputOutput = Boolean(
        currencies[SwapField.INPUT] &&
            currencies[SwapField.OUTPUT] &&
            parsedAmounts[independentField]?.greaterThan("0"),
    );

    const routeNotFound = !trade?.route;
    const isLoadingRoute = TradeState.LOADING === tradeState.state;

    const { approvalState, approvalCallback } = useApproveCallbackFromTrade(trade, allowedSlippage);

    const priceImpactSeverity = useMemo(() => {
        if (!trade) return 4;
        const realizedLpFeePercent = computeRealizedLPFeePercent(trade);
        const priceImpact = trade.priceImpact.subtract(realizedLpFeePercent);
        return warningSeverity(priceImpact);
    }, [trade]);

    const showApproveFlow =
        !swapInputError &&
        (approvalState === ApprovalState.NOT_APPROVED || approvalState === ApprovalState.PENDING) &&
        !(priceImpactSeverity > 3 && !isExpertMode);

    const {
        callback: swapCallback,
        error: swapCallbackError,
        isLoading: isSwapLoading,
        confirmLoading: isSwapConfirmLoading,
    } = useSwapCallback(trade, allowedSlippage, approvalState);

    const [startSwap, setStartSwap] = useState(false);

    const handleApproval = useCallback(async () => {
        const tx = await approvalCallback?.();
        if (tx) {
            await waitForTransaction({ hash: tx.hash, confirmations: 1 });
            setStartSwap(true);
        }
    }, [approvalCallback]);

    const handleSwap = useCallback(async () => {
        if (!swapCallback) return;
        try {
            await swapCallback();
        } catch (error) {
            return new Error(`Swap Failed ${error}`);
        }
    }, [swapCallback]);

    useEffect(() => {
        try {
            if (startSwap && swapCallback) {
                setStartSwap(false);
                swapCallback();
            }
        } catch (error) {
            new Error(`Swap Failed ${error}`);
        }
    }, [startSwap, swapCallback]);

    const isValid = !swapInputError;

    const priceImpactTooHigh = priceImpactSeverity > 3 && !isExpertMode;

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    if (!account) return <FloatingButton onClick={() => open()}>Connect Wallet</FloatingButton>;

    if (isWrongChain)
        return (
            <FloatingButton
                onClick={() => open({ view: "Networks" })}
            >{`Switch to ${DEFAULT_CHAIN_NAME}`}</FloatingButton>
        );

    if (showWrap && wrapInputError)
        return <FloatingButton disabled>{wrapInputError}</FloatingButton>;

    if (showWrap)
        return (
            <FloatingButton
                disabled={isWrapLoading || isWrapConfirmLoading}
                onClick={() => onWrap && onWrap()}
            >
                {isWrapLoading || isWrapConfirmLoading ? (
                    <Loader />
                ) : wrapType === WrapType.WRAP ? (
                    "Wrap"
                ) : (
                    "Unwrap"
                )}
            </FloatingButton>
        );

    if (routeNotFound && userHasSpecifiedInputOutput)
        return (
            <FloatingButton disabled>
                {isLoadingRoute ? <Loader /> : "Insufficient Liquidity"}
            </FloatingButton>
        );

    if (showApproveFlow)
        return (
            <FloatingButton
                disabled={approvalState !== ApprovalState.NOT_APPROVED}
                onClick={() => handleApproval()}
            >
                {approvalState === ApprovalState.PENDING ? (
                    <Loader />
                ) : approvalState === ApprovalState.APPROVED ? (
                    "Approved"
                ) : (
                    `Approve ${currencies[SwapField.INPUT]?.symbol}`
                )}
            </FloatingButton>
        );

    return (
        <>
            <FloatingButton
                onClick={() => handleSwap()}
                disabled={
                    !isValid ||
                    priceImpactTooHigh ||
                    !!swapCallbackError ||
                    isSwapLoading ||
                    isSwapConfirmLoading
                }
            >
                {isSwapLoading || isSwapConfirmLoading ? (
                    <Loader />
                ) : swapInputError ? (
                    swapInputError
                ) : priceImpactTooHigh ? (
                    "Price Impact Too High"
                ) : priceImpactSeverity > 2 ? (
                    "Swap"
                ) : (
                    "Swap"
                )}
            </FloatingButton>
        </>
    );
};

export default SwapButton;



================================================
File: src/components/swap/V4AMMPanel/index.tsx
================================================
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import { SettingModal } from "@/components/common/Settings";
import { memo } from "react";
import tw, { styled } from "twin.macro";
import SwapPair from "../SwapPair";
import SwapButton from "./SwapButton";
import SwapParams from "../SwapParams";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PoweredByAlgebra from "@/components/common/PoweredBy/Algebra";

const _V4AMMPanel = styled.div`
    ${() => tw``}
`;
const V4AMMPanel: FCProps = ({ className, style }) => {
    return (
        <_V4AMMPanel className={className} style={style}>
            <PanelBase>
                <PanelTitle title="SWAP V4" />
                <PanelContainer>
                    <div className="[padding:20px_24px_42px] m:[padding:16px_20px_36px]">
                        <SettingModal />

                        <div className="mt-[14px]">
                            <SwapPair />
                        </div>
                        <div className="mt-[40px] m:mt-[28px]">
                            <SwapButton />
                        </div>
                    </div>
                    <SwapParams />
                </PanelContainer>
                <PanelFooter />
            </PanelBase>

            <PoweredByAlgebra className="mt-[24px] m:mt-[20px]" />
        </_V4AMMPanel>
    );
};

export default memo(V4AMMPanel);



================================================
File: src/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
File: src/components/ui/button.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import tw, { styled } from "twin.macro";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    {
        variants: {
            variant: {
                default: "bg-primary text-primary-foreground hover:bg-primary/90",
                action: "bg-primary-button text-primary-foreground font-bold hover:bg-primary-button/80",
                destructive:
                    "bg-destructive text-destructive-foreground hover:bg-destructive/80 font-semibold",
                outline: "border border-card-border bg-background hover:bg-card-hover",
                secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
                ghost: "hover:bg-card-hover",
                link: "text-primary underline-offset-4 hover:underline",
                icon: "font-semibold hover:bg-card-hover",
                iconActive:
                    "font-semibold text-primary-text bg-muted-primary hover:bg-muted-primary",
            },
            size: {
                default: "h-10 px-4 py-2",
                sm: "h-9 rounded-2xl px-3",
                md: "h-6 rounded-2xl p-4 py-6",
                lg: "rounded-2xl text-md p-4",
                icon: "h-10 w-10 rounded-2xl",
            },
        },
        defaultVariants: {
            variant: "action",
            size: "lg",
        },
    },
);

export interface ButtonProps
    extends React.ButtonHTMLAttributes<HTMLButtonElement>,
        VariantProps<typeof buttonVariants> {
    asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, asChild = false, ...props }, ref) => {
        const Comp = asChild ? Slot : "button";
        return (
            <Comp
                className={cn(
                    "font-[Geneva] text-[14px]",
                    buttonVariants({ variant, size, className }),
                )}
                ref={ref}
                {...props}
            />
        );
    },
);
Button.displayName = "Button";

const Button2 = styled.button`
    color: #fff;
    font-family: Geneva;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 120%;

    &:disabled {
        border-color: #858484;
        background: #bbb;
        color: #858484;
        cursor: not-allowed;
    }
    ${() =>
        tw`flex h-[47px] items-center justify-center rounded-[6px] bg-black p-[10px_16px] transition-colors b1 m:h-[33px] m:p-[9px_12px] m:text-[12px]`}
`;

export { Button, buttonVariants, Button2 };



================================================
File: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
File: src/components/ui/credenza.tsx
================================================
"use client";

import * as React from "react";

import { cn } from "@/lib/utils";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import {
    Dialog,
    DialogClose,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
    DialogTrigger,
} from "@/components/ui/dialog";
import {
    Drawer,
    DrawerClose,
    DrawerContent,
    DrawerDescription,
    DrawerFooter,
    DrawerHeader,
    DrawerTitle,
    DrawerTrigger,
} from "@/components/ui/drawer";

interface BaseProps {
    children: React.ReactNode;
}

interface RootCredenzaProps extends BaseProps {
    className?: string;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
}

interface CredenzaProps extends BaseProps {
    className?: string;
    asChild?: true;
}

const Credenza = ({ children, ...props }: RootCredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const Credenza = isDesktop ? Dialog : Drawer;

    return <Credenza {...props}>{children}</Credenza>;
};

const CredenzaTrigger = ({ className, children, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaTrigger = isDesktop ? DialogTrigger : DrawerTrigger;

    return (
        <CredenzaTrigger className={className} {...props}>
            {children}
        </CredenzaTrigger>
    );
};

const CredenzaClose: FCProps<any> = ({ className, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaClose = isDesktop ? DialogClose : DrawerClose;

    return <CredenzaClose className={className} {...props} />;
};

const CredenzaContent = ({
    className,
    children,
    ...props
}: CredenzaProps & { onInteractOutside: () => void; onEscapeKeyDown: () => void }) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaContent = isDesktop ? DialogContent : DrawerContent;

    return (
        <CredenzaContent className={className} {...props}>
            {children}
        </CredenzaContent>
    );
};

const CredenzaDescription = ({ className, children, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaDescription = isDesktop ? DialogDescription : DrawerDescription;

    return (
        <CredenzaDescription className={className} {...props}>
            {children}
        </CredenzaDescription>
    );
};

const CredenzaHeader = ({ className, children, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaHeader = isDesktop ? DialogHeader : DrawerHeader;

    return (
        <CredenzaHeader className={className} {...props}>
            {children}
        </CredenzaHeader>
    );
};

const CredenzaTitle = ({ className, children, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaTitle = isDesktop ? DialogTitle : DrawerTitle;

    return (
        <CredenzaTitle className={className} {...props}>
            {children}
        </CredenzaTitle>
    );
};

const CredenzaBody = ({ className, children, ...props }: CredenzaProps) => {
    return (
        <div className={cn("px-4 md:px-0", className)} {...props}>
            {children}
        </div>
    );
};

const CredenzaFooter = ({ className, children, ...props }: CredenzaProps) => {
    const isDesktop = useMediaQuery("desktop");
    const CredenzaFooter = isDesktop ? DialogFooter : DrawerFooter;

    return (
        <CredenzaFooter className={className} {...props}>
            {children}
        </CredenzaFooter>
    );
};

export {
    Credenza,
    CredenzaTrigger,
    CredenzaClose,
    CredenzaContent,
    CredenzaDescription,
    CredenzaHeader,
    CredenzaTitle,
    CredenzaBody,
    CredenzaFooter,
};



================================================
File: src/components/ui/dialog.tsx
================================================
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";

import { cn } from "@/lib/utils";
import PanelBase from "../common/Panel/PanelBase";
import Image from "../common/Image";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Close>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Close>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Close
        ref={ref}
        className={cn("absolute right-[13px] top-[6px]", className)}
        {...props}
    >
        <Image src="/modal_close.svg" width={16} height={16} />
    </DialogPrimitive.Close>
));
DialogClose.displayName = DialogPrimitive.Close.displayName;

const DialogOverlay = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Overlay>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Overlay
        ref={ref}
        className={cn(
            "fixed inset-0 z-50 bg-[#333]/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
            className,
        )}
        {...props}
    />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
    <DialogPortal>
        <DialogOverlay />
        <DialogPrimitive.Content
            ref={ref}
            className={cn(
                "fixed left-[50%] top-[50%] z-50 grid w-full max-w-[434px] translate-x-[-50%] translate-y-[-50%] outline-none duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%]",
                className,
            )}
            {...props}
        >
            <PanelBase className={`max-w-[434px] ${className}`}>{children}</PanelBase>
        </DialogPrimitive.Content>
    </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
    <div
        className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)}
        {...props}
    />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
    <div
        className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
        {...props}
    />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Title>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Title
        ref={ref}
        className={cn("text-lg font-semibold leading-none tracking-tight", className)}
        {...props}
    />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Description>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
    <DialogPrimitive.Description
        ref={ref}
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
    />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
    Dialog,
    DialogPortal,
    DialogOverlay,
    DialogTrigger,
    DialogClose,
    DialogContent,
    DialogHeader,
    DialogFooter,
    DialogTitle,
    DialogDescription,
};



================================================
File: src/components/ui/drawer.tsx
================================================
import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({
    shouldScaleBackground = true,
    ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
    <DrawerPrimitive.Root shouldScaleBackground={shouldScaleBackground} {...props} />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
    React.ElementRef<typeof DrawerPrimitive.Overlay>,
    React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
    <DrawerPrimitive.Overlay
        ref={ref}
        className={cn("fixed inset-0 z-50 bg-[#333]/50", className)}
        {...props}
    />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
    React.ElementRef<typeof DrawerPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
    <DrawerPortal>
        <DrawerOverlay />
        <DrawerPrimitive.Content
            ref={ref}
            className={cn(
                "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col bg-white",
                className,
            )}
            {...props}
        >
            {children}
        </DrawerPrimitive.Content>
    </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
    <div className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)} {...props} />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
    <div className={cn("mt-auto flex flex-col gap-2 p-4", className)} {...props} />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
    React.ElementRef<typeof DrawerPrimitive.Title>,
    React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
    <DrawerPrimitive.Title
        ref={ref}
        className={cn("text-lg font-semibold leading-none tracking-tight", className)}
        {...props}
    />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
    React.ElementRef<typeof DrawerPrimitive.Description>,
    React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
    <DrawerPrimitive.Description
        ref={ref}
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
    />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
    Drawer,
    DrawerPortal,
    DrawerOverlay,
    DrawerTrigger,
    DrawerClose,
    DrawerContent,
    DrawerHeader,
    DrawerFooter,
    DrawerTitle,
    DrawerDescription,
};



================================================
File: src/components/ui/hover-card.tsx
================================================
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      "flex flex-col gap-2 bg-card rounded-3xl border border-card-border text-white w-fit",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }



================================================
File: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const inputRegex = RegExp(`^\\d*(?:\\\\[.])?\\d*$`);
export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  onUserInput?: (value: string) => void;
  maxDecimals?: number
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, onUserInput, maxDecimals = 18, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        onChange={e => {
          let value = e.target.value.replace(/,/g, ".")
          value = value.indexOf(".") >= 0 ? value.slice(0, value.indexOf(".") + maxDecimals + 1) : value
          if (value === "" || inputRegex.test(value.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))) {
            onUserInput && onUserInput(value)
          }
        }}
        inputMode={'decimal'}
        pattern="^[0-9]*[.,]?[0-9]*$"
        minLength={1}
        maxLength={100}
        spellCheck="false"
        autoComplete="off"
        autoCorrect="off"
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
File: src/components/ui/pagination.tsx
================================================
import { memo } from "react";
import { Pagination as ReactPagination } from "react-headless-pagination";
import tw, { styled } from "twin.macro";
import Image from "../common/Image";
import { theme } from "twin.macro";

interface PaginationProps {
    totalPages: number;
    page: number;
    handlePageChange: (page: number) => void;
}

const _PageButton = styled(ReactPagination.PageButton)`
    text-align: center;
    font-family: Geneva;
    font-size: 12px;
    font-weight: 400;
    line-height: 120%;

    ${() =>
        tw`flex h-[32px] w-[32px] cursor-pointer items-center justify-center [border:1px_solid_#fff] hover:bg-[#E8E8E8] m:h-[24px] m:w-[24px]`}

    @media (max-width: ${theme`screens.mobile.max`}) {
        font-size: 10px;
    }
`;

const Pagination: FCProps<PaginationProps> = ({
    totalPages,
    page,
    handlePageChange,
    className,
}) => {
    return (
        <>
            <ReactPagination
                totalPages={totalPages}
                edgePageCount={2}
                middlePagesSiblingCount={1}
                currentPage={page}
                setCurrentPage={handlePageChange}
                className={`flex items-center gap-[8px] ${className}`}
                truncableText="..."
                truncableClassName=""
            >
                <ReactPagination.PrevButton
                    className={`flex h-[32px] w-[32px] cursor-pointer items-center justify-center rounded-[8px] bg-[#FFF] [border:1px_solid_#fff] m:h-[24px] m:w-[24px] ${page === 0 && "!cursor-not-allowed"}`}
                >
                    <img
                        width={16}
                        height={16}
                        src={
                            page === 0 ? "/icon_left_arrow_gray.svg" : "/icon_left_arrow_black.svg"
                        }
                        alt=""
                    />
                </ReactPagination.PrevButton>

                <nav className="flex justify-center">
                    <ul className="flex items-center gap-[8px] text-[#000]">
                        <_PageButton
                            activeClassName="bg-[#000] text-[#FFF] hover:!bg-[#000]"
                            inactiveClassName="bg-[#FFF] text-[#000]"
                        />
                    </ul>
                </nav>

                <ReactPagination.NextButton
                    className={`flex h-[32px] w-[32px] cursor-pointer items-center justify-center rounded-[8px] bg-[#FFF] [border:1px_solid_#fff] m:h-[24px] m:w-[24px] ${page === totalPages - 1 && "!cursor-not-allowed"}`}
                >
                    <Image
                        width={16}
                        height={16}
                        src={
                            page === totalPages - 1
                                ? "/icon_right_arrow_gray.svg"
                                : "/icon_right_arrow_black.svg"
                        }
                        alt=""
                    />
                </ReactPagination.NextButton>
            </ReactPagination>
        </>
    );
};

export default memo(Pagination);



================================================
File: src/components/ui/popover.tsx
================================================
import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@/lib/utils';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
    React.ElementRef<typeof PopoverPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
    <PopoverPrimitive.Portal>
        <PopoverPrimitive.Content
            ref={ref}
            align={align}
            sideOffset={sideOffset}
            className={cn(
                'z-50 w-48 rounded-3xl border bg-card p-4 text-white shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className
            )}
            {...props}
        />
    </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };



================================================
File: src/components/ui/separator.tsx
================================================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }



================================================
File: src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
File: src/components/ui/slider.tsx
================================================
import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";
import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
    React.ElementRef<typeof SliderPrimitive.Root>,
    React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
    <div className={cn("flex h-[40px] w-full items-center overflow-hidden", className)}>
        <div className="relative h-[22px] w-full rounded-[14px] bg-white px-[7px] b1">
            <SliderPrimitive.Root
                ref={ref}
                className="absolute inset-[4px] grow cursor-pointer touch-none select-none rounded-[6px] bg-[url('/bg-fragment.png')] b1"
                {...props}
            >
                <SliderPrimitive.Thumb className="block !h-[40px] !w-[19px] translate-y-[-15px] bg-[url('/slider-icon.svg')] bg-no-repeat transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50" />
            </SliderPrimitive.Root>
        </div>
    </div>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };



================================================
File: src/components/ui/switch.tsx
================================================
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
    React.ElementRef<typeof SwitchPrimitives.Root>,
    React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
    <SwitchPrimitives.Root
        className={cn(
            "peer inline-flex h-[14px] w-[28px] shrink-0 cursor-pointer items-center rounded-[3px] transition-colors [border:1px_solid_#000] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-[#FFEBCE] data-[state=unchecked]:bg-[#FFF]",
            className,
        )}
        {...props}
        ref={ref}
    >
        <SwitchPrimitives.Thumb
            className={cn(
                "pointer-events-none block h-[10px] w-[10px] rounded-[2px] bg-[#000] shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-[15px] data-[state=unchecked]:translate-x-[1.5px] data-[state=checked]:bg-[#000]",
            )}
        />
    </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };



================================================
File: src/components/ui/table.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
    ({ className, ...props }, ref) => (
        <div className="relative w-full overflow-auto m:flex-1">
            <table ref={ref} className={cn("w-full caption-bottom", className)} {...props} />
        </div>
    ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<
    HTMLTableSectionElement,
    React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
    <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
    HTMLTableSectionElement,
    React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => <tbody ref={ref} className={cn(className)} {...props} />);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
    HTMLTableSectionElement,
    React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
    <tfoot
        ref={ref}
        className={cn("bg-primary font-medium text-primary-foreground", className)}
        {...props}
    />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
    ({ className, ...props }, ref) => (
        <tr ref={ref} className={cn("data-[state=selected]:bg-[#FFF]", className)} {...props} />
    ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
    HTMLTableCellElement,
    React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
    <th
        ref={ref}
        className={cn(
            "h-[36px] px-[24px] text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
            className,
        )}
        {...props}
    />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
    HTMLTableCellElement,
    React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
    <td
        ref={ref}
        className={cn(
            "align-middle [padding:0_14px_0_24px] [&:has([role=checkbox])]:pr-0",
            className,
        )}
        {...props}
    />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
    HTMLTableCaptionElement,
    React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
    <caption ref={ref} className={cn("mt-4 text-sm text-muted-foreground", className)} {...props} />
));
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };



================================================
File: src/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
File: src/components/ui/toast.tsx
================================================
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Viewport>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
    <ToastPrimitives.Viewport
        ref={ref}
        className={cn(
            "fixed left-0 top-[60px] z-[100] flex w-full max-w-[409px] flex-col-reverse gap-4 p-[48px] m:top-[56px] m:max-w-[unset] m:gap-[8px] m:[padding:15px_20px]",
            className,
        )}
        // className={cn(
        //   "fixed top-0 z-[100] flex gap-4 max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        //   className
        // )}
        {...props}
    />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
    "group pointer-events-auto relative flex w-full items-center overflow-hidden transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-left-full data-[state=open]:slide-in-from-top-full",

    // "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
    {
        variants: {
            variant: {
                default: "text-left",
                destructive: "",
                // default: "border bg-background text-foreground bg-card border-card-border rounded-3xl text-left",
                // destructive:
                //   "destructive group border-destructive bg-destructive text-destructive-foreground",
            },
        },
        defaultVariants: {
            variant: "default",
        },
    },
);

const Toast = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Root>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
    return (
        <ToastPrimitives.Root
            ref={ref}
            className={cn(toastVariants({ variant }), className)}
            {...props}
        />
    );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Action>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
    <ToastPrimitives.Action
        ref={ref}
        className={cn(
            "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
            className,
        )}
        {...props}
    />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Close>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
    <ToastPrimitives.Close
        ref={ref}
        className={cn(
            "absolute right-[12px] top-[13px] p-[4px] text-[black] m:right-[16px] m:p-[1px]",
            className,
        )}
        // className={cn(
        //   "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
        //   className
        // )}
        toast-close=""
        {...props}
    >
        <X className="h-[16px] w-[16px] m:h-[14px] m:w-[14px]" />
    </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Title>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
    <ToastPrimitives.Title
        ref={ref}
        className={cn(
            "font-[FraktionMono-Bold] text-[14px] font-bold leading-[1.2] text-[#000]",
            className,
        )}
        {...props}
    />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Description>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
    <ToastPrimitives.Description
        ref={ref}
        className={cn(
            "font-[Geneva] text-[12px] leading-[1.2] text-[#999] m:text-[10px]",
            className,
        )}
        {...props}
    />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
    type ToastProps,
    type ToastActionElement,
    ToastProvider,
    ToastViewport,
    Toast,
    ToastTitle,
    ToastDescription,
    ToastClose,
    ToastAction,
};



================================================
File: src/components/ui/toaster.tsx
================================================
import {
    Toast,
    ToastClose,
    ToastDescription,
    ToastProvider,
    ToastTitle,
    ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";
import LineBoxBase from "../common/LineBoxBase";
import tw, { styled, theme } from "twin.macro";

const _BoxBase = styled(LineBoxBase)`
    ${() => tw`w-[100%]`}

    >.inner {
        padding: 16px;
        ${() => tw`relative flex items-center`}
    }

    @media (max-width: ${theme`screens.mobile.max`}) {
        > .inner {
            padding: 12px 16px;
        }
    }
`;

export function Toaster() {
    const { toasts } = useToast();

    return (
        <ToastProvider>
            {toasts.map(function ({ id, title, description, action, ...props }) {
                return (
                    <Toast key={id} {...props}>
                        <_BoxBase>
                            <div className="flex flex-col items-start gap-[4px]">
                                {title && (
                                    <ToastTitle>
                                        <div className="flex items-center gap-[4px] m:gap-[8px]">
                                            {title}
                                            {action}
                                        </div>
                                    </ToastTitle>
                                )}
                                {description && <ToastDescription>{description}</ToastDescription>}
                            </div>
                            <ToastClose />
                        </_BoxBase>
                    </Toast>
                );
            })}
            <ToastViewport />
        </ToastProvider>
    );
}



================================================
File: src/components/ui/use-toast.ts
================================================
// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 3
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
    type: ActionType["ADD_TOAST"]
    toast: ToasterToast
  }
  | {
    type: ActionType["UPDATE_TOAST"]
    toast: Partial<ToasterToast>
  }
  | {
    type: ActionType["DISMISS_TOAST"]
    toastId?: ToasterToast["id"]
  }
  | {
    type: ActionType["REMOVE_TOAST"]
    toastId?: ToasterToast["id"]
  }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
              ...t,
              open: false,
            }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



================================================
File: src/constants/addresses.ts
================================================
import { Environment } from "@/types/common";

const VITE_ENVIRONMENT =
    import.meta.env?.VITE_ENVIRONMENT ?? process.env?.VITE_ENVIRONMENT ?? Environment.PROD;

const ADDRESSES_ENV: AddressesEnv = {
    [Environment.PROD]: {
        POOL_INIT_CODE_HASH: "0xf96d2474815c32e070cd63233f06af5413efc5dcb430aee4ff18cc29007c562d",
        ALGEBRA_FACTORY: "0x74EfE55beA4988e7D92D03EFd8ddB8BF8b7bD597",
        ALGEBRA_POOL_DEPLOYER: "0x24196b3f35E1B8313016b9f6641D605dCf48A76a",
        ALGEBRA_POSITION_MANAGER: "0x7b3794f728780A61e0eB709b5bB849F50aad1E7f",
        ALGEBRA_QUOTER: "0x6DC367969b2D856070dBC56f086890DF1bB70885",
        ALGEBRA_QUOTER_V2: "0x20dA24b5FaC067930Ced329A3457298172510Fe7",
        ALGEBRA_ROUTER: "0x832933BA44658C50ae6152039Cd30A6f4C2432b1",
        ALGEBRA_ETERNAL_FARMING: "0xf3784e22F36FfA9292423b08392726440F5Fe81E",
        FARMING_CENTER: "0xd2eD85385a2B884Bd77B5BBCE368C8A2cBdD3e27",
        ICECREAM_SWAPROUTER: "0xAB8b5ced00DcF751F7954f2763E3d759e9409A45",

        GAMMA_UNIPROXY: "0x8a9570ec97534277ade6e46d100939fbce4968f0",

        USDT: "0x900101d06a7426441ae63e9ab3b9b0f63be145f1",
        WBTC: "0x5832f53d147b3d6cd4578b9cbd62425c7ea9d0bd",
        coreBTC: "0x8034ab88c3512246bf7894f57c834dddbd1de01f",
        GP: "0x86b8c90fe6532fa328ce25a44e09f690bb3b4856",
        dualCORELP: "0x87bfd9b4231aaf41d5b2cd4d847e7dc2161e0633",
        aBTC: "0x70727228db8c7491bf0ad42c180dbf8d95b257e2",
    },
    [Environment.DEV]: {
        POOL_INIT_CODE_HASH: "0xf96d2474815c32e070cd63233f06af5413efc5dcb430aee4ff18cc29007c562d",
        ALGEBRA_FACTORY: "0x5eEE9D8668356f2482a4aaC9eb4040529C4b4DEe",
        ALGEBRA_POOL_DEPLOYER: "0xBF8E4eee4c0584D71E43c00df345bc40B02d52D6",
        ALGEBRA_POSITION_MANAGER: "0x5322c08603C7C17fbC5cf68e9Ad7919865EEfE2f",
        ALGEBRA_QUOTER: "0x6E06516359756d57d3E15D1253D8e39Aa1A18699",
        ALGEBRA_QUOTER_V2: "0x627A5f579Ff3266bCE37b318693Af48Efd292a69",
        ALGEBRA_ROUTER: "0x40bFf03AD7C6b61F3a69f23FAfbAc63bb0c2B908",
        ALGEBRA_ETERNAL_FARMING: "0x87dc32eb7dC43E273f9e9508903617Dc2f5Af539",
        FARMING_CENTER: "0x24E18AdF059597865E8826A00a1DD1fE9A4FdfCb",
        ICECREAM_SWAPROUTER: "0x",

        GAMMA_UNIPROXY: "0x",

        USDT: "0x9cf7ea86e0fb5fc729fda2958eba35430a7b48f1",
        G: "0xeb386ff30229dc78b2d552ef68c79cb85069e37f",
        GP: "0x08780728436a47e52f02ede3a516fddba07968db",
        dualCORELP: "0x87bfd9b4231aaf41d5b2cd4d847e7dc2161e0633",
        aBTC: "0x70727228db8c7491bf0ad42c180dbf8d95b257e2",
    },
} as const;

export const ADDRESSES = ADDRESSES_ENV[VITE_ENVIRONMENT];

export const {
    POOL_INIT_CODE_HASH,
    ALGEBRA_FACTORY,
    ALGEBRA_POOL_DEPLOYER,
    ALGEBRA_POSITION_MANAGER,
    ALGEBRA_QUOTER,
    ALGEBRA_QUOTER_V2,
    ALGEBRA_ROUTER,
    ALGEBRA_ETERNAL_FARMING,
    FARMING_CENTER,
    GAMMA_UNIPROXY,
    ICECREAM_SWAPROUTER,
} = ADDRESSES;



================================================
File: src/constants/api.ts
================================================
import { Environment } from "@/types/common";

export const fetcher = (url: string) => fetch(url).then((res) => res.json());

const API_ENV: ApiEnv = {
    [Environment.PROD]: {
        eternalFarmings: `${import.meta.env.VITE_BACKEND_URL_PROD}/api/APR/eternalFarmings/?network=core`,
        poolsMax: `${import.meta.env.VITE_BACKEND_URL_PROD}/api/APR/pools/max?network=core`,
        poolsAvg: `${import.meta.env.VITE_BACKEND_URL_PROD}/api/APR/pools/?network=core`,
    },
    [Environment.DEV]: {
        eternalFarmings: `${import.meta.env.VITE_BACKEND_URL_DEV}/api/APR/eternalFarmings/?network=core-testnet`,
        poolsMax: `${import.meta.env.VITE_BACKEND_URL_DEV}/api/APR/pools/max?network=core-testnet`,
        poolsAvg: `${import.meta.env.VITE_BACKEND_URL_DEV}/api/APR/pools/?network=core-testnet`,
    },
};

export const ETERNAL_FARMINGS_API = API_ENV[import.meta.env.VITE_ENVIRONMENT].eternalFarmings;
export const POOL_MAX_APR_API = API_ENV[import.meta.env.VITE_ENVIRONMENT].poolsMax;
export const POOL_AVG_APR_API = API_ENV[import.meta.env.VITE_ENVIRONMENT].poolsAvg;



================================================
File: src/constants/default-chain-id.ts
================================================
import { Environment } from "@/types/common";

const DEFAULT_CHAIN_ENV: DefaultChainEnv = {
    [Environment.PROD]: {
        DEFAULT_CHAIN_ID: "0x45c",
        DEFAULT_CHAIN_NAME: "Core",
        DEFAULT_NATIVE_SYMBOL: "CORE",
        DEFAULT_NATIVE_NAME: "Core",
    },
    [Environment.DEV]: {
        DEFAULT_CHAIN_ID: "0x45b",
        DEFAULT_CHAIN_NAME: "Core Testnet",
        DEFAULT_NATIVE_SYMBOL: "tCORE",
        DEFAULT_NATIVE_NAME: "Core",
    },
};

export const DEFAULT_CHAIN_ID = Number(
    DEFAULT_CHAIN_ENV[import.meta.env.VITE_ENVIRONMENT].DEFAULT_CHAIN_ID,
);

export const DEFAULT_CHAIN_NAME =
    DEFAULT_CHAIN_ENV[import.meta.env.VITE_ENVIRONMENT].DEFAULT_CHAIN_NAME;

export const DEFAULT_NATIVE_SYMBOL =
    DEFAULT_CHAIN_ENV[import.meta.env.VITE_ENVIRONMENT].DEFAULT_NATIVE_SYMBOL;

export const DEFAULT_NATIVE_NAME =
    DEFAULT_CHAIN_ENV[import.meta.env.VITE_ENVIRONMENT].DEFAULT_NATIVE_NAME;



================================================
File: src/constants/max-uint128.ts
================================================
export const MAX_UINT128 = 340282366920938463463374607431768211455n


================================================
File: src/constants/routing.ts
================================================
import { WNATIVE, Token, ChainId } from "@glyph-exchange/integral-sdk";
import { STABLECOINS } from "./tokens";

type ChainTokenList = {
    readonly [chainId: number]: (Token | null)[];
};

export const WNATIVE_EXTENDED: { [chainId: number]: Token } = {
    ...WNATIVE,
};

const WNATIVE_ONLY: ChainTokenList = Object.fromEntries(
    Object.entries(WNATIVE_EXTENDED).map(([key, value]) => [key, [value]]),
);

export const BASES_TO_CHECK_TRADES_AGAINST: ChainTokenList = {
    ...WNATIVE_ONLY,
    [ChainId.CoreMainnet]: [
        ...WNATIVE_ONLY[ChainId.CoreMainnet],
        STABLECOINS.USDT,
        STABLECOINS.WBTC,
        STABLECOINS.coreBTC,
        null,
    ],
    [ChainId.CoreTestnet]: [...WNATIVE_ONLY[ChainId.CoreTestnet], STABLECOINS.USDT, STABLECOINS.G!],
};



================================================
File: src/constants/tokens.ts
================================================
import { Token } from "@glyph-exchange/integral-sdk";
import { DEFAULT_CHAIN_ID } from "./default-chain-id";
import { ADDRESSES } from "./addresses";

export const STABLECOINS = {
    USDT: new Token(DEFAULT_CHAIN_ID, ADDRESSES.USDT, 6, "USDT", "USDT"),

    G: ADDRESSES.G ? new Token(DEFAULT_CHAIN_ID, ADDRESSES.G, 18, "G", "Glyph Exchange") : null,

    WBTC: ADDRESSES.WBTC
        ? new Token(DEFAULT_CHAIN_ID, ADDRESSES.WBTC, 8, "WBTC", "Wrapped Bitcoin")
        : null,

    coreBTC: ADDRESSES.coreBTC
        ? new Token(DEFAULT_CHAIN_ID, ADDRESSES.coreBTC, 8, "coreBTC", "Core Wrapped BTC")
        : null,
};

export const INTEGRALCOINS = {
    GP: new Token(DEFAULT_CHAIN_ID, ADDRESSES.GP, 18, "GP", "G-Points"),
};



================================================
File: src/graphql/clients/index.ts
================================================
import { ApolloClient, InMemoryCache } from "@apollo/client";
import { Environment } from "@/types/common";

const GRAPH_ENV: GraphEnv = {
    [Environment.PROD]: {
        INFO_GRAPH: import.meta.env.VITE_INFO_GRAPH_PROD,
        BLOCKS_GRAPH: import.meta.env.VITE_BLOCKS_GRAPH_PROD,
        FARMING_GRAPH: import.meta.env.VITE_FARMING_GRAPH_PROD,
        LIMIT_ORDERS: import.meta.env.VITE_LIMIT_ORDERS_GRAPH_PROD,
    },
    [Environment.DEV]: {
        INFO_GRAPH: import.meta.env.VITE_INFO_GRAPH_DEV,
        BLOCKS_GRAPH: import.meta.env.VITE_BLOCKS_GRAPH_DEV,
        FARMING_GRAPH: import.meta.env.VITE_FARMING_GRAPH_DEV,
        LIMIT_ORDERS: import.meta.env.VITE_LIMIT_ORDERS_GRAPH_DEV,
    },
};

export const infoClient = new ApolloClient({
    uri: GRAPH_ENV[import.meta.env.VITE_ENVIRONMENT].INFO_GRAPH,
    cache: new InMemoryCache(),
});

export const blocksClient = new ApolloClient({
    uri: GRAPH_ENV[import.meta.env.VITE_ENVIRONMENT].BLOCKS_GRAPH,
    cache: new InMemoryCache(),
});

export const farmingClient = new ApolloClient({
    uri: GRAPH_ENV[import.meta.env.VITE_ENVIRONMENT].FARMING_GRAPH,
    cache: new InMemoryCache(),
});



================================================
File: src/graphql/generated/graphql.tsx
================================================
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigDecimal: { input: any; output: any; }
  BigInt: { input: any; output: any; }
  Bytes: { input: any; output: any; }
  /**
   * 8 bytes signed integer
   *
   */
  Int8: { input: any; output: any; }
};

export type AlgebraDayData = {
  __typename?: 'AlgebraDayData';
  date: Scalars['Int']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  tvlUSD: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  volumeMatic: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
  volumeUSDUntracked: Scalars['BigDecimal']['output'];
};

export type AlgebraDayData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<AlgebraDayData_Filter>>>;
  date?: InputMaybe<Scalars['Int']['input']>;
  date_gt?: InputMaybe<Scalars['Int']['input']>;
  date_gte?: InputMaybe<Scalars['Int']['input']>;
  date_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  date_lt?: InputMaybe<Scalars['Int']['input']>;
  date_lte?: InputMaybe<Scalars['Int']['input']>;
  date_not?: InputMaybe<Scalars['Int']['input']>;
  date_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  or?: InputMaybe<Array<InputMaybe<AlgebraDayData_Filter>>>;
  tvlUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tvlUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  volumeMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSDUntracked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSDUntracked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum AlgebraDayData_OrderBy {
  Date = 'date',
  FeesUsd = 'feesUSD',
  Id = 'id',
  TvlUsd = 'tvlUSD',
  TxCount = 'txCount',
  VolumeMatic = 'volumeMatic',
  VolumeUsd = 'volumeUSD',
  VolumeUsdUntracked = 'volumeUSDUntracked'
}

export type Block = {
  __typename?: 'Block';
  author?: Maybe<Scalars['String']['output']>;
  difficulty?: Maybe<Scalars['BigInt']['output']>;
  gasLimit?: Maybe<Scalars['BigInt']['output']>;
  gasUsed?: Maybe<Scalars['BigInt']['output']>;
  id: Scalars['ID']['output'];
  number: Scalars['BigInt']['output'];
  parentHash?: Maybe<Scalars['String']['output']>;
  receiptsRoot?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['BigInt']['output']>;
  stateRoot?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['BigInt']['output'];
  totalDifficulty?: Maybe<Scalars['BigInt']['output']>;
  transactionsRoot?: Maybe<Scalars['String']['output']>;
  unclesHash?: Maybe<Scalars['String']['output']>;
};

export type BlockChangedFilter = {
  number_gte: Scalars['Int']['input'];
};

export type Block_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Block_Filter>>>;
  author?: InputMaybe<Scalars['String']['input']>;
  author_contains?: InputMaybe<Scalars['String']['input']>;
  author_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  author_ends_with?: InputMaybe<Scalars['String']['input']>;
  author_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  author_gt?: InputMaybe<Scalars['String']['input']>;
  author_gte?: InputMaybe<Scalars['String']['input']>;
  author_in?: InputMaybe<Array<Scalars['String']['input']>>;
  author_lt?: InputMaybe<Scalars['String']['input']>;
  author_lte?: InputMaybe<Scalars['String']['input']>;
  author_not?: InputMaybe<Scalars['String']['input']>;
  author_not_contains?: InputMaybe<Scalars['String']['input']>;
  author_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  author_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  author_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  author_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  author_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  author_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  author_starts_with?: InputMaybe<Scalars['String']['input']>;
  author_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  difficulty?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_gt?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_gte?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  difficulty_lt?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_lte?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_not?: InputMaybe<Scalars['BigInt']['input']>;
  difficulty_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasLimit?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_gt?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_gte?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasLimit_lt?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_lte?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_not?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']['input']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  number?: InputMaybe<Scalars['BigInt']['input']>;
  number_gt?: InputMaybe<Scalars['BigInt']['input']>;
  number_gte?: InputMaybe<Scalars['BigInt']['input']>;
  number_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  number_lt?: InputMaybe<Scalars['BigInt']['input']>;
  number_lte?: InputMaybe<Scalars['BigInt']['input']>;
  number_not?: InputMaybe<Scalars['BigInt']['input']>;
  number_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Block_Filter>>>;
  parentHash?: InputMaybe<Scalars['String']['input']>;
  parentHash_contains?: InputMaybe<Scalars['String']['input']>;
  parentHash_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  parentHash_ends_with?: InputMaybe<Scalars['String']['input']>;
  parentHash_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  parentHash_gt?: InputMaybe<Scalars['String']['input']>;
  parentHash_gte?: InputMaybe<Scalars['String']['input']>;
  parentHash_in?: InputMaybe<Array<Scalars['String']['input']>>;
  parentHash_lt?: InputMaybe<Scalars['String']['input']>;
  parentHash_lte?: InputMaybe<Scalars['String']['input']>;
  parentHash_not?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_contains?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  parentHash_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  parentHash_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  parentHash_starts_with?: InputMaybe<Scalars['String']['input']>;
  parentHash_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_contains?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_ends_with?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_gt?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_gte?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_in?: InputMaybe<Array<Scalars['String']['input']>>;
  receiptsRoot_lt?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_lte?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_contains?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  receiptsRoot_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_starts_with?: InputMaybe<Scalars['String']['input']>;
  receiptsRoot_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['BigInt']['input']>;
  size_gt?: InputMaybe<Scalars['BigInt']['input']>;
  size_gte?: InputMaybe<Scalars['BigInt']['input']>;
  size_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  size_lt?: InputMaybe<Scalars['BigInt']['input']>;
  size_lte?: InputMaybe<Scalars['BigInt']['input']>;
  size_not?: InputMaybe<Scalars['BigInt']['input']>;
  size_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  stateRoot?: InputMaybe<Scalars['String']['input']>;
  stateRoot_contains?: InputMaybe<Scalars['String']['input']>;
  stateRoot_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  stateRoot_ends_with?: InputMaybe<Scalars['String']['input']>;
  stateRoot_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  stateRoot_gt?: InputMaybe<Scalars['String']['input']>;
  stateRoot_gte?: InputMaybe<Scalars['String']['input']>;
  stateRoot_in?: InputMaybe<Array<Scalars['String']['input']>>;
  stateRoot_lt?: InputMaybe<Scalars['String']['input']>;
  stateRoot_lte?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_contains?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  stateRoot_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  stateRoot_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  stateRoot_starts_with?: InputMaybe<Scalars['String']['input']>;
  stateRoot_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  totalDifficulty?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_gt?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_gte?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  totalDifficulty_lt?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_lte?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_not?: InputMaybe<Scalars['BigInt']['input']>;
  totalDifficulty_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  transactionsRoot?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_contains?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_ends_with?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_gt?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_gte?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transactionsRoot_lt?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_lte?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_contains?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transactionsRoot_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_starts_with?: InputMaybe<Scalars['String']['input']>;
  transactionsRoot_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash?: InputMaybe<Scalars['String']['input']>;
  unclesHash_contains?: InputMaybe<Scalars['String']['input']>;
  unclesHash_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash_ends_with?: InputMaybe<Scalars['String']['input']>;
  unclesHash_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash_gt?: InputMaybe<Scalars['String']['input']>;
  unclesHash_gte?: InputMaybe<Scalars['String']['input']>;
  unclesHash_in?: InputMaybe<Array<Scalars['String']['input']>>;
  unclesHash_lt?: InputMaybe<Scalars['String']['input']>;
  unclesHash_lte?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_contains?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  unclesHash_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  unclesHash_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  unclesHash_starts_with?: InputMaybe<Scalars['String']['input']>;
  unclesHash_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export type Block_Height = {
  hash?: InputMaybe<Scalars['Bytes']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  number_gte?: InputMaybe<Scalars['Int']['input']>;
};

export enum Block_OrderBy {
  Author = 'author',
  Difficulty = 'difficulty',
  GasLimit = 'gasLimit',
  GasUsed = 'gasUsed',
  Id = 'id',
  Number = 'number',
  ParentHash = 'parentHash',
  ReceiptsRoot = 'receiptsRoot',
  Size = 'size',
  StateRoot = 'stateRoot',
  Timestamp = 'timestamp',
  TotalDifficulty = 'totalDifficulty',
  TransactionsRoot = 'transactionsRoot',
  UnclesHash = 'unclesHash'
}

export type Bundle = {
  __typename?: 'Bundle';
  id: Scalars['ID']['output'];
  maticPriceUSD: Scalars['BigDecimal']['output'];
};

export type Bundle_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Bundle_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  maticPriceUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  maticPriceUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  maticPriceUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Bundle_Filter>>>;
};

export enum Bundle_OrderBy {
  Id = 'id',
  MaticPriceUsd = 'maticPriceUSD'
}

export type Burn = {
  __typename?: 'Burn';
  amount: Scalars['BigInt']['output'];
  amount0: Scalars['BigDecimal']['output'];
  amount1: Scalars['BigDecimal']['output'];
  amountUSD?: Maybe<Scalars['BigDecimal']['output']>;
  id: Scalars['ID']['output'];
  logIndex?: Maybe<Scalars['BigInt']['output']>;
  origin: Scalars['Bytes']['output'];
  owner?: Maybe<Scalars['Bytes']['output']>;
  pool: Pool;
  tickLower: Scalars['BigInt']['output'];
  tickUpper: Scalars['BigInt']['output'];
  timestamp: Scalars['BigInt']['output'];
  token0: Token;
  token1: Token;
  transaction: Transaction;
};

export type Burn_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount?: InputMaybe<Scalars['BigInt']['input']>;
  amount0?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Burn_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  logIndex?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Burn_Filter>>>;
  origin?: InputMaybe<Scalars['Bytes']['input']>;
  origin_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  origin_lt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_lte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickLower_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  token0?: InputMaybe<Scalars['String']['input']>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']['input']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_gt?: InputMaybe<Scalars['String']['input']>;
  token0_gte?: InputMaybe<Scalars['String']['input']>;
  token0_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_lt?: InputMaybe<Scalars['String']['input']>;
  token0_lte?: InputMaybe<Scalars['String']['input']>;
  token0_not?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1?: InputMaybe<Scalars['String']['input']>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']['input']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_gt?: InputMaybe<Scalars['String']['input']>;
  token1_gte?: InputMaybe<Scalars['String']['input']>;
  token1_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_lt?: InputMaybe<Scalars['String']['input']>;
  token1_lte?: InputMaybe<Scalars['String']['input']>;
  token1_not?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum Burn_OrderBy {
  Amount = 'amount',
  Amount0 = 'amount0',
  Amount1 = 'amount1',
  AmountUsd = 'amountUSD',
  Id = 'id',
  LogIndex = 'logIndex',
  Origin = 'origin',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  TickLower = 'tickLower',
  TickUpper = 'tickUpper',
  Timestamp = 'timestamp',
  Token0 = 'token0',
  Token0Decimals = 'token0__decimals',
  Token0DerivedMatic = 'token0__derivedMatic',
  Token0FeesUsd = 'token0__feesUSD',
  Token0Id = 'token0__id',
  Token0Name = 'token0__name',
  Token0PoolCount = 'token0__poolCount',
  Token0Symbol = 'token0__symbol',
  Token0TotalSupply = 'token0__totalSupply',
  Token0TotalValueLocked = 'token0__totalValueLocked',
  Token0TotalValueLockedUsd = 'token0__totalValueLockedUSD',
  Token0TotalValueLockedUsdUntracked = 'token0__totalValueLockedUSDUntracked',
  Token0TxCount = 'token0__txCount',
  Token0UntrackedVolumeUsd = 'token0__untrackedVolumeUSD',
  Token0Volume = 'token0__volume',
  Token0VolumeUsd = 'token0__volumeUSD',
  Token1 = 'token1',
  Token1Decimals = 'token1__decimals',
  Token1DerivedMatic = 'token1__derivedMatic',
  Token1FeesUsd = 'token1__feesUSD',
  Token1Id = 'token1__id',
  Token1Name = 'token1__name',
  Token1PoolCount = 'token1__poolCount',
  Token1Symbol = 'token1__symbol',
  Token1TotalSupply = 'token1__totalSupply',
  Token1TotalValueLocked = 'token1__totalValueLocked',
  Token1TotalValueLockedUsd = 'token1__totalValueLockedUSD',
  Token1TotalValueLockedUsdUntracked = 'token1__totalValueLockedUSDUntracked',
  Token1TxCount = 'token1__txCount',
  Token1UntrackedVolumeUsd = 'token1__untrackedVolumeUSD',
  Token1Volume = 'token1__volume',
  Token1VolumeUsd = 'token1__volumeUSD',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp'
}

export type Collect = {
  __typename?: 'Collect';
  amount0: Scalars['BigDecimal']['output'];
  amount1: Scalars['BigDecimal']['output'];
  amountUSD?: Maybe<Scalars['BigDecimal']['output']>;
  id: Scalars['ID']['output'];
  logIndex?: Maybe<Scalars['BigInt']['output']>;
  owner?: Maybe<Scalars['Bytes']['output']>;
  pool: Pool;
  tickLower: Scalars['BigInt']['output'];
  tickUpper: Scalars['BigInt']['output'];
  timestamp: Scalars['BigInt']['output'];
  transaction: Transaction;
};

export type Collect_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount0?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Collect_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  logIndex?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Collect_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickLower_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum Collect_OrderBy {
  Amount0 = 'amount0',
  Amount1 = 'amount1',
  AmountUsd = 'amountUSD',
  Id = 'id',
  LogIndex = 'logIndex',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  TickLower = 'tickLower',
  TickUpper = 'tickUpper',
  Timestamp = 'timestamp',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp'
}

export type Deposit = {
  __typename?: 'Deposit';
  eternalFarming?: Maybe<Scalars['Bytes']['output']>;
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  owner: Scalars['Bytes']['output'];
  pool: Scalars['Bytes']['output'];
  rangeLength: Scalars['BigInt']['output'];
};

export type Deposit_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Deposit_Filter>>>;
  eternalFarming?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_contains?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_gt?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_gte?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  eternalFarming_lt?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_lte?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_not?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  eternalFarming_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Deposit_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['Bytes']['input']>;
  pool_contains?: InputMaybe<Scalars['Bytes']['input']>;
  pool_gt?: InputMaybe<Scalars['Bytes']['input']>;
  pool_gte?: InputMaybe<Scalars['Bytes']['input']>;
  pool_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool_lt?: InputMaybe<Scalars['Bytes']['input']>;
  pool_lte?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  rangeLength?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_gt?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_gte?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  rangeLength_lt?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_lte?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_not?: InputMaybe<Scalars['BigInt']['input']>;
  rangeLength_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export enum Deposit_OrderBy {
  EternalFarming = 'eternalFarming',
  Id = 'id',
  Liquidity = 'liquidity',
  Owner = 'owner',
  Pool = 'pool',
  RangeLength = 'rangeLength'
}

export type EternalFarming = {
  __typename?: 'EternalFarming';
  bonusReward: Scalars['BigInt']['output'];
  bonusRewardRate: Scalars['BigInt']['output'];
  bonusRewardToken: Scalars['Bytes']['output'];
  id: Scalars['ID']['output'];
  isDeactivated?: Maybe<Scalars['Boolean']['output']>;
  minRangeLength: Scalars['BigInt']['output'];
  nonce: Scalars['BigInt']['output'];
  pool: Scalars['Bytes']['output'];
  reward: Scalars['BigInt']['output'];
  rewardRate: Scalars['BigInt']['output'];
  rewardToken: Scalars['Bytes']['output'];
  virtualPool: Scalars['Bytes']['output'];
};

export type EternalFarming_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<EternalFarming_Filter>>>;
  bonusReward?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_gt?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_gte?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  bonusRewardRate_lt?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_lte?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_not?: InputMaybe<Scalars['BigInt']['input']>;
  bonusRewardRate_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  bonusRewardToken?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_contains?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_gt?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_gte?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  bonusRewardToken_lt?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_lte?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_not?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  bonusRewardToken_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  bonusReward_gt?: InputMaybe<Scalars['BigInt']['input']>;
  bonusReward_gte?: InputMaybe<Scalars['BigInt']['input']>;
  bonusReward_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  bonusReward_lt?: InputMaybe<Scalars['BigInt']['input']>;
  bonusReward_lte?: InputMaybe<Scalars['BigInt']['input']>;
  bonusReward_not?: InputMaybe<Scalars['BigInt']['input']>;
  bonusReward_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  isDeactivated?: InputMaybe<Scalars['Boolean']['input']>;
  isDeactivated_in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  isDeactivated_not?: InputMaybe<Scalars['Boolean']['input']>;
  isDeactivated_not_in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  minRangeLength?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_gt?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_gte?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  minRangeLength_lt?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_lte?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_not?: InputMaybe<Scalars['BigInt']['input']>;
  minRangeLength_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  nonce?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_gt?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_gte?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  nonce_lt?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_lte?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_not?: InputMaybe<Scalars['BigInt']['input']>;
  nonce_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<EternalFarming_Filter>>>;
  pool?: InputMaybe<Scalars['Bytes']['input']>;
  pool_contains?: InputMaybe<Scalars['Bytes']['input']>;
  pool_gt?: InputMaybe<Scalars['Bytes']['input']>;
  pool_gte?: InputMaybe<Scalars['Bytes']['input']>;
  pool_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool_lt?: InputMaybe<Scalars['Bytes']['input']>;
  pool_lte?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  reward?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_gt?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_gte?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  rewardRate_lt?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_lte?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_not?: InputMaybe<Scalars['BigInt']['input']>;
  rewardRate_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  rewardToken?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_contains?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_gt?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_gte?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  rewardToken_lt?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_lte?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_not?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  rewardToken_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  reward_gt?: InputMaybe<Scalars['BigInt']['input']>;
  reward_gte?: InputMaybe<Scalars['BigInt']['input']>;
  reward_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  reward_lt?: InputMaybe<Scalars['BigInt']['input']>;
  reward_lte?: InputMaybe<Scalars['BigInt']['input']>;
  reward_not?: InputMaybe<Scalars['BigInt']['input']>;
  reward_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  virtualPool?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_contains?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_gt?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_gte?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  virtualPool_lt?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_lte?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_not?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  virtualPool_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};

export enum EternalFarming_OrderBy {
  BonusReward = 'bonusReward',
  BonusRewardRate = 'bonusRewardRate',
  BonusRewardToken = 'bonusRewardToken',
  Id = 'id',
  IsDeactivated = 'isDeactivated',
  MinRangeLength = 'minRangeLength',
  Nonce = 'nonce',
  Pool = 'pool',
  Reward = 'reward',
  RewardRate = 'rewardRate',
  RewardToken = 'rewardToken',
  VirtualPool = 'virtualPool'
}

export type Factory = {
  __typename?: 'Factory';
  defaultCommunityFee: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  owner: Scalars['ID']['output'];
  poolCount: Scalars['BigInt']['output'];
  totalFeesMatic: Scalars['BigDecimal']['output'];
  totalFeesUSD: Scalars['BigDecimal']['output'];
  totalValueLockedMatic: Scalars['BigDecimal']['output'];
  totalValueLockedMaticUntracked: Scalars['BigDecimal']['output'];
  totalValueLockedUSD: Scalars['BigDecimal']['output'];
  totalValueLockedUSDUntracked: Scalars['BigDecimal']['output'];
  totalVolumeMatic: Scalars['BigDecimal']['output'];
  totalVolumeUSD: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
};

export type Factory_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Factory_Filter>>>;
  defaultCommunityFee?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  defaultCommunityFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  defaultCommunityFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Factory_Filter>>>;
  owner?: InputMaybe<Scalars['ID']['input']>;
  owner_gt?: InputMaybe<Scalars['ID']['input']>;
  owner_gte?: InputMaybe<Scalars['ID']['input']>;
  owner_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  owner_lt?: InputMaybe<Scalars['ID']['input']>;
  owner_lte?: InputMaybe<Scalars['ID']['input']>;
  owner_not?: InputMaybe<Scalars['ID']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  poolCount?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  poolCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  totalFeesMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalFeesMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalFeesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalFeesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalFeesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedMaticUntracked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMaticUntracked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSDUntracked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalVolumeMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalVolumeMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum Factory_OrderBy {
  DefaultCommunityFee = 'defaultCommunityFee',
  Id = 'id',
  Owner = 'owner',
  PoolCount = 'poolCount',
  TotalFeesMatic = 'totalFeesMatic',
  TotalFeesUsd = 'totalFeesUSD',
  TotalValueLockedMatic = 'totalValueLockedMatic',
  TotalValueLockedMaticUntracked = 'totalValueLockedMaticUntracked',
  TotalValueLockedUsd = 'totalValueLockedUSD',
  TotalValueLockedUsdUntracked = 'totalValueLockedUSDUntracked',
  TotalVolumeMatic = 'totalVolumeMatic',
  TotalVolumeUsd = 'totalVolumeUSD',
  TxCount = 'txCount',
  UntrackedVolumeUsd = 'untrackedVolumeUSD'
}

export type FeeHourData = {
  __typename?: 'FeeHourData';
  changesCount: Scalars['BigInt']['output'];
  endFee: Scalars['BigInt']['output'];
  fee: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  maxFee: Scalars['BigInt']['output'];
  minFee: Scalars['BigInt']['output'];
  pool: Scalars['String']['output'];
  startFee: Scalars['BigInt']['output'];
  timestamp: Scalars['BigInt']['output'];
};

export type FeeHourData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<FeeHourData_Filter>>>;
  changesCount?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  changesCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  changesCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  endFee?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  endFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  endFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee?: InputMaybe<Scalars['BigInt']['input']>;
  fee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  maxFee?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  maxFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  maxFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  minFee?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  minFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  minFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<FeeHourData_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  startFee?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  startFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  startFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export enum FeeHourData_OrderBy {
  ChangesCount = 'changesCount',
  EndFee = 'endFee',
  Fee = 'fee',
  Id = 'id',
  MaxFee = 'maxFee',
  MinFee = 'minFee',
  Pool = 'pool',
  StartFee = 'startFee',
  Timestamp = 'timestamp'
}

export type Flash = {
  __typename?: 'Flash';
  amount0: Scalars['BigDecimal']['output'];
  amount0Paid: Scalars['BigDecimal']['output'];
  amount1: Scalars['BigDecimal']['output'];
  amount1Paid: Scalars['BigDecimal']['output'];
  amountUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  logIndex?: Maybe<Scalars['BigInt']['output']>;
  pool: Pool;
  recipient: Scalars['Bytes']['output'];
  sender: Scalars['Bytes']['output'];
  timestamp: Scalars['BigInt']['output'];
  transaction: Transaction;
};

export type Flash_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount0?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0Paid_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0Paid_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1Paid_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1Paid_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Flash_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  logIndex?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Flash_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  recipient?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_contains?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_gt?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_gte?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  recipient_lt?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_lte?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  sender?: InputMaybe<Scalars['Bytes']['input']>;
  sender_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_lte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum Flash_OrderBy {
  Amount0 = 'amount0',
  Amount0Paid = 'amount0Paid',
  Amount1 = 'amount1',
  Amount1Paid = 'amount1Paid',
  AmountUsd = 'amountUSD',
  Id = 'id',
  LogIndex = 'logIndex',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Recipient = 'recipient',
  Sender = 'sender',
  Timestamp = 'timestamp',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp'
}

export type Mint = {
  __typename?: 'Mint';
  amount: Scalars['BigInt']['output'];
  amount0: Scalars['BigDecimal']['output'];
  amount1: Scalars['BigDecimal']['output'];
  amountUSD?: Maybe<Scalars['BigDecimal']['output']>;
  id: Scalars['ID']['output'];
  logIndex?: Maybe<Scalars['BigInt']['output']>;
  origin: Scalars['Bytes']['output'];
  owner: Scalars['Bytes']['output'];
  pool: Pool;
  sender?: Maybe<Scalars['Bytes']['output']>;
  tickLower: Scalars['BigInt']['output'];
  tickUpper: Scalars['BigInt']['output'];
  timestamp: Scalars['BigInt']['output'];
  token0: Token;
  token1: Token;
  transaction: Transaction;
};

export type Mint_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount?: InputMaybe<Scalars['BigInt']['input']>;
  amount0?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Mint_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  logIndex?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Mint_Filter>>>;
  origin?: InputMaybe<Scalars['Bytes']['input']>;
  origin_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  origin_lt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_lte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  sender?: InputMaybe<Scalars['Bytes']['input']>;
  sender_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_lte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  tickLower?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickLower_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickLower_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickUpper_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickUpper_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  token0?: InputMaybe<Scalars['String']['input']>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']['input']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_gt?: InputMaybe<Scalars['String']['input']>;
  token0_gte?: InputMaybe<Scalars['String']['input']>;
  token0_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_lt?: InputMaybe<Scalars['String']['input']>;
  token0_lte?: InputMaybe<Scalars['String']['input']>;
  token0_not?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1?: InputMaybe<Scalars['String']['input']>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']['input']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_gt?: InputMaybe<Scalars['String']['input']>;
  token1_gte?: InputMaybe<Scalars['String']['input']>;
  token1_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_lt?: InputMaybe<Scalars['String']['input']>;
  token1_lte?: InputMaybe<Scalars['String']['input']>;
  token1_not?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum Mint_OrderBy {
  Amount = 'amount',
  Amount0 = 'amount0',
  Amount1 = 'amount1',
  AmountUsd = 'amountUSD',
  Id = 'id',
  LogIndex = 'logIndex',
  Origin = 'origin',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Sender = 'sender',
  TickLower = 'tickLower',
  TickUpper = 'tickUpper',
  Timestamp = 'timestamp',
  Token0 = 'token0',
  Token0Decimals = 'token0__decimals',
  Token0DerivedMatic = 'token0__derivedMatic',
  Token0FeesUsd = 'token0__feesUSD',
  Token0Id = 'token0__id',
  Token0Name = 'token0__name',
  Token0PoolCount = 'token0__poolCount',
  Token0Symbol = 'token0__symbol',
  Token0TotalSupply = 'token0__totalSupply',
  Token0TotalValueLocked = 'token0__totalValueLocked',
  Token0TotalValueLockedUsd = 'token0__totalValueLockedUSD',
  Token0TotalValueLockedUsdUntracked = 'token0__totalValueLockedUSDUntracked',
  Token0TxCount = 'token0__txCount',
  Token0UntrackedVolumeUsd = 'token0__untrackedVolumeUSD',
  Token0Volume = 'token0__volume',
  Token0VolumeUsd = 'token0__volumeUSD',
  Token1 = 'token1',
  Token1Decimals = 'token1__decimals',
  Token1DerivedMatic = 'token1__derivedMatic',
  Token1FeesUsd = 'token1__feesUSD',
  Token1Id = 'token1__id',
  Token1Name = 'token1__name',
  Token1PoolCount = 'token1__poolCount',
  Token1Symbol = 'token1__symbol',
  Token1TotalSupply = 'token1__totalSupply',
  Token1TotalValueLocked = 'token1__totalValueLocked',
  Token1TotalValueLockedUsd = 'token1__totalValueLockedUSD',
  Token1TotalValueLockedUsdUntracked = 'token1__totalValueLockedUSDUntracked',
  Token1TxCount = 'token1__txCount',
  Token1UntrackedVolumeUsd = 'token1__untrackedVolumeUSD',
  Token1Volume = 'token1__volume',
  Token1VolumeUsd = 'token1__volumeUSD',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp'
}

/** Defines the order direction, either ascending or descending */
export enum OrderDirection {
  Asc = 'asc',
  Desc = 'desc'
}

export type Pool = {
  __typename?: 'Pool';
  burns: Array<Burn>;
  collectedFeesToken0: Scalars['BigDecimal']['output'];
  collectedFeesToken1: Scalars['BigDecimal']['output'];
  collectedFeesUSD: Scalars['BigDecimal']['output'];
  collects: Array<Collect>;
  communityFee: Scalars['BigInt']['output'];
  createdAtBlockNumber: Scalars['BigInt']['output'];
  createdAtTimestamp: Scalars['BigInt']['output'];
  fee: Scalars['BigInt']['output'];
  feeGrowthGlobal0X128: Scalars['BigInt']['output'];
  feeGrowthGlobal1X128: Scalars['BigInt']['output'];
  feesToken0: Scalars['BigDecimal']['output'];
  feesToken1: Scalars['BigDecimal']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  liquidityProviderCount: Scalars['BigInt']['output'];
  mints: Array<Mint>;
  observationIndex: Scalars['BigInt']['output'];
  poolDayData: Array<PoolDayData>;
  poolHourData: Array<PoolHourData>;
  sqrtPrice: Scalars['BigInt']['output'];
  swaps: Array<Swap>;
  tick: Scalars['BigInt']['output'];
  tickSpacing: Scalars['BigInt']['output'];
  ticks: Array<Tick>;
  token0: Token;
  token0Price: Scalars['BigDecimal']['output'];
  token1: Token;
  token1Price: Scalars['BigDecimal']['output'];
  totalValueLockedMatic: Scalars['BigDecimal']['output'];
  totalValueLockedToken0: Scalars['BigDecimal']['output'];
  totalValueLockedToken1: Scalars['BigDecimal']['output'];
  totalValueLockedUSD: Scalars['BigDecimal']['output'];
  totalValueLockedUSDUntracked: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  untrackedFeesUSD: Scalars['BigDecimal']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};


export type PoolBurnsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Burn_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Burn_Filter>;
};


export type PoolCollectsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Collect_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Collect_Filter>;
};


export type PoolMintsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Mint_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Mint_Filter>;
};


export type PoolPoolDayDataArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PoolDayData_Filter>;
};


export type PoolPoolHourDataArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PoolHourData_Filter>;
};


export type PoolSwapsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Swap_Filter>;
};


export type PoolTicksArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Tick_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Tick_Filter>;
};

export type PoolDayData = {
  __typename?: 'PoolDayData';
  close: Scalars['BigDecimal']['output'];
  date: Scalars['Int']['output'];
  feeGrowthGlobal0X128: Scalars['BigInt']['output'];
  feeGrowthGlobal1X128: Scalars['BigInt']['output'];
  feesToken0: Scalars['BigDecimal']['output'];
  feesToken1: Scalars['BigDecimal']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  high: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  low: Scalars['BigDecimal']['output'];
  open: Scalars['BigDecimal']['output'];
  pool: Pool;
  sqrtPrice: Scalars['BigInt']['output'];
  tick?: Maybe<Scalars['BigInt']['output']>;
  token0Price: Scalars['BigDecimal']['output'];
  token1Price: Scalars['BigDecimal']['output'];
  tvlUSD: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type PoolDayData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolDayData_Filter>>>;
  close?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  close_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  date?: InputMaybe<Scalars['Int']['input']>;
  date_gt?: InputMaybe<Scalars['Int']['input']>;
  date_gte?: InputMaybe<Scalars['Int']['input']>;
  date_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  date_lt?: InputMaybe<Scalars['Int']['input']>;
  date_lte?: InputMaybe<Scalars['Int']['input']>;
  date_not?: InputMaybe<Scalars['Int']['input']>;
  date_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  feeGrowthGlobal0X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal0X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  low?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  low_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  or?: InputMaybe<Array<InputMaybe<PoolDayData_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  sqrtPrice?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  sqrtPrice_lt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_lte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  token0Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tvlUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tvlUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum PoolDayData_OrderBy {
  Close = 'close',
  Date = 'date',
  FeeGrowthGlobal0X128 = 'feeGrowthGlobal0X128',
  FeeGrowthGlobal1X128 = 'feeGrowthGlobal1X128',
  FeesToken0 = 'feesToken0',
  FeesToken1 = 'feesToken1',
  FeesUsd = 'feesUSD',
  High = 'high',
  Id = 'id',
  Liquidity = 'liquidity',
  Low = 'low',
  Open = 'open',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  SqrtPrice = 'sqrtPrice',
  Tick = 'tick',
  Token0Price = 'token0Price',
  Token1Price = 'token1Price',
  TvlUsd = 'tvlUSD',
  TxCount = 'txCount',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type PoolFeeData = {
  __typename?: 'PoolFeeData';
  fee: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  pool?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['BigInt']['output'];
};

export type PoolFeeData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolFeeData_Filter>>>;
  fee?: InputMaybe<Scalars['BigInt']['input']>;
  fee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  or?: InputMaybe<Array<InputMaybe<PoolFeeData_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export enum PoolFeeData_OrderBy {
  Fee = 'fee',
  Id = 'id',
  Pool = 'pool',
  Timestamp = 'timestamp'
}

export type PoolHourData = {
  __typename?: 'PoolHourData';
  close: Scalars['BigDecimal']['output'];
  feeGrowthGlobal0X128: Scalars['BigInt']['output'];
  feeGrowthGlobal1X128: Scalars['BigInt']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  high: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  low: Scalars['BigDecimal']['output'];
  open: Scalars['BigDecimal']['output'];
  periodStartUnix: Scalars['Int']['output'];
  pool: Pool;
  sqrtPrice: Scalars['BigInt']['output'];
  tick?: Maybe<Scalars['BigInt']['output']>;
  token0Price: Scalars['BigDecimal']['output'];
  token1Price: Scalars['BigDecimal']['output'];
  tvlUSD: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type PoolHourData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolHourData_Filter>>>;
  close?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  close_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feeGrowthGlobal0X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal0X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  low?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  low_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  or?: InputMaybe<Array<InputMaybe<PoolHourData_Filter>>>;
  periodStartUnix?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  periodStartUnix_lt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_lte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  sqrtPrice?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  sqrtPrice_lt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_lte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  token0Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tvlUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tvlUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  tvlUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum PoolHourData_OrderBy {
  Close = 'close',
  FeeGrowthGlobal0X128 = 'feeGrowthGlobal0X128',
  FeeGrowthGlobal1X128 = 'feeGrowthGlobal1X128',
  FeesUsd = 'feesUSD',
  High = 'high',
  Id = 'id',
  Liquidity = 'liquidity',
  Low = 'low',
  Open = 'open',
  PeriodStartUnix = 'periodStartUnix',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  SqrtPrice = 'sqrtPrice',
  Tick = 'tick',
  Token0Price = 'token0Price',
  Token1Price = 'token1Price',
  TvlUsd = 'tvlUSD',
  TxCount = 'txCount',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type PoolPosition = {
  __typename?: 'PoolPosition';
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  lowerTick: Tick;
  owner: Scalars['Bytes']['output'];
  pool: Pool;
  upperTick: Tick;
};

export type PoolPosition_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PoolPosition_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  lowerTick?: InputMaybe<Scalars['String']['input']>;
  lowerTick_?: InputMaybe<Tick_Filter>;
  lowerTick_contains?: InputMaybe<Scalars['String']['input']>;
  lowerTick_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  lowerTick_ends_with?: InputMaybe<Scalars['String']['input']>;
  lowerTick_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  lowerTick_gt?: InputMaybe<Scalars['String']['input']>;
  lowerTick_gte?: InputMaybe<Scalars['String']['input']>;
  lowerTick_in?: InputMaybe<Array<Scalars['String']['input']>>;
  lowerTick_lt?: InputMaybe<Scalars['String']['input']>;
  lowerTick_lte?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_contains?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  lowerTick_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  lowerTick_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  lowerTick_starts_with?: InputMaybe<Scalars['String']['input']>;
  lowerTick_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  or?: InputMaybe<Array<InputMaybe<PoolPosition_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick?: InputMaybe<Scalars['String']['input']>;
  upperTick_?: InputMaybe<Tick_Filter>;
  upperTick_contains?: InputMaybe<Scalars['String']['input']>;
  upperTick_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick_ends_with?: InputMaybe<Scalars['String']['input']>;
  upperTick_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick_gt?: InputMaybe<Scalars['String']['input']>;
  upperTick_gte?: InputMaybe<Scalars['String']['input']>;
  upperTick_in?: InputMaybe<Array<Scalars['String']['input']>>;
  upperTick_lt?: InputMaybe<Scalars['String']['input']>;
  upperTick_lte?: InputMaybe<Scalars['String']['input']>;
  upperTick_not?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_contains?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  upperTick_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  upperTick_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  upperTick_starts_with?: InputMaybe<Scalars['String']['input']>;
  upperTick_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum PoolPosition_OrderBy {
  Id = 'id',
  Liquidity = 'liquidity',
  LowerTick = 'lowerTick',
  LowerTickCollectedFeesToken0 = 'lowerTick__collectedFeesToken0',
  LowerTickCollectedFeesToken1 = 'lowerTick__collectedFeesToken1',
  LowerTickCollectedFeesUsd = 'lowerTick__collectedFeesUSD',
  LowerTickCreatedAtBlockNumber = 'lowerTick__createdAtBlockNumber',
  LowerTickCreatedAtTimestamp = 'lowerTick__createdAtTimestamp',
  LowerTickFeeGrowthOutside0X128 = 'lowerTick__feeGrowthOutside0X128',
  LowerTickFeeGrowthOutside1X128 = 'lowerTick__feeGrowthOutside1X128',
  LowerTickFeesUsd = 'lowerTick__feesUSD',
  LowerTickId = 'lowerTick__id',
  LowerTickLiquidityGross = 'lowerTick__liquidityGross',
  LowerTickLiquidityNet = 'lowerTick__liquidityNet',
  LowerTickLiquidityProviderCount = 'lowerTick__liquidityProviderCount',
  LowerTickPoolAddress = 'lowerTick__poolAddress',
  LowerTickPrice0 = 'lowerTick__price0',
  LowerTickPrice1 = 'lowerTick__price1',
  LowerTickTickIdx = 'lowerTick__tickIdx',
  LowerTickUntrackedVolumeUsd = 'lowerTick__untrackedVolumeUSD',
  LowerTickVolumeToken0 = 'lowerTick__volumeToken0',
  LowerTickVolumeToken1 = 'lowerTick__volumeToken1',
  LowerTickVolumeUsd = 'lowerTick__volumeUSD',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  UpperTick = 'upperTick',
  UpperTickCollectedFeesToken0 = 'upperTick__collectedFeesToken0',
  UpperTickCollectedFeesToken1 = 'upperTick__collectedFeesToken1',
  UpperTickCollectedFeesUsd = 'upperTick__collectedFeesUSD',
  UpperTickCreatedAtBlockNumber = 'upperTick__createdAtBlockNumber',
  UpperTickCreatedAtTimestamp = 'upperTick__createdAtTimestamp',
  UpperTickFeeGrowthOutside0X128 = 'upperTick__feeGrowthOutside0X128',
  UpperTickFeeGrowthOutside1X128 = 'upperTick__feeGrowthOutside1X128',
  UpperTickFeesUsd = 'upperTick__feesUSD',
  UpperTickId = 'upperTick__id',
  UpperTickLiquidityGross = 'upperTick__liquidityGross',
  UpperTickLiquidityNet = 'upperTick__liquidityNet',
  UpperTickLiquidityProviderCount = 'upperTick__liquidityProviderCount',
  UpperTickPoolAddress = 'upperTick__poolAddress',
  UpperTickPrice0 = 'upperTick__price0',
  UpperTickPrice1 = 'upperTick__price1',
  UpperTickTickIdx = 'upperTick__tickIdx',
  UpperTickUntrackedVolumeUsd = 'upperTick__untrackedVolumeUSD',
  UpperTickVolumeToken0 = 'upperTick__volumeToken0',
  UpperTickVolumeToken1 = 'upperTick__volumeToken1',
  UpperTickVolumeUsd = 'upperTick__volumeUSD'
}

export type Pool_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Pool_Filter>>>;
  burns_?: InputMaybe<Burn_Filter>;
  collectedFeesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collects_?: InputMaybe<Collect_Filter>;
  communityFee?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  communityFee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_not?: InputMaybe<Scalars['BigInt']['input']>;
  communityFee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal0X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal0X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthGlobal1X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthGlobal1X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee_gt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_gte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']['input']>;
  fee_lte?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not?: InputMaybe<Scalars['BigInt']['input']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityProviderCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  mints_?: InputMaybe<Mint_Filter>;
  observationIndex?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  observationIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  observationIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Pool_Filter>>>;
  poolDayData_?: InputMaybe<PoolDayData_Filter>;
  poolHourData_?: InputMaybe<PoolHourData_Filter>;
  sqrtPrice?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_gte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  sqrtPrice_lt?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_lte?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not?: InputMaybe<Scalars['BigInt']['input']>;
  sqrtPrice_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  swaps_?: InputMaybe<Swap_Filter>;
  tick?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickSpacing_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickSpacing_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  ticks_?: InputMaybe<Tick_Filter>;
  token0?: InputMaybe<Scalars['String']['input']>;
  token0Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']['input']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_gt?: InputMaybe<Scalars['String']['input']>;
  token0_gte?: InputMaybe<Scalars['String']['input']>;
  token0_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_lt?: InputMaybe<Scalars['String']['input']>;
  token0_lte?: InputMaybe<Scalars['String']['input']>;
  token0_not?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1?: InputMaybe<Scalars['String']['input']>;
  token1Price?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Price_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Price_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']['input']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_gt?: InputMaybe<Scalars['String']['input']>;
  token1_gte?: InputMaybe<Scalars['String']['input']>;
  token1_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_lt?: InputMaybe<Scalars['String']['input']>;
  token1_lte?: InputMaybe<Scalars['String']['input']>;
  token1_not?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  totalValueLockedMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSDUntracked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedFeesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedFeesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedFeesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum Pool_OrderBy {
  Burns = 'burns',
  CollectedFeesToken0 = 'collectedFeesToken0',
  CollectedFeesToken1 = 'collectedFeesToken1',
  CollectedFeesUsd = 'collectedFeesUSD',
  Collects = 'collects',
  CommunityFee = 'communityFee',
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Fee = 'fee',
  FeeGrowthGlobal0X128 = 'feeGrowthGlobal0X128',
  FeeGrowthGlobal1X128 = 'feeGrowthGlobal1X128',
  FeesToken0 = 'feesToken0',
  FeesToken1 = 'feesToken1',
  FeesUsd = 'feesUSD',
  Id = 'id',
  Liquidity = 'liquidity',
  LiquidityProviderCount = 'liquidityProviderCount',
  Mints = 'mints',
  ObservationIndex = 'observationIndex',
  PoolDayData = 'poolDayData',
  PoolHourData = 'poolHourData',
  SqrtPrice = 'sqrtPrice',
  Swaps = 'swaps',
  Tick = 'tick',
  TickSpacing = 'tickSpacing',
  Ticks = 'ticks',
  Token0 = 'token0',
  Token0Price = 'token0Price',
  Token0Decimals = 'token0__decimals',
  Token0DerivedMatic = 'token0__derivedMatic',
  Token0FeesUsd = 'token0__feesUSD',
  Token0Id = 'token0__id',
  Token0Name = 'token0__name',
  Token0PoolCount = 'token0__poolCount',
  Token0Symbol = 'token0__symbol',
  Token0TotalSupply = 'token0__totalSupply',
  Token0TotalValueLocked = 'token0__totalValueLocked',
  Token0TotalValueLockedUsd = 'token0__totalValueLockedUSD',
  Token0TotalValueLockedUsdUntracked = 'token0__totalValueLockedUSDUntracked',
  Token0TxCount = 'token0__txCount',
  Token0UntrackedVolumeUsd = 'token0__untrackedVolumeUSD',
  Token0Volume = 'token0__volume',
  Token0VolumeUsd = 'token0__volumeUSD',
  Token1 = 'token1',
  Token1Price = 'token1Price',
  Token1Decimals = 'token1__decimals',
  Token1DerivedMatic = 'token1__derivedMatic',
  Token1FeesUsd = 'token1__feesUSD',
  Token1Id = 'token1__id',
  Token1Name = 'token1__name',
  Token1PoolCount = 'token1__poolCount',
  Token1Symbol = 'token1__symbol',
  Token1TotalSupply = 'token1__totalSupply',
  Token1TotalValueLocked = 'token1__totalValueLocked',
  Token1TotalValueLockedUsd = 'token1__totalValueLockedUSD',
  Token1TotalValueLockedUsdUntracked = 'token1__totalValueLockedUSDUntracked',
  Token1TxCount = 'token1__txCount',
  Token1UntrackedVolumeUsd = 'token1__untrackedVolumeUSD',
  Token1Volume = 'token1__volume',
  Token1VolumeUsd = 'token1__volumeUSD',
  TotalValueLockedMatic = 'totalValueLockedMatic',
  TotalValueLockedToken0 = 'totalValueLockedToken0',
  TotalValueLockedToken1 = 'totalValueLockedToken1',
  TotalValueLockedUsd = 'totalValueLockedUSD',
  TotalValueLockedUsdUntracked = 'totalValueLockedUSDUntracked',
  TxCount = 'txCount',
  UntrackedFeesUsd = 'untrackedFeesUSD',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type Position = {
  __typename?: 'Position';
  collectedFeesToken0: Scalars['BigDecimal']['output'];
  collectedFeesToken1: Scalars['BigDecimal']['output'];
  collectedToken0: Scalars['BigDecimal']['output'];
  collectedToken1: Scalars['BigDecimal']['output'];
  depositedToken0: Scalars['BigDecimal']['output'];
  depositedToken1: Scalars['BigDecimal']['output'];
  feeGrowthInside0LastX128: Scalars['BigInt']['output'];
  feeGrowthInside1LastX128: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  owner: Scalars['Bytes']['output'];
  pool: Pool;
  tickLower: Tick;
  tickUpper: Tick;
  token0: Token;
  token0Tvl?: Maybe<Scalars['BigDecimal']['output']>;
  token1: Token;
  token1Tvl?: Maybe<Scalars['BigDecimal']['output']>;
  transaction: Transaction;
  withdrawnToken0: Scalars['BigDecimal']['output'];
  withdrawnToken1: Scalars['BigDecimal']['output'];
};

export type PositionSnapshot = {
  __typename?: 'PositionSnapshot';
  blockNumber: Scalars['BigInt']['output'];
  collectedFeesToken0: Scalars['BigDecimal']['output'];
  collectedFeesToken1: Scalars['BigDecimal']['output'];
  depositedToken0: Scalars['BigDecimal']['output'];
  depositedToken1: Scalars['BigDecimal']['output'];
  feeGrowthInside0LastX128: Scalars['BigInt']['output'];
  feeGrowthInside1LastX128: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  owner: Scalars['Bytes']['output'];
  pool: Pool;
  position: Position;
  timestamp: Scalars['BigInt']['output'];
  transaction: Transaction;
  withdrawnToken0: Scalars['BigDecimal']['output'];
  withdrawnToken1: Scalars['BigDecimal']['output'];
};

export type PositionSnapshot_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PositionSnapshot_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  collectedFeesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feeGrowthInside0LastX128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside0LastX128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside1LastX128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside1LastX128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<PositionSnapshot_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  position_?: InputMaybe<Position_Filter>;
  position_contains?: InputMaybe<Scalars['String']['input']>;
  position_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  position_ends_with?: InputMaybe<Scalars['String']['input']>;
  position_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  position_gt?: InputMaybe<Scalars['String']['input']>;
  position_gte?: InputMaybe<Scalars['String']['input']>;
  position_in?: InputMaybe<Array<Scalars['String']['input']>>;
  position_lt?: InputMaybe<Scalars['String']['input']>;
  position_lte?: InputMaybe<Scalars['String']['input']>;
  position_not?: InputMaybe<Scalars['String']['input']>;
  position_not_contains?: InputMaybe<Scalars['String']['input']>;
  position_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  position_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  position_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  position_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  position_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  position_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  position_starts_with?: InputMaybe<Scalars['String']['input']>;
  position_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  withdrawnToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum PositionSnapshot_OrderBy {
  BlockNumber = 'blockNumber',
  CollectedFeesToken0 = 'collectedFeesToken0',
  CollectedFeesToken1 = 'collectedFeesToken1',
  DepositedToken0 = 'depositedToken0',
  DepositedToken1 = 'depositedToken1',
  FeeGrowthInside0LastX128 = 'feeGrowthInside0LastX128',
  FeeGrowthInside1LastX128 = 'feeGrowthInside1LastX128',
  Id = 'id',
  Liquidity = 'liquidity',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Position = 'position',
  PositionCollectedFeesToken0 = 'position__collectedFeesToken0',
  PositionCollectedFeesToken1 = 'position__collectedFeesToken1',
  PositionCollectedToken0 = 'position__collectedToken0',
  PositionCollectedToken1 = 'position__collectedToken1',
  PositionDepositedToken0 = 'position__depositedToken0',
  PositionDepositedToken1 = 'position__depositedToken1',
  PositionFeeGrowthInside0LastX128 = 'position__feeGrowthInside0LastX128',
  PositionFeeGrowthInside1LastX128 = 'position__feeGrowthInside1LastX128',
  PositionId = 'position__id',
  PositionLiquidity = 'position__liquidity',
  PositionOwner = 'position__owner',
  PositionToken0Tvl = 'position__token0Tvl',
  PositionToken1Tvl = 'position__token1Tvl',
  PositionWithdrawnToken0 = 'position__withdrawnToken0',
  PositionWithdrawnToken1 = 'position__withdrawnToken1',
  Timestamp = 'timestamp',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp',
  WithdrawnToken0 = 'withdrawnToken0',
  WithdrawnToken1 = 'withdrawnToken1'
}

export type Position_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Position_Filter>>>;
  collectedFeesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  depositedToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  depositedToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feeGrowthInside0LastX128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside0LastX128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside0LastX128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside1LastX128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthInside1LastX128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthInside1LastX128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Position_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower?: InputMaybe<Scalars['String']['input']>;
  tickLower_?: InputMaybe<Tick_Filter>;
  tickLower_contains?: InputMaybe<Scalars['String']['input']>;
  tickLower_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower_ends_with?: InputMaybe<Scalars['String']['input']>;
  tickLower_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower_gt?: InputMaybe<Scalars['String']['input']>;
  tickLower_gte?: InputMaybe<Scalars['String']['input']>;
  tickLower_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tickLower_lt?: InputMaybe<Scalars['String']['input']>;
  tickLower_lte?: InputMaybe<Scalars['String']['input']>;
  tickLower_not?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_contains?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tickLower_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  tickLower_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickLower_starts_with?: InputMaybe<Scalars['String']['input']>;
  tickLower_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper?: InputMaybe<Scalars['String']['input']>;
  tickUpper_?: InputMaybe<Tick_Filter>;
  tickUpper_contains?: InputMaybe<Scalars['String']['input']>;
  tickUpper_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper_ends_with?: InputMaybe<Scalars['String']['input']>;
  tickUpper_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper_gt?: InputMaybe<Scalars['String']['input']>;
  tickUpper_gte?: InputMaybe<Scalars['String']['input']>;
  tickUpper_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tickUpper_lt?: InputMaybe<Scalars['String']['input']>;
  tickUpper_lte?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_contains?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tickUpper_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  tickUpper_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tickUpper_starts_with?: InputMaybe<Scalars['String']['input']>;
  tickUpper_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0?: InputMaybe<Scalars['String']['input']>;
  token0Tvl?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0Tvl_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token0Tvl_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']['input']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_gt?: InputMaybe<Scalars['String']['input']>;
  token0_gte?: InputMaybe<Scalars['String']['input']>;
  token0_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_lt?: InputMaybe<Scalars['String']['input']>;
  token0_lte?: InputMaybe<Scalars['String']['input']>;
  token0_not?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1?: InputMaybe<Scalars['String']['input']>;
  token1Tvl?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1Tvl_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  token1Tvl_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']['input']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_gt?: InputMaybe<Scalars['String']['input']>;
  token1_gte?: InputMaybe<Scalars['String']['input']>;
  token1_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_lt?: InputMaybe<Scalars['String']['input']>;
  token1_lte?: InputMaybe<Scalars['String']['input']>;
  token1_not?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  withdrawnToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  withdrawnToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  withdrawnToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum Position_OrderBy {
  CollectedFeesToken0 = 'collectedFeesToken0',
  CollectedFeesToken1 = 'collectedFeesToken1',
  CollectedToken0 = 'collectedToken0',
  CollectedToken1 = 'collectedToken1',
  DepositedToken0 = 'depositedToken0',
  DepositedToken1 = 'depositedToken1',
  FeeGrowthInside0LastX128 = 'feeGrowthInside0LastX128',
  FeeGrowthInside1LastX128 = 'feeGrowthInside1LastX128',
  Id = 'id',
  Liquidity = 'liquidity',
  Owner = 'owner',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  TickLower = 'tickLower',
  TickLowerCollectedFeesToken0 = 'tickLower__collectedFeesToken0',
  TickLowerCollectedFeesToken1 = 'tickLower__collectedFeesToken1',
  TickLowerCollectedFeesUsd = 'tickLower__collectedFeesUSD',
  TickLowerCreatedAtBlockNumber = 'tickLower__createdAtBlockNumber',
  TickLowerCreatedAtTimestamp = 'tickLower__createdAtTimestamp',
  TickLowerFeeGrowthOutside0X128 = 'tickLower__feeGrowthOutside0X128',
  TickLowerFeeGrowthOutside1X128 = 'tickLower__feeGrowthOutside1X128',
  TickLowerFeesUsd = 'tickLower__feesUSD',
  TickLowerId = 'tickLower__id',
  TickLowerLiquidityGross = 'tickLower__liquidityGross',
  TickLowerLiquidityNet = 'tickLower__liquidityNet',
  TickLowerLiquidityProviderCount = 'tickLower__liquidityProviderCount',
  TickLowerPoolAddress = 'tickLower__poolAddress',
  TickLowerPrice0 = 'tickLower__price0',
  TickLowerPrice1 = 'tickLower__price1',
  TickLowerTickIdx = 'tickLower__tickIdx',
  TickLowerUntrackedVolumeUsd = 'tickLower__untrackedVolumeUSD',
  TickLowerVolumeToken0 = 'tickLower__volumeToken0',
  TickLowerVolumeToken1 = 'tickLower__volumeToken1',
  TickLowerVolumeUsd = 'tickLower__volumeUSD',
  TickUpper = 'tickUpper',
  TickUpperCollectedFeesToken0 = 'tickUpper__collectedFeesToken0',
  TickUpperCollectedFeesToken1 = 'tickUpper__collectedFeesToken1',
  TickUpperCollectedFeesUsd = 'tickUpper__collectedFeesUSD',
  TickUpperCreatedAtBlockNumber = 'tickUpper__createdAtBlockNumber',
  TickUpperCreatedAtTimestamp = 'tickUpper__createdAtTimestamp',
  TickUpperFeeGrowthOutside0X128 = 'tickUpper__feeGrowthOutside0X128',
  TickUpperFeeGrowthOutside1X128 = 'tickUpper__feeGrowthOutside1X128',
  TickUpperFeesUsd = 'tickUpper__feesUSD',
  TickUpperId = 'tickUpper__id',
  TickUpperLiquidityGross = 'tickUpper__liquidityGross',
  TickUpperLiquidityNet = 'tickUpper__liquidityNet',
  TickUpperLiquidityProviderCount = 'tickUpper__liquidityProviderCount',
  TickUpperPoolAddress = 'tickUpper__poolAddress',
  TickUpperPrice0 = 'tickUpper__price0',
  TickUpperPrice1 = 'tickUpper__price1',
  TickUpperTickIdx = 'tickUpper__tickIdx',
  TickUpperUntrackedVolumeUsd = 'tickUpper__untrackedVolumeUSD',
  TickUpperVolumeToken0 = 'tickUpper__volumeToken0',
  TickUpperVolumeToken1 = 'tickUpper__volumeToken1',
  TickUpperVolumeUsd = 'tickUpper__volumeUSD',
  Token0 = 'token0',
  Token0Tvl = 'token0Tvl',
  Token0Decimals = 'token0__decimals',
  Token0DerivedMatic = 'token0__derivedMatic',
  Token0FeesUsd = 'token0__feesUSD',
  Token0Id = 'token0__id',
  Token0Name = 'token0__name',
  Token0PoolCount = 'token0__poolCount',
  Token0Symbol = 'token0__symbol',
  Token0TotalSupply = 'token0__totalSupply',
  Token0TotalValueLocked = 'token0__totalValueLocked',
  Token0TotalValueLockedUsd = 'token0__totalValueLockedUSD',
  Token0TotalValueLockedUsdUntracked = 'token0__totalValueLockedUSDUntracked',
  Token0TxCount = 'token0__txCount',
  Token0UntrackedVolumeUsd = 'token0__untrackedVolumeUSD',
  Token0Volume = 'token0__volume',
  Token0VolumeUsd = 'token0__volumeUSD',
  Token1 = 'token1',
  Token1Tvl = 'token1Tvl',
  Token1Decimals = 'token1__decimals',
  Token1DerivedMatic = 'token1__derivedMatic',
  Token1FeesUsd = 'token1__feesUSD',
  Token1Id = 'token1__id',
  Token1Name = 'token1__name',
  Token1PoolCount = 'token1__poolCount',
  Token1Symbol = 'token1__symbol',
  Token1TotalSupply = 'token1__totalSupply',
  Token1TotalValueLocked = 'token1__totalValueLocked',
  Token1TotalValueLockedUsd = 'token1__totalValueLockedUSD',
  Token1TotalValueLockedUsdUntracked = 'token1__totalValueLockedUSDUntracked',
  Token1TxCount = 'token1__txCount',
  Token1UntrackedVolumeUsd = 'token1__untrackedVolumeUSD',
  Token1Volume = 'token1__volume',
  Token1VolumeUsd = 'token1__volumeUSD',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp',
  WithdrawnToken0 = 'withdrawnToken0',
  WithdrawnToken1 = 'withdrawnToken1'
}

export type Query = {
  __typename?: 'Query';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  algebraDayData?: Maybe<AlgebraDayData>;
  algebraDayDatas: Array<AlgebraDayData>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  bundle?: Maybe<Bundle>;
  bundles: Array<Bundle>;
  burn?: Maybe<Burn>;
  burns: Array<Burn>;
  collect?: Maybe<Collect>;
  collects: Array<Collect>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  eternalFarming?: Maybe<EternalFarming>;
  eternalFarmings: Array<EternalFarming>;
  factories: Array<Factory>;
  factory?: Maybe<Factory>;
  feeHourData?: Maybe<FeeHourData>;
  feeHourDatas: Array<FeeHourData>;
  flash?: Maybe<Flash>;
  flashes: Array<Flash>;
  mint?: Maybe<Mint>;
  mints: Array<Mint>;
  pool?: Maybe<Pool>;
  poolDayData?: Maybe<PoolDayData>;
  poolDayDatas: Array<PoolDayData>;
  poolFeeData?: Maybe<PoolFeeData>;
  poolFeeDatas: Array<PoolFeeData>;
  poolHourData?: Maybe<PoolHourData>;
  poolHourDatas: Array<PoolHourData>;
  poolPosition?: Maybe<PoolPosition>;
  poolPositions: Array<PoolPosition>;
  pools: Array<Pool>;
  position?: Maybe<Position>;
  positionSnapshot?: Maybe<PositionSnapshot>;
  positionSnapshots: Array<PositionSnapshot>;
  positions: Array<Position>;
  reward?: Maybe<Reward>;
  rewards: Array<Reward>;
  swap?: Maybe<Swap>;
  swaps: Array<Swap>;
  tick?: Maybe<Tick>;
  tickDayData?: Maybe<TickDayData>;
  tickDayDatas: Array<TickDayData>;
  tickHourData?: Maybe<TickHourData>;
  tickHourDatas: Array<TickHourData>;
  ticks: Array<Tick>;
  token?: Maybe<Token>;
  tokenDayData?: Maybe<TokenDayData>;
  tokenDayDatas: Array<TokenDayData>;
  tokenHourData?: Maybe<TokenHourData>;
  tokenHourDatas: Array<TokenHourData>;
  tokens: Array<Token>;
  transaction?: Maybe<Transaction>;
  transactions: Array<Transaction>;
};


export type Query_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};


export type QueryAlgebraDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAlgebraDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AlgebraDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AlgebraDayData_Filter>;
};


export type QueryBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};


export type QueryBundleArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryBundlesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Bundle_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Bundle_Filter>;
};


export type QueryBurnArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryBurnsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Burn_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Burn_Filter>;
};


export type QueryCollectArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryCollectsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Collect_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Collect_Filter>;
};


export type QueryDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};


export type QueryEternalFarmingArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryEternalFarmingsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EternalFarming_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<EternalFarming_Filter>;
};


export type QueryFactoriesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Factory_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Factory_Filter>;
};


export type QueryFactoryArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFeeHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFeeHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FeeHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FeeHourData_Filter>;
};


export type QueryFlashArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFlashesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Flash_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Flash_Filter>;
};


export type QueryMintArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryMintsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Mint_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Mint_Filter>;
};


export type QueryPoolArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPoolDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPoolDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolDayData_Filter>;
};


export type QueryPoolFeeDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPoolFeeDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolFeeData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolFeeData_Filter>;
};


export type QueryPoolHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPoolHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolHourData_Filter>;
};


export type QueryPoolPositionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPoolPositionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolPosition_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolPosition_Filter>;
};


export type QueryPoolsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Pool_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pool_Filter>;
};


export type QueryPositionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPositionSnapshotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPositionSnapshotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PositionSnapshot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PositionSnapshot_Filter>;
};


export type QueryPositionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Position_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Position_Filter>;
};


export type QueryRewardArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRewardsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Reward_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Reward_Filter>;
};


export type QuerySwapArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySwapsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Swap_Filter>;
};


export type QueryTickArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTickDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTickDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TickDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TickDayData_Filter>;
};


export type QueryTickHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTickHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TickHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TickHourData_Filter>;
};


export type QueryTicksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Tick_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Tick_Filter>;
};


export type QueryTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TokenDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDayData_Filter>;
};


export type QueryTokenHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TokenHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenHourData_Filter>;
};


export type QueryTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};


export type QueryTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type Reward = {
  __typename?: 'Reward';
  amount: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  owner: Scalars['Bytes']['output'];
  rewardAddress: Scalars['Bytes']['output'];
};

export type Reward_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount?: InputMaybe<Scalars['BigInt']['input']>;
  amount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  amount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not?: InputMaybe<Scalars['BigInt']['input']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Reward_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Reward_Filter>>>;
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
  owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  rewardAddress?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_contains?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_gt?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_gte?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  rewardAddress_lt?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_lte?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_not?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  rewardAddress_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};

export enum Reward_OrderBy {
  Amount = 'amount',
  Id = 'id',
  Owner = 'owner',
  RewardAddress = 'rewardAddress'
}

export type Subscription = {
  __typename?: 'Subscription';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  algebraDayData?: Maybe<AlgebraDayData>;
  algebraDayDatas: Array<AlgebraDayData>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  bundle?: Maybe<Bundle>;
  bundles: Array<Bundle>;
  burn?: Maybe<Burn>;
  burns: Array<Burn>;
  collect?: Maybe<Collect>;
  collects: Array<Collect>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  eternalFarming?: Maybe<EternalFarming>;
  eternalFarmings: Array<EternalFarming>;
  factories: Array<Factory>;
  factory?: Maybe<Factory>;
  feeHourData?: Maybe<FeeHourData>;
  feeHourDatas: Array<FeeHourData>;
  flash?: Maybe<Flash>;
  flashes: Array<Flash>;
  mint?: Maybe<Mint>;
  mints: Array<Mint>;
  pool?: Maybe<Pool>;
  poolDayData?: Maybe<PoolDayData>;
  poolDayDatas: Array<PoolDayData>;
  poolFeeData?: Maybe<PoolFeeData>;
  poolFeeDatas: Array<PoolFeeData>;
  poolHourData?: Maybe<PoolHourData>;
  poolHourDatas: Array<PoolHourData>;
  poolPosition?: Maybe<PoolPosition>;
  poolPositions: Array<PoolPosition>;
  pools: Array<Pool>;
  position?: Maybe<Position>;
  positionSnapshot?: Maybe<PositionSnapshot>;
  positionSnapshots: Array<PositionSnapshot>;
  positions: Array<Position>;
  reward?: Maybe<Reward>;
  rewards: Array<Reward>;
  swap?: Maybe<Swap>;
  swaps: Array<Swap>;
  tick?: Maybe<Tick>;
  tickDayData?: Maybe<TickDayData>;
  tickDayDatas: Array<TickDayData>;
  tickHourData?: Maybe<TickHourData>;
  tickHourDatas: Array<TickHourData>;
  ticks: Array<Tick>;
  token?: Maybe<Token>;
  tokenDayData?: Maybe<TokenDayData>;
  tokenDayDatas: Array<TokenDayData>;
  tokenHourData?: Maybe<TokenHourData>;
  tokenHourDatas: Array<TokenHourData>;
  tokens: Array<Token>;
  transaction?: Maybe<Transaction>;
  transactions: Array<Transaction>;
};


export type Subscription_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};


export type SubscriptionAlgebraDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAlgebraDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AlgebraDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AlgebraDayData_Filter>;
};


export type SubscriptionBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};


export type SubscriptionBundleArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionBundlesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Bundle_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Bundle_Filter>;
};


export type SubscriptionBurnArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionBurnsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Burn_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Burn_Filter>;
};


export type SubscriptionCollectArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionCollectsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Collect_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Collect_Filter>;
};


export type SubscriptionDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};


export type SubscriptionEternalFarmingArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionEternalFarmingsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EternalFarming_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<EternalFarming_Filter>;
};


export type SubscriptionFactoriesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Factory_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Factory_Filter>;
};


export type SubscriptionFactoryArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFeeHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFeeHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FeeHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FeeHourData_Filter>;
};


export type SubscriptionFlashArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFlashesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Flash_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Flash_Filter>;
};


export type SubscriptionMintArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionMintsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Mint_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Mint_Filter>;
};


export type SubscriptionPoolArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPoolDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPoolDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolDayData_Filter>;
};


export type SubscriptionPoolFeeDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPoolFeeDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolFeeData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolFeeData_Filter>;
};


export type SubscriptionPoolHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPoolHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolHourData_Filter>;
};


export type SubscriptionPoolPositionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPoolPositionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PoolPosition_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PoolPosition_Filter>;
};


export type SubscriptionPoolsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Pool_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pool_Filter>;
};


export type SubscriptionPositionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPositionSnapshotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPositionSnapshotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PositionSnapshot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PositionSnapshot_Filter>;
};


export type SubscriptionPositionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Position_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Position_Filter>;
};


export type SubscriptionRewardArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRewardsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Reward_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Reward_Filter>;
};


export type SubscriptionSwapArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSwapsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Swap_Filter>;
};


export type SubscriptionTickArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTickDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTickDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TickDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TickDayData_Filter>;
};


export type SubscriptionTickHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTickHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TickHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TickHourData_Filter>;
};


export type SubscriptionTicksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Tick_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Tick_Filter>;
};


export type SubscriptionTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenDayDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenDayDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TokenDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDayData_Filter>;
};


export type SubscriptionTokenHourDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenHourDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TokenHourData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenHourData_Filter>;
};


export type SubscriptionTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};


export type SubscriptionTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID']['input'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type Swap = {
  __typename?: 'Swap';
  amount0: Scalars['BigDecimal']['output'];
  amount1: Scalars['BigDecimal']['output'];
  amountUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidity: Scalars['BigInt']['output'];
  logIndex?: Maybe<Scalars['BigInt']['output']>;
  origin: Scalars['Bytes']['output'];
  pool: Pool;
  price: Scalars['BigInt']['output'];
  recipient: Scalars['Bytes']['output'];
  sender: Scalars['Bytes']['output'];
  tick: Scalars['BigInt']['output'];
  timestamp: Scalars['BigInt']['output'];
  token0: Token;
  token1: Token;
  transaction: Transaction;
};

export type Swap_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  amount0?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amount1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amount1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  amountUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  amountUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  and?: InputMaybe<Array<InputMaybe<Swap_Filter>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidity?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidity_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidity_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']['input']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Swap_Filter>>>;
  origin?: InputMaybe<Scalars['Bytes']['input']>;
  origin_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_gte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  origin_lt?: InputMaybe<Scalars['Bytes']['input']>;
  origin_lte?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  origin_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['BigInt']['input']>;
  price_gt?: InputMaybe<Scalars['BigInt']['input']>;
  price_gte?: InputMaybe<Scalars['BigInt']['input']>;
  price_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  price_lt?: InputMaybe<Scalars['BigInt']['input']>;
  price_lte?: InputMaybe<Scalars['BigInt']['input']>;
  price_not?: InputMaybe<Scalars['BigInt']['input']>;
  price_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  recipient?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_contains?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_gt?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_gte?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  recipient_lt?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_lte?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  recipient_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  sender?: InputMaybe<Scalars['Bytes']['input']>;
  sender_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_gte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']['input']>;
  sender_lte?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
  tick?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tick_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tick_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not?: InputMaybe<Scalars['BigInt']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  token0?: InputMaybe<Scalars['String']['input']>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']['input']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_gt?: InputMaybe<Scalars['String']['input']>;
  token0_gte?: InputMaybe<Scalars['String']['input']>;
  token0_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_lt?: InputMaybe<Scalars['String']['input']>;
  token0_lte?: InputMaybe<Scalars['String']['input']>;
  token0_not?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains?: InputMaybe<Scalars['String']['input']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with?: InputMaybe<Scalars['String']['input']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1?: InputMaybe<Scalars['String']['input']>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']['input']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_gt?: InputMaybe<Scalars['String']['input']>;
  token1_gte?: InputMaybe<Scalars['String']['input']>;
  token1_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_lt?: InputMaybe<Scalars['String']['input']>;
  token1_lte?: InputMaybe<Scalars['String']['input']>;
  token1_not?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains?: InputMaybe<Scalars['String']['input']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with?: InputMaybe<Scalars['String']['input']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction?: InputMaybe<Scalars['String']['input']>;
  transaction_?: InputMaybe<Transaction_Filter>;
  transaction_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_gt?: InputMaybe<Scalars['String']['input']>;
  transaction_gte?: InputMaybe<Scalars['String']['input']>;
  transaction_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_lt?: InputMaybe<Scalars['String']['input']>;
  transaction_lte?: InputMaybe<Scalars['String']['input']>;
  transaction_not?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains?: InputMaybe<Scalars['String']['input']>;
  transaction_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  transaction_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with?: InputMaybe<Scalars['String']['input']>;
  transaction_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};

export enum Swap_OrderBy {
  Amount0 = 'amount0',
  Amount1 = 'amount1',
  AmountUsd = 'amountUSD',
  Id = 'id',
  Liquidity = 'liquidity',
  LogIndex = 'logIndex',
  Origin = 'origin',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Price = 'price',
  Recipient = 'recipient',
  Sender = 'sender',
  Tick = 'tick',
  Timestamp = 'timestamp',
  Token0 = 'token0',
  Token0Decimals = 'token0__decimals',
  Token0DerivedMatic = 'token0__derivedMatic',
  Token0FeesUsd = 'token0__feesUSD',
  Token0Id = 'token0__id',
  Token0Name = 'token0__name',
  Token0PoolCount = 'token0__poolCount',
  Token0Symbol = 'token0__symbol',
  Token0TotalSupply = 'token0__totalSupply',
  Token0TotalValueLocked = 'token0__totalValueLocked',
  Token0TotalValueLockedUsd = 'token0__totalValueLockedUSD',
  Token0TotalValueLockedUsdUntracked = 'token0__totalValueLockedUSDUntracked',
  Token0TxCount = 'token0__txCount',
  Token0UntrackedVolumeUsd = 'token0__untrackedVolumeUSD',
  Token0Volume = 'token0__volume',
  Token0VolumeUsd = 'token0__volumeUSD',
  Token1 = 'token1',
  Token1Decimals = 'token1__decimals',
  Token1DerivedMatic = 'token1__derivedMatic',
  Token1FeesUsd = 'token1__feesUSD',
  Token1Id = 'token1__id',
  Token1Name = 'token1__name',
  Token1PoolCount = 'token1__poolCount',
  Token1Symbol = 'token1__symbol',
  Token1TotalSupply = 'token1__totalSupply',
  Token1TotalValueLocked = 'token1__totalValueLocked',
  Token1TotalValueLockedUsd = 'token1__totalValueLockedUSD',
  Token1TotalValueLockedUsdUntracked = 'token1__totalValueLockedUSDUntracked',
  Token1TxCount = 'token1__txCount',
  Token1UntrackedVolumeUsd = 'token1__untrackedVolumeUSD',
  Token1Volume = 'token1__volume',
  Token1VolumeUsd = 'token1__volumeUSD',
  Transaction = 'transaction',
  TransactionBlockNumber = 'transaction__blockNumber',
  TransactionGasLimit = 'transaction__gasLimit',
  TransactionGasPrice = 'transaction__gasPrice',
  TransactionId = 'transaction__id',
  TransactionTimestamp = 'transaction__timestamp'
}

export type Tick = {
  __typename?: 'Tick';
  collectedFeesToken0: Scalars['BigDecimal']['output'];
  collectedFeesToken1: Scalars['BigDecimal']['output'];
  collectedFeesUSD: Scalars['BigDecimal']['output'];
  createdAtBlockNumber: Scalars['BigInt']['output'];
  createdAtTimestamp: Scalars['BigInt']['output'];
  feeGrowthOutside0X128: Scalars['BigInt']['output'];
  feeGrowthOutside1X128: Scalars['BigInt']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidityGross: Scalars['BigInt']['output'];
  liquidityNet: Scalars['BigInt']['output'];
  liquidityProviderCount: Scalars['BigInt']['output'];
  pool: Pool;
  poolAddress?: Maybe<Scalars['String']['output']>;
  price0: Scalars['BigDecimal']['output'];
  price1: Scalars['BigDecimal']['output'];
  tickIdx: Scalars['BigInt']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type TickDayData = {
  __typename?: 'TickDayData';
  date: Scalars['Int']['output'];
  feeGrowthOutside0X128: Scalars['BigInt']['output'];
  feeGrowthOutside1X128: Scalars['BigInt']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidityGross: Scalars['BigInt']['output'];
  liquidityNet: Scalars['BigInt']['output'];
  pool: Pool;
  tick: Tick;
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type TickDayData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TickDayData_Filter>>>;
  date?: InputMaybe<Scalars['Int']['input']>;
  date_gt?: InputMaybe<Scalars['Int']['input']>;
  date_gte?: InputMaybe<Scalars['Int']['input']>;
  date_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  date_lt?: InputMaybe<Scalars['Int']['input']>;
  date_lte?: InputMaybe<Scalars['Int']['input']>;
  date_not?: InputMaybe<Scalars['Int']['input']>;
  date_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  feeGrowthOutside0X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside0X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside1X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside1X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidityGross?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityGross_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<TickDayData_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick?: InputMaybe<Scalars['String']['input']>;
  tick_?: InputMaybe<Tick_Filter>;
  tick_contains?: InputMaybe<Scalars['String']['input']>;
  tick_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_ends_with?: InputMaybe<Scalars['String']['input']>;
  tick_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_gt?: InputMaybe<Scalars['String']['input']>;
  tick_gte?: InputMaybe<Scalars['String']['input']>;
  tick_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tick_lt?: InputMaybe<Scalars['String']['input']>;
  tick_lte?: InputMaybe<Scalars['String']['input']>;
  tick_not?: InputMaybe<Scalars['String']['input']>;
  tick_not_contains?: InputMaybe<Scalars['String']['input']>;
  tick_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  tick_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tick_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  tick_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_starts_with?: InputMaybe<Scalars['String']['input']>;
  tick_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum TickDayData_OrderBy {
  Date = 'date',
  FeeGrowthOutside0X128 = 'feeGrowthOutside0X128',
  FeeGrowthOutside1X128 = 'feeGrowthOutside1X128',
  FeesUsd = 'feesUSD',
  Id = 'id',
  LiquidityGross = 'liquidityGross',
  LiquidityNet = 'liquidityNet',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Tick = 'tick',
  TickCollectedFeesToken0 = 'tick__collectedFeesToken0',
  TickCollectedFeesToken1 = 'tick__collectedFeesToken1',
  TickCollectedFeesUsd = 'tick__collectedFeesUSD',
  TickCreatedAtBlockNumber = 'tick__createdAtBlockNumber',
  TickCreatedAtTimestamp = 'tick__createdAtTimestamp',
  TickFeeGrowthOutside0X128 = 'tick__feeGrowthOutside0X128',
  TickFeeGrowthOutside1X128 = 'tick__feeGrowthOutside1X128',
  TickFeesUsd = 'tick__feesUSD',
  TickId = 'tick__id',
  TickLiquidityGross = 'tick__liquidityGross',
  TickLiquidityNet = 'tick__liquidityNet',
  TickLiquidityProviderCount = 'tick__liquidityProviderCount',
  TickPoolAddress = 'tick__poolAddress',
  TickPrice0 = 'tick__price0',
  TickPrice1 = 'tick__price1',
  TickTickIdx = 'tick__tickIdx',
  TickUntrackedVolumeUsd = 'tick__untrackedVolumeUSD',
  TickVolumeToken0 = 'tick__volumeToken0',
  TickVolumeToken1 = 'tick__volumeToken1',
  TickVolumeUsd = 'tick__volumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type TickHourData = {
  __typename?: 'TickHourData';
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  liquidityGross: Scalars['BigInt']['output'];
  liquidityNet: Scalars['BigInt']['output'];
  periodStartUnix: Scalars['Int']['output'];
  pool: Pool;
  tick: Tick;
  volumeToken0: Scalars['BigDecimal']['output'];
  volumeToken1: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type TickHourData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TickHourData_Filter>>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidityGross?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityGross_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<TickHourData_Filter>>>;
  periodStartUnix?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  periodStartUnix_lt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_lte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick?: InputMaybe<Scalars['String']['input']>;
  tick_?: InputMaybe<Tick_Filter>;
  tick_contains?: InputMaybe<Scalars['String']['input']>;
  tick_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_ends_with?: InputMaybe<Scalars['String']['input']>;
  tick_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_gt?: InputMaybe<Scalars['String']['input']>;
  tick_gte?: InputMaybe<Scalars['String']['input']>;
  tick_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tick_lt?: InputMaybe<Scalars['String']['input']>;
  tick_lte?: InputMaybe<Scalars['String']['input']>;
  tick_not?: InputMaybe<Scalars['String']['input']>;
  tick_not_contains?: InputMaybe<Scalars['String']['input']>;
  tick_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  tick_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  tick_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  tick_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tick_starts_with?: InputMaybe<Scalars['String']['input']>;
  tick_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum TickHourData_OrderBy {
  FeesUsd = 'feesUSD',
  Id = 'id',
  LiquidityGross = 'liquidityGross',
  LiquidityNet = 'liquidityNet',
  PeriodStartUnix = 'periodStartUnix',
  Pool = 'pool',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Tick = 'tick',
  TickCollectedFeesToken0 = 'tick__collectedFeesToken0',
  TickCollectedFeesToken1 = 'tick__collectedFeesToken1',
  TickCollectedFeesUsd = 'tick__collectedFeesUSD',
  TickCreatedAtBlockNumber = 'tick__createdAtBlockNumber',
  TickCreatedAtTimestamp = 'tick__createdAtTimestamp',
  TickFeeGrowthOutside0X128 = 'tick__feeGrowthOutside0X128',
  TickFeeGrowthOutside1X128 = 'tick__feeGrowthOutside1X128',
  TickFeesUsd = 'tick__feesUSD',
  TickId = 'tick__id',
  TickLiquidityGross = 'tick__liquidityGross',
  TickLiquidityNet = 'tick__liquidityNet',
  TickLiquidityProviderCount = 'tick__liquidityProviderCount',
  TickPoolAddress = 'tick__poolAddress',
  TickPrice0 = 'tick__price0',
  TickPrice1 = 'tick__price1',
  TickTickIdx = 'tick__tickIdx',
  TickUntrackedVolumeUsd = 'tick__untrackedVolumeUSD',
  TickVolumeToken0 = 'tick__volumeToken0',
  TickVolumeToken1 = 'tick__volumeToken1',
  TickVolumeUsd = 'tick__volumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type Tick_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Tick_Filter>>>;
  collectedFeesToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  collectedFeesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  collectedFeesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside0X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside0X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside0X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside1X128?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_gt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_gte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feeGrowthOutside1X128_lt?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_lte?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_not?: InputMaybe<Scalars['BigInt']['input']>;
  feeGrowthOutside1X128_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  liquidityGross?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityGross_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityGross_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityNet_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityNet_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityProviderCount?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  liquidityProviderCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  liquidityProviderCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  or?: InputMaybe<Array<InputMaybe<Tick_Filter>>>;
  pool?: InputMaybe<Scalars['String']['input']>;
  poolAddress?: InputMaybe<Scalars['String']['input']>;
  poolAddress_contains?: InputMaybe<Scalars['String']['input']>;
  poolAddress_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  poolAddress_ends_with?: InputMaybe<Scalars['String']['input']>;
  poolAddress_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  poolAddress_gt?: InputMaybe<Scalars['String']['input']>;
  poolAddress_gte?: InputMaybe<Scalars['String']['input']>;
  poolAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;
  poolAddress_lt?: InputMaybe<Scalars['String']['input']>;
  poolAddress_lte?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_contains?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  poolAddress_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  poolAddress_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  poolAddress_starts_with?: InputMaybe<Scalars['String']['input']>;
  poolAddress_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']['input']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_gt?: InputMaybe<Scalars['String']['input']>;
  pool_gte?: InputMaybe<Scalars['String']['input']>;
  pool_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_lt?: InputMaybe<Scalars['String']['input']>;
  pool_lte?: InputMaybe<Scalars['String']['input']>;
  pool_not?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains?: InputMaybe<Scalars['String']['input']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with?: InputMaybe<Scalars['String']['input']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  price0?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  price0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  price0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  price1?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  price1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  price1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  tickIdx?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_gt?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_gte?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  tickIdx_lt?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_lte?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_not?: InputMaybe<Scalars['BigInt']['input']>;
  tickIdx_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken0_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken0_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeToken1_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeToken1_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum Tick_OrderBy {
  CollectedFeesToken0 = 'collectedFeesToken0',
  CollectedFeesToken1 = 'collectedFeesToken1',
  CollectedFeesUsd = 'collectedFeesUSD',
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  FeeGrowthOutside0X128 = 'feeGrowthOutside0X128',
  FeeGrowthOutside1X128 = 'feeGrowthOutside1X128',
  FeesUsd = 'feesUSD',
  Id = 'id',
  LiquidityGross = 'liquidityGross',
  LiquidityNet = 'liquidityNet',
  LiquidityProviderCount = 'liquidityProviderCount',
  Pool = 'pool',
  PoolAddress = 'poolAddress',
  PoolCollectedFeesToken0 = 'pool__collectedFeesToken0',
  PoolCollectedFeesToken1 = 'pool__collectedFeesToken1',
  PoolCollectedFeesUsd = 'pool__collectedFeesUSD',
  PoolCommunityFee = 'pool__communityFee',
  PoolCreatedAtBlockNumber = 'pool__createdAtBlockNumber',
  PoolCreatedAtTimestamp = 'pool__createdAtTimestamp',
  PoolFee = 'pool__fee',
  PoolFeeGrowthGlobal0X128 = 'pool__feeGrowthGlobal0X128',
  PoolFeeGrowthGlobal1X128 = 'pool__feeGrowthGlobal1X128',
  PoolFeesToken0 = 'pool__feesToken0',
  PoolFeesToken1 = 'pool__feesToken1',
  PoolFeesUsd = 'pool__feesUSD',
  PoolId = 'pool__id',
  PoolLiquidity = 'pool__liquidity',
  PoolLiquidityProviderCount = 'pool__liquidityProviderCount',
  PoolObservationIndex = 'pool__observationIndex',
  PoolSqrtPrice = 'pool__sqrtPrice',
  PoolTick = 'pool__tick',
  PoolTickSpacing = 'pool__tickSpacing',
  PoolToken0Price = 'pool__token0Price',
  PoolToken1Price = 'pool__token1Price',
  PoolTotalValueLockedMatic = 'pool__totalValueLockedMatic',
  PoolTotalValueLockedToken0 = 'pool__totalValueLockedToken0',
  PoolTotalValueLockedToken1 = 'pool__totalValueLockedToken1',
  PoolTotalValueLockedUsd = 'pool__totalValueLockedUSD',
  PoolTotalValueLockedUsdUntracked = 'pool__totalValueLockedUSDUntracked',
  PoolTxCount = 'pool__txCount',
  PoolUntrackedFeesUsd = 'pool__untrackedFeesUSD',
  PoolUntrackedVolumeUsd = 'pool__untrackedVolumeUSD',
  PoolVolumeToken0 = 'pool__volumeToken0',
  PoolVolumeToken1 = 'pool__volumeToken1',
  PoolVolumeUsd = 'pool__volumeUSD',
  Price0 = 'price0',
  Price1 = 'price1',
  TickIdx = 'tickIdx',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  VolumeToken0 = 'volumeToken0',
  VolumeToken1 = 'volumeToken1',
  VolumeUsd = 'volumeUSD'
}

export type Token = {
  __typename?: 'Token';
  decimals: Scalars['BigInt']['output'];
  derivedMatic: Scalars['BigDecimal']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  poolCount: Scalars['BigInt']['output'];
  symbol: Scalars['String']['output'];
  tokenDayData: Array<TokenDayData>;
  totalSupply: Scalars['BigInt']['output'];
  totalValueLocked: Scalars['BigDecimal']['output'];
  totalValueLockedUSD: Scalars['BigDecimal']['output'];
  totalValueLockedUSDUntracked: Scalars['BigDecimal']['output'];
  txCount: Scalars['BigInt']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volume: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
  whitelistPools: Array<Pool>;
};


export type TokenTokenDayDataArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TokenDayData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TokenDayData_Filter>;
};


export type TokenWhitelistPoolsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Pool_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Pool_Filter>;
};

export type TokenDayData = {
  __typename?: 'TokenDayData';
  close: Scalars['BigDecimal']['output'];
  date: Scalars['Int']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  high: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  low: Scalars['BigDecimal']['output'];
  open: Scalars['BigDecimal']['output'];
  priceUSD: Scalars['BigDecimal']['output'];
  token: Token;
  totalValueLocked: Scalars['BigDecimal']['output'];
  totalValueLockedUSD: Scalars['BigDecimal']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volume: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type TokenDayData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenDayData_Filter>>>;
  close?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  close_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  date?: InputMaybe<Scalars['Int']['input']>;
  date_gt?: InputMaybe<Scalars['Int']['input']>;
  date_gte?: InputMaybe<Scalars['Int']['input']>;
  date_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  date_lt?: InputMaybe<Scalars['Int']['input']>;
  date_lte?: InputMaybe<Scalars['Int']['input']>;
  date_not?: InputMaybe<Scalars['Int']['input']>;
  date_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  low?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  low_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  or?: InputMaybe<Array<InputMaybe<TokenDayData_Filter>>>;
  priceUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  priceUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token?: InputMaybe<Scalars['String']['input']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']['input']>;
  token_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token_ends_with?: InputMaybe<Scalars['String']['input']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_gt?: InputMaybe<Scalars['String']['input']>;
  token_gte?: InputMaybe<Scalars['String']['input']>;
  token_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token_lt?: InputMaybe<Scalars['String']['input']>;
  token_lte?: InputMaybe<Scalars['String']['input']>;
  token_not?: InputMaybe<Scalars['String']['input']>;
  token_not_contains?: InputMaybe<Scalars['String']['input']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_starts_with?: InputMaybe<Scalars['String']['input']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  totalValueLocked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum TokenDayData_OrderBy {
  Close = 'close',
  Date = 'date',
  FeesUsd = 'feesUSD',
  High = 'high',
  Id = 'id',
  Low = 'low',
  Open = 'open',
  PriceUsd = 'priceUSD',
  Token = 'token',
  TokenDecimals = 'token__decimals',
  TokenDerivedMatic = 'token__derivedMatic',
  TokenFeesUsd = 'token__feesUSD',
  TokenId = 'token__id',
  TokenName = 'token__name',
  TokenPoolCount = 'token__poolCount',
  TokenSymbol = 'token__symbol',
  TokenTotalSupply = 'token__totalSupply',
  TokenTotalValueLocked = 'token__totalValueLocked',
  TokenTotalValueLockedUsd = 'token__totalValueLockedUSD',
  TokenTotalValueLockedUsdUntracked = 'token__totalValueLockedUSDUntracked',
  TokenTxCount = 'token__txCount',
  TokenUntrackedVolumeUsd = 'token__untrackedVolumeUSD',
  TokenVolume = 'token__volume',
  TokenVolumeUsd = 'token__volumeUSD',
  TotalValueLocked = 'totalValueLocked',
  TotalValueLockedUsd = 'totalValueLockedUSD',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  Volume = 'volume',
  VolumeUsd = 'volumeUSD'
}

export type TokenHourData = {
  __typename?: 'TokenHourData';
  close: Scalars['BigDecimal']['output'];
  feesUSD: Scalars['BigDecimal']['output'];
  high: Scalars['BigDecimal']['output'];
  id: Scalars['ID']['output'];
  low: Scalars['BigDecimal']['output'];
  open: Scalars['BigDecimal']['output'];
  periodStartUnix: Scalars['Int']['output'];
  priceUSD: Scalars['BigDecimal']['output'];
  token: Token;
  totalValueLocked: Scalars['BigDecimal']['output'];
  totalValueLockedUSD: Scalars['BigDecimal']['output'];
  untrackedVolumeUSD: Scalars['BigDecimal']['output'];
  volume: Scalars['BigDecimal']['output'];
  volumeUSD: Scalars['BigDecimal']['output'];
};

export type TokenHourData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenHourData_Filter>>>;
  close?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  close_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  close_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  high_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  high_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  low?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  low_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  low_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  open_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  open_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  or?: InputMaybe<Array<InputMaybe<TokenHourData_Filter>>>;
  periodStartUnix?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_gte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  periodStartUnix_lt?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_lte?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not?: InputMaybe<Scalars['Int']['input']>;
  periodStartUnix_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  priceUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  priceUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  priceUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  token?: InputMaybe<Scalars['String']['input']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']['input']>;
  token_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token_ends_with?: InputMaybe<Scalars['String']['input']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_gt?: InputMaybe<Scalars['String']['input']>;
  token_gte?: InputMaybe<Scalars['String']['input']>;
  token_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token_lt?: InputMaybe<Scalars['String']['input']>;
  token_lte?: InputMaybe<Scalars['String']['input']>;
  token_not?: InputMaybe<Scalars['String']['input']>;
  token_not_contains?: InputMaybe<Scalars['String']['input']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  token_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  token_starts_with?: InputMaybe<Scalars['String']['input']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  totalValueLocked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
};

export enum TokenHourData_OrderBy {
  Close = 'close',
  FeesUsd = 'feesUSD',
  High = 'high',
  Id = 'id',
  Low = 'low',
  Open = 'open',
  PeriodStartUnix = 'periodStartUnix',
  PriceUsd = 'priceUSD',
  Token = 'token',
  TokenDecimals = 'token__decimals',
  TokenDerivedMatic = 'token__derivedMatic',
  TokenFeesUsd = 'token__feesUSD',
  TokenId = 'token__id',
  TokenName = 'token__name',
  TokenPoolCount = 'token__poolCount',
  TokenSymbol = 'token__symbol',
  TokenTotalSupply = 'token__totalSupply',
  TokenTotalValueLocked = 'token__totalValueLocked',
  TokenTotalValueLockedUsd = 'token__totalValueLockedUSD',
  TokenTotalValueLockedUsdUntracked = 'token__totalValueLockedUSDUntracked',
  TokenTxCount = 'token__txCount',
  TokenUntrackedVolumeUsd = 'token__untrackedVolumeUSD',
  TokenVolume = 'token__volume',
  TokenVolumeUsd = 'token__volumeUSD',
  TotalValueLocked = 'totalValueLocked',
  TotalValueLockedUsd = 'totalValueLockedUSD',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  Volume = 'volume',
  VolumeUsd = 'volumeUSD'
}

export type Token_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  decimals?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_gt?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_gte?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  decimals_lt?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_lte?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_not?: InputMaybe<Scalars['BigInt']['input']>;
  decimals_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  derivedMatic?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  derivedMatic_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  derivedMatic_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  feesUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  feesUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_contains?: InputMaybe<Scalars['String']['input']>;
  name_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  name_ends_with?: InputMaybe<Scalars['String']['input']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  name_gt?: InputMaybe<Scalars['String']['input']>;
  name_gte?: InputMaybe<Scalars['String']['input']>;
  name_in?: InputMaybe<Array<Scalars['String']['input']>>;
  name_lt?: InputMaybe<Scalars['String']['input']>;
  name_lte?: InputMaybe<Scalars['String']['input']>;
  name_not?: InputMaybe<Scalars['String']['input']>;
  name_not_contains?: InputMaybe<Scalars['String']['input']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  name_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  name_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  name_starts_with?: InputMaybe<Scalars['String']['input']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  or?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  poolCount?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  poolCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  poolCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  symbol?: InputMaybe<Scalars['String']['input']>;
  symbol_contains?: InputMaybe<Scalars['String']['input']>;
  symbol_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  symbol_ends_with?: InputMaybe<Scalars['String']['input']>;
  symbol_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  symbol_gt?: InputMaybe<Scalars['String']['input']>;
  symbol_gte?: InputMaybe<Scalars['String']['input']>;
  symbol_in?: InputMaybe<Array<Scalars['String']['input']>>;
  symbol_lt?: InputMaybe<Scalars['String']['input']>;
  symbol_lte?: InputMaybe<Scalars['String']['input']>;
  symbol_not?: InputMaybe<Scalars['String']['input']>;
  symbol_not_contains?: InputMaybe<Scalars['String']['input']>;
  symbol_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
  symbol_not_ends_with?: InputMaybe<Scalars['String']['input']>;
  symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
  symbol_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
  symbol_not_starts_with?: InputMaybe<Scalars['String']['input']>;
  symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  symbol_starts_with?: InputMaybe<Scalars['String']['input']>;
  symbol_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
  tokenDayData_?: InputMaybe<TokenDayData_Filter>;
  totalSupply?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_gt?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_gte?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  totalSupply_lt?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_lte?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_not?: InputMaybe<Scalars['BigInt']['input']>;
  totalSupply_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  totalValueLocked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSDUntracked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSDUntracked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLockedUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLockedUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  totalValueLocked_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  totalValueLocked_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  txCount?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_gte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  txCount_lt?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_lte?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not?: InputMaybe<Scalars['BigInt']['input']>;
  txCount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  untrackedVolumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  untrackedVolumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  untrackedVolumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volumeUSD_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volumeUSD_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_gt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_gte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  volume_lt?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_lte?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not?: InputMaybe<Scalars['BigDecimal']['input']>;
  volume_not_in?: InputMaybe<Array<Scalars['BigDecimal']['input']>>;
  whitelistPools?: InputMaybe<Array<Scalars['String']['input']>>;
  whitelistPools_?: InputMaybe<Pool_Filter>;
  whitelistPools_contains?: InputMaybe<Array<Scalars['String']['input']>>;
  whitelistPools_contains_nocase?: InputMaybe<Array<Scalars['String']['input']>>;
  whitelistPools_not?: InputMaybe<Array<Scalars['String']['input']>>;
  whitelistPools_not_contains?: InputMaybe<Array<Scalars['String']['input']>>;
  whitelistPools_not_contains_nocase?: InputMaybe<Array<Scalars['String']['input']>>;
};

export enum Token_OrderBy {
  Decimals = 'decimals',
  DerivedMatic = 'derivedMatic',
  FeesUsd = 'feesUSD',
  Id = 'id',
  Name = 'name',
  PoolCount = 'poolCount',
  Symbol = 'symbol',
  TokenDayData = 'tokenDayData',
  TotalSupply = 'totalSupply',
  TotalValueLocked = 'totalValueLocked',
  TotalValueLockedUsd = 'totalValueLockedUSD',
  TotalValueLockedUsdUntracked = 'totalValueLockedUSDUntracked',
  TxCount = 'txCount',
  UntrackedVolumeUsd = 'untrackedVolumeUSD',
  Volume = 'volume',
  VolumeUsd = 'volumeUSD',
  WhitelistPools = 'whitelistPools'
}

export type Transaction = {
  __typename?: 'Transaction';
  blockNumber: Scalars['BigInt']['output'];
  burns: Array<Burn>;
  collects: Array<Collect>;
  flashed: Array<Flash>;
  gasLimit: Scalars['BigInt']['output'];
  gasPrice: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  mints: Array<Mint>;
  swaps: Array<Swap>;
  timestamp: Scalars['BigInt']['output'];
};


export type TransactionBurnsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Burn_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Burn_Filter>;
};


export type TransactionCollectsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Collect_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Collect_Filter>;
};


export type TransactionFlashedArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Flash_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Flash_Filter>;
};


export type TransactionMintsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Mint_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Mint_Filter>;
};


export type TransactionSwapsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Swap_Filter>;
};

export type Transaction_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Transaction_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']['input']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  burns_?: InputMaybe<Burn_Filter>;
  collects_?: InputMaybe<Collect_Filter>;
  flashed_?: InputMaybe<Flash_Filter>;
  gasLimit?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_gt?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_gte?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasLimit_lt?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_lte?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_not?: InputMaybe<Scalars['BigInt']['input']>;
  gasLimit_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']['input']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_gt?: InputMaybe<Scalars['ID']['input']>;
  id_gte?: InputMaybe<Scalars['ID']['input']>;
  id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_lt?: InputMaybe<Scalars['ID']['input']>;
  id_lte?: InputMaybe<Scalars['ID']['input']>;
  id_not?: InputMaybe<Scalars['ID']['input']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
  mints_?: InputMaybe<Mint_Filter>;
  or?: InputMaybe<Array<InputMaybe<Transaction_Filter>>>;
  swaps_?: InputMaybe<Swap_Filter>;
  timestamp?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export enum Transaction_OrderBy {
  BlockNumber = 'blockNumber',
  Burns = 'burns',
  Collects = 'collects',
  Flashed = 'flashed',
  GasLimit = 'gasLimit',
  GasPrice = 'gasPrice',
  Id = 'id',
  Mints = 'mints',
  Swaps = 'swaps',
  Timestamp = 'timestamp'
}

export type _Block_ = {
  __typename?: '_Block_';
  /** The hash of the block */
  hash?: Maybe<Scalars['Bytes']['output']>;
  /** The block number */
  number: Scalars['Int']['output'];
  /** Integer representation of the timestamp stored in blocks for the chain */
  timestamp?: Maybe<Scalars['Int']['output']>;
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  __typename?: '_Meta_';
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   *
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars['String']['output'];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars['Boolean']['output'];
};

export enum _SubgraphErrorPolicy_ {
  /** Data will be returned even if the subgraph has indexing errors */
  Allow = 'allow',
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  Deny = 'deny'
}

export type BlockFieldsFragment = { __typename?: 'Block', number: any, timestamp: any };

export type EternalFarmingsQueryVariables = Exact<{
  pool?: InputMaybe<Scalars['Bytes']['input']>;
}>;


export type EternalFarmingsQuery = { __typename?: 'Query', eternalFarmings: Array<{ __typename?: 'EternalFarming', id: string, reward: any, bonusReward: any, rewardRate: any, bonusRewardRate: any, rewardToken: any, bonusRewardToken: any, isDeactivated?: boolean | null, nonce: any, minRangeLength: any, virtualPool: any, pool: any }> };

export type DepositsQueryVariables = Exact<{
  owner?: InputMaybe<Scalars['Bytes']['input']>;
  pool?: InputMaybe<Scalars['Bytes']['input']>;
}>;


export type DepositsQuery = { __typename?: 'Query', deposits: Array<{ __typename?: 'Deposit', eternalFarming?: any | null, id: string, liquidity: any, owner: any, pool: any, rangeLength: any }> };

export type ActiveFarmingsQueryVariables = Exact<{ [key: string]: never; }>;


export type ActiveFarmingsQuery = { __typename?: 'Query', eternalFarmings: Array<{ __typename?: 'EternalFarming', pool: any, id: string }> };

export type BundleFieldsFragment = { __typename?: 'Bundle', id: string, maticPriceUSD: any };

export type NativePriceQueryVariables = Exact<{ [key: string]: never; }>;


export type NativePriceQuery = { __typename?: 'Query', bundles: Array<{ __typename?: 'Bundle', id: string, maticPriceUSD: any }> };

export type PoolFieldsFragment = { __typename?: 'Pool', id: string, fee: any, sqrtPrice: any, liquidity: any, tick: any, tickSpacing: any, totalValueLockedUSD: any, volumeUSD: any, feesUSD: any, untrackedFeesUSD: any, token0Price: any, token1Price: any, token0: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any }, token1: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any } };

export type TickFieldsFragment = { __typename?: 'Tick', tickIdx: any, liquidityNet: any, liquidityGross: any, price0: any, price1: any };

export type PoolFeeDataFieldsFragment = { __typename?: 'PoolDayData', feesUSD: any };

export type PoolDayDataFieldsFragment = { __typename?: 'PoolDayData', feesUSD: any, tvlUSD: any, volumeUSD: any, id: string, date: number };

export type PoolsListQueryVariables = Exact<{ [key: string]: never; }>;


export type PoolsListQuery = { __typename?: 'Query', pools: Array<{ __typename?: 'Pool', id: string, fee: any, sqrtPrice: any, liquidity: any, tick: any, tickSpacing: any, totalValueLockedUSD: any, volumeUSD: any, feesUSD: any, untrackedFeesUSD: any, token0Price: any, token1Price: any, poolDayData: Array<{ __typename?: 'PoolDayData', feesUSD: any, tvlUSD: any, volumeUSD: any, id: string, date: number }>, token0: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any }, token1: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any } }> };

export type AllTicksQueryVariables = Exact<{
  poolAddress: Scalars['String']['input'];
  skip: Scalars['Int']['input'];
}>;


export type AllTicksQuery = { __typename?: 'Query', ticks: Array<{ __typename?: 'Tick', tickIdx: any, liquidityNet: any, liquidityGross: any, price0: any, price1: any }> };

export type SinglePoolQueryVariables = Exact<{
  poolId: Scalars['ID']['input'];
}>;


export type SinglePoolQuery = { __typename?: 'Query', pool?: { __typename?: 'Pool', id: string, fee: any, sqrtPrice: any, liquidity: any, tick: any, tickSpacing: any, totalValueLockedUSD: any, volumeUSD: any, feesUSD: any, untrackedFeesUSD: any, token0Price: any, token1Price: any, token0: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any }, token1: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any } } | null };

export type MultiplePoolsQueryVariables = Exact<{
  poolIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
}>;


export type MultiplePoolsQuery = { __typename?: 'Query', pools: Array<{ __typename?: 'Pool', id: string, fee: any, sqrtPrice: any, liquidity: any, tick: any, tickSpacing: any, totalValueLockedUSD: any, volumeUSD: any, feesUSD: any, untrackedFeesUSD: any, token0Price: any, token1Price: any, token0: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any }, token1: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any } }> };

export type PoolFeeDataQueryVariables = Exact<{
  poolId?: InputMaybe<Scalars['String']['input']>;
}>;


export type PoolFeeDataQuery = { __typename?: 'Query', poolDayDatas: Array<{ __typename?: 'PoolDayData', feesUSD: any }> };

export type TokenFieldsFragment = { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any };

export type SingleTokenQueryVariables = Exact<{
  tokenId: Scalars['ID']['input'];
}>;


export type SingleTokenQuery = { __typename?: 'Query', token?: { __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any } | null };

export type AllTokensQueryVariables = Exact<{ [key: string]: never; }>;


export type AllTokensQuery = { __typename?: 'Query', tokens: Array<{ __typename?: 'Token', id: string, symbol: string, name: string, decimals: any, derivedMatic: any }> };

export const BlockFieldsFragmentDoc = gql`
    fragment BlockFields on Block {
  number
  timestamp
}
    `;
export const BundleFieldsFragmentDoc = gql`
    fragment BundleFields on Bundle {
  id
  maticPriceUSD
}
    `;
export const TokenFieldsFragmentDoc = gql`
    fragment TokenFields on Token {
  id
  symbol
  name
  decimals
  derivedMatic
}
    `;
export const PoolFieldsFragmentDoc = gql`
    fragment PoolFields on Pool {
  id
  fee
  token0 {
    ...TokenFields
  }
  token1 {
    ...TokenFields
  }
  sqrtPrice
  liquidity
  tick
  tickSpacing
  totalValueLockedUSD
  volumeUSD
  feesUSD
  untrackedFeesUSD
  token0Price
  token1Price
}
    ${TokenFieldsFragmentDoc}`;
export const TickFieldsFragmentDoc = gql`
    fragment TickFields on Tick {
  tickIdx
  liquidityNet
  liquidityGross
  price0
  price1
}
    `;
export const PoolFeeDataFieldsFragmentDoc = gql`
    fragment PoolFeeDataFields on PoolDayData {
  feesUSD
}
    `;
export const PoolDayDataFieldsFragmentDoc = gql`
    fragment PoolDayDataFields on PoolDayData {
  feesUSD
  tvlUSD
  volumeUSD
  id
  date
}
    `;
export const EternalFarmingsDocument = gql`
    query EternalFarmings($pool: Bytes) {
  eternalFarmings(where: {pool: $pool}) {
    id
    reward
    bonusReward
    rewardRate
    bonusRewardRate
    rewardToken
    bonusRewardToken
    isDeactivated
    nonce
    minRangeLength
    virtualPool
    pool
  }
}
    `;

/**
 * __useEternalFarmingsQuery__
 *
 * To run a query within a React component, call `useEternalFarmingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEternalFarmingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEternalFarmingsQuery({
 *   variables: {
 *      pool: // value for 'pool'
 *   },
 * });
 */
export function useEternalFarmingsQuery(baseOptions?: Apollo.QueryHookOptions<EternalFarmingsQuery, EternalFarmingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EternalFarmingsQuery, EternalFarmingsQueryVariables>(EternalFarmingsDocument, options);
      }
export function useEternalFarmingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EternalFarmingsQuery, EternalFarmingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EternalFarmingsQuery, EternalFarmingsQueryVariables>(EternalFarmingsDocument, options);
        }
export function useEternalFarmingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<EternalFarmingsQuery, EternalFarmingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EternalFarmingsQuery, EternalFarmingsQueryVariables>(EternalFarmingsDocument, options);
        }
export type EternalFarmingsQueryHookResult = ReturnType<typeof useEternalFarmingsQuery>;
export type EternalFarmingsLazyQueryHookResult = ReturnType<typeof useEternalFarmingsLazyQuery>;
export type EternalFarmingsSuspenseQueryHookResult = ReturnType<typeof useEternalFarmingsSuspenseQuery>;
export type EternalFarmingsQueryResult = Apollo.QueryResult<EternalFarmingsQuery, EternalFarmingsQueryVariables>;
export const DepositsDocument = gql`
    query Deposits($owner: Bytes, $pool: Bytes) {
  deposits(where: {owner: $owner, pool: $pool}) {
    eternalFarming
    id
    liquidity
    owner
    pool
    rangeLength
  }
}
    `;

/**
 * __useDepositsQuery__
 *
 * To run a query within a React component, call `useDepositsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDepositsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDepositsQuery({
 *   variables: {
 *      owner: // value for 'owner'
 *      pool: // value for 'pool'
 *   },
 * });
 */
export function useDepositsQuery(baseOptions?: Apollo.QueryHookOptions<DepositsQuery, DepositsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DepositsQuery, DepositsQueryVariables>(DepositsDocument, options);
      }
export function useDepositsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DepositsQuery, DepositsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DepositsQuery, DepositsQueryVariables>(DepositsDocument, options);
        }
export function useDepositsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<DepositsQuery, DepositsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DepositsQuery, DepositsQueryVariables>(DepositsDocument, options);
        }
export type DepositsQueryHookResult = ReturnType<typeof useDepositsQuery>;
export type DepositsLazyQueryHookResult = ReturnType<typeof useDepositsLazyQuery>;
export type DepositsSuspenseQueryHookResult = ReturnType<typeof useDepositsSuspenseQuery>;
export type DepositsQueryResult = Apollo.QueryResult<DepositsQuery, DepositsQueryVariables>;
export const ActiveFarmingsDocument = gql`
    query ActiveFarmings {
  eternalFarmings(where: {isDeactivated: false}) {
    pool
    id
  }
}
    `;

/**
 * __useActiveFarmingsQuery__
 *
 * To run a query within a React component, call `useActiveFarmingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveFarmingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveFarmingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useActiveFarmingsQuery(baseOptions?: Apollo.QueryHookOptions<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>(ActiveFarmingsDocument, options);
      }
export function useActiveFarmingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>(ActiveFarmingsDocument, options);
        }
export function useActiveFarmingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>(ActiveFarmingsDocument, options);
        }
export type ActiveFarmingsQueryHookResult = ReturnType<typeof useActiveFarmingsQuery>;
export type ActiveFarmingsLazyQueryHookResult = ReturnType<typeof useActiveFarmingsLazyQuery>;
export type ActiveFarmingsSuspenseQueryHookResult = ReturnType<typeof useActiveFarmingsSuspenseQuery>;
export type ActiveFarmingsQueryResult = Apollo.QueryResult<ActiveFarmingsQuery, ActiveFarmingsQueryVariables>;
export const NativePriceDocument = gql`
    query NativePrice {
  bundles {
    ...BundleFields
  }
}
    ${BundleFieldsFragmentDoc}`;

/**
 * __useNativePriceQuery__
 *
 * To run a query within a React component, call `useNativePriceQuery` and pass it any options that fit your needs.
 * When your component renders, `useNativePriceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNativePriceQuery({
 *   variables: {
 *   },
 * });
 */
export function useNativePriceQuery(baseOptions?: Apollo.QueryHookOptions<NativePriceQuery, NativePriceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NativePriceQuery, NativePriceQueryVariables>(NativePriceDocument, options);
      }
export function useNativePriceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NativePriceQuery, NativePriceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NativePriceQuery, NativePriceQueryVariables>(NativePriceDocument, options);
        }
export function useNativePriceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<NativePriceQuery, NativePriceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NativePriceQuery, NativePriceQueryVariables>(NativePriceDocument, options);
        }
export type NativePriceQueryHookResult = ReturnType<typeof useNativePriceQuery>;
export type NativePriceLazyQueryHookResult = ReturnType<typeof useNativePriceLazyQuery>;
export type NativePriceSuspenseQueryHookResult = ReturnType<typeof useNativePriceSuspenseQuery>;
export type NativePriceQueryResult = Apollo.QueryResult<NativePriceQuery, NativePriceQueryVariables>;
export const PoolsListDocument = gql`
    query PoolsList {
  pools {
    ...PoolFields
    poolDayData(first: 1, orderBy: date, orderDirection: desc) {
      ...PoolDayDataFields
    }
  }
}
    ${PoolFieldsFragmentDoc}
${PoolDayDataFieldsFragmentDoc}`;

/**
 * __usePoolsListQuery__
 *
 * To run a query within a React component, call `usePoolsListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePoolsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePoolsListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePoolsListQuery(baseOptions?: Apollo.QueryHookOptions<PoolsListQuery, PoolsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PoolsListQuery, PoolsListQueryVariables>(PoolsListDocument, options);
      }
export function usePoolsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PoolsListQuery, PoolsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PoolsListQuery, PoolsListQueryVariables>(PoolsListDocument, options);
        }
export function usePoolsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PoolsListQuery, PoolsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PoolsListQuery, PoolsListQueryVariables>(PoolsListDocument, options);
        }
export type PoolsListQueryHookResult = ReturnType<typeof usePoolsListQuery>;
export type PoolsListLazyQueryHookResult = ReturnType<typeof usePoolsListLazyQuery>;
export type PoolsListSuspenseQueryHookResult = ReturnType<typeof usePoolsListSuspenseQuery>;
export type PoolsListQueryResult = Apollo.QueryResult<PoolsListQuery, PoolsListQueryVariables>;
export const AllTicksDocument = gql`
    query allTicks($poolAddress: String!, $skip: Int!) {
  ticks(
    first: 1000
    skip: $skip
    where: {poolAddress: $poolAddress}
    orderBy: tickIdx
  ) {
    ...TickFields
  }
}
    ${TickFieldsFragmentDoc}`;

/**
 * __useAllTicksQuery__
 *
 * To run a query within a React component, call `useAllTicksQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllTicksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllTicksQuery({
 *   variables: {
 *      poolAddress: // value for 'poolAddress'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useAllTicksQuery(baseOptions: Apollo.QueryHookOptions<AllTicksQuery, AllTicksQueryVariables> & ({ variables: AllTicksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllTicksQuery, AllTicksQueryVariables>(AllTicksDocument, options);
      }
export function useAllTicksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllTicksQuery, AllTicksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllTicksQuery, AllTicksQueryVariables>(AllTicksDocument, options);
        }
export function useAllTicksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AllTicksQuery, AllTicksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllTicksQuery, AllTicksQueryVariables>(AllTicksDocument, options);
        }
export type AllTicksQueryHookResult = ReturnType<typeof useAllTicksQuery>;
export type AllTicksLazyQueryHookResult = ReturnType<typeof useAllTicksLazyQuery>;
export type AllTicksSuspenseQueryHookResult = ReturnType<typeof useAllTicksSuspenseQuery>;
export type AllTicksQueryResult = Apollo.QueryResult<AllTicksQuery, AllTicksQueryVariables>;
export const SinglePoolDocument = gql`
    query SinglePool($poolId: ID!) {
  pool(id: $poolId) {
    ...PoolFields
  }
}
    ${PoolFieldsFragmentDoc}`;

/**
 * __useSinglePoolQuery__
 *
 * To run a query within a React component, call `useSinglePoolQuery` and pass it any options that fit your needs.
 * When your component renders, `useSinglePoolQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSinglePoolQuery({
 *   variables: {
 *      poolId: // value for 'poolId'
 *   },
 * });
 */
export function useSinglePoolQuery(baseOptions: Apollo.QueryHookOptions<SinglePoolQuery, SinglePoolQueryVariables> & ({ variables: SinglePoolQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SinglePoolQuery, SinglePoolQueryVariables>(SinglePoolDocument, options);
      }
export function useSinglePoolLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SinglePoolQuery, SinglePoolQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SinglePoolQuery, SinglePoolQueryVariables>(SinglePoolDocument, options);
        }
export function useSinglePoolSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SinglePoolQuery, SinglePoolQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SinglePoolQuery, SinglePoolQueryVariables>(SinglePoolDocument, options);
        }
export type SinglePoolQueryHookResult = ReturnType<typeof useSinglePoolQuery>;
export type SinglePoolLazyQueryHookResult = ReturnType<typeof useSinglePoolLazyQuery>;
export type SinglePoolSuspenseQueryHookResult = ReturnType<typeof useSinglePoolSuspenseQuery>;
export type SinglePoolQueryResult = Apollo.QueryResult<SinglePoolQuery, SinglePoolQueryVariables>;
export const MultiplePoolsDocument = gql`
    query MultiplePools($poolIds: [ID!]) {
  pools(where: {id_in: $poolIds}) {
    ...PoolFields
  }
}
    ${PoolFieldsFragmentDoc}`;

/**
 * __useMultiplePoolsQuery__
 *
 * To run a query within a React component, call `useMultiplePoolsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMultiplePoolsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMultiplePoolsQuery({
 *   variables: {
 *      poolIds: // value for 'poolIds'
 *   },
 * });
 */
export function useMultiplePoolsQuery(baseOptions?: Apollo.QueryHookOptions<MultiplePoolsQuery, MultiplePoolsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MultiplePoolsQuery, MultiplePoolsQueryVariables>(MultiplePoolsDocument, options);
      }
export function useMultiplePoolsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MultiplePoolsQuery, MultiplePoolsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MultiplePoolsQuery, MultiplePoolsQueryVariables>(MultiplePoolsDocument, options);
        }
export function useMultiplePoolsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MultiplePoolsQuery, MultiplePoolsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MultiplePoolsQuery, MultiplePoolsQueryVariables>(MultiplePoolsDocument, options);
        }
export type MultiplePoolsQueryHookResult = ReturnType<typeof useMultiplePoolsQuery>;
export type MultiplePoolsLazyQueryHookResult = ReturnType<typeof useMultiplePoolsLazyQuery>;
export type MultiplePoolsSuspenseQueryHookResult = ReturnType<typeof useMultiplePoolsSuspenseQuery>;
export type MultiplePoolsQueryResult = Apollo.QueryResult<MultiplePoolsQuery, MultiplePoolsQueryVariables>;
export const PoolFeeDataDocument = gql`
    query PoolFeeData($poolId: String) {
  poolDayDatas(where: {pool: $poolId}, orderBy: date, orderDirection: desc) {
    ...PoolFeeDataFields
  }
}
    ${PoolFeeDataFieldsFragmentDoc}`;

/**
 * __usePoolFeeDataQuery__
 *
 * To run a query within a React component, call `usePoolFeeDataQuery` and pass it any options that fit your needs.
 * When your component renders, `usePoolFeeDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePoolFeeDataQuery({
 *   variables: {
 *      poolId: // value for 'poolId'
 *   },
 * });
 */
export function usePoolFeeDataQuery(baseOptions?: Apollo.QueryHookOptions<PoolFeeDataQuery, PoolFeeDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PoolFeeDataQuery, PoolFeeDataQueryVariables>(PoolFeeDataDocument, options);
      }
export function usePoolFeeDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PoolFeeDataQuery, PoolFeeDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PoolFeeDataQuery, PoolFeeDataQueryVariables>(PoolFeeDataDocument, options);
        }
export function usePoolFeeDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PoolFeeDataQuery, PoolFeeDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PoolFeeDataQuery, PoolFeeDataQueryVariables>(PoolFeeDataDocument, options);
        }
export type PoolFeeDataQueryHookResult = ReturnType<typeof usePoolFeeDataQuery>;
export type PoolFeeDataLazyQueryHookResult = ReturnType<typeof usePoolFeeDataLazyQuery>;
export type PoolFeeDataSuspenseQueryHookResult = ReturnType<typeof usePoolFeeDataSuspenseQuery>;
export type PoolFeeDataQueryResult = Apollo.QueryResult<PoolFeeDataQuery, PoolFeeDataQueryVariables>;
export const SingleTokenDocument = gql`
    query SingleToken($tokenId: ID!) {
  token(id: $tokenId) {
    ...TokenFields
  }
}
    ${TokenFieldsFragmentDoc}`;

/**
 * __useSingleTokenQuery__
 *
 * To run a query within a React component, call `useSingleTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSingleTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSingleTokenQuery({
 *   variables: {
 *      tokenId: // value for 'tokenId'
 *   },
 * });
 */
export function useSingleTokenQuery(baseOptions: Apollo.QueryHookOptions<SingleTokenQuery, SingleTokenQueryVariables> & ({ variables: SingleTokenQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SingleTokenQuery, SingleTokenQueryVariables>(SingleTokenDocument, options);
      }
export function useSingleTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SingleTokenQuery, SingleTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SingleTokenQuery, SingleTokenQueryVariables>(SingleTokenDocument, options);
        }
export function useSingleTokenSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SingleTokenQuery, SingleTokenQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SingleTokenQuery, SingleTokenQueryVariables>(SingleTokenDocument, options);
        }
export type SingleTokenQueryHookResult = ReturnType<typeof useSingleTokenQuery>;
export type SingleTokenLazyQueryHookResult = ReturnType<typeof useSingleTokenLazyQuery>;
export type SingleTokenSuspenseQueryHookResult = ReturnType<typeof useSingleTokenSuspenseQuery>;
export type SingleTokenQueryResult = Apollo.QueryResult<SingleTokenQuery, SingleTokenQueryVariables>;
export const AllTokensDocument = gql`
    query AllTokens {
  tokens {
    ...TokenFields
  }
}
    ${TokenFieldsFragmentDoc}`;

/**
 * __useAllTokensQuery__
 *
 * To run a query within a React component, call `useAllTokensQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllTokensQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllTokensQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllTokensQuery(baseOptions?: Apollo.QueryHookOptions<AllTokensQuery, AllTokensQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllTokensQuery, AllTokensQueryVariables>(AllTokensDocument, options);
      }
export function useAllTokensLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllTokensQuery, AllTokensQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllTokensQuery, AllTokensQueryVariables>(AllTokensDocument, options);
        }
export function useAllTokensSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AllTokensQuery, AllTokensQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllTokensQuery, AllTokensQueryVariables>(AllTokensDocument, options);
        }
export type AllTokensQueryHookResult = ReturnType<typeof useAllTokensQuery>;
export type AllTokensLazyQueryHookResult = ReturnType<typeof useAllTokensLazyQuery>;
export type AllTokensSuspenseQueryHookResult = ReturnType<typeof useAllTokensSuspenseQuery>;
export type AllTokensQueryResult = Apollo.QueryResult<AllTokensQuery, AllTokensQueryVariables>;


================================================
File: src/graphql/queries/blocks.ts
================================================
import { gql } from "@apollo/client"

export const BLOCK_FRAGMENT = gql`
    fragment BlockFields on Block {
        number
        timestamp
    }
`

export const GET_BLOCKS = (timestamps: string[]) => {
    let queryString = 'query blocks {'
    queryString += timestamps.map((timestamp) => {
        return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${timestamp + 600
            } }) {
            number
          }`
    })
    queryString += '}'
    return gql(queryString)
}


================================================
File: src/graphql/queries/farmings.ts
================================================
import { gql } from "@apollo/client";

export const ETERNAL_FARMINGS = gql`
    query EternalFarmings($pool: Bytes) {
        eternalFarmings(where: { pool: $pool }) {
            id
            reward
            bonusReward
            rewardRate
            bonusRewardRate
            rewardToken
            bonusRewardToken
            isDeactivated
            nonce
            minRangeLength
            virtualPool
            pool
        }
    }
`;

export const DEPOSITS = gql`
    query Deposits($owner: Bytes, $pool: Bytes) {
        deposits(where: { owner: $owner, pool: $pool }) {
            eternalFarming
            id
            liquidity
            owner
            pool
            rangeLength
        }
    }
`;

export const ACTIVE_FARMINGS = gql`
    query ActiveFarmings {
        eternalFarmings(where: { isDeactivated: false }) {
            pool
            id
        }
    }
`;



================================================
File: src/graphql/queries/global.ts
================================================
import { gql } from "@apollo/client";

export const BUNDLE_FRAGMENT = gql`
    fragment BundleFields on Bundle {
        id
        maticPriceUSD
    }
`

export const NATIVE_PRICE = gql`
    query NativePrice {
        bundles {
            ...BundleFields
        }
    }
`




================================================
File: src/graphql/queries/pools.ts
================================================
import { gql } from "@apollo/client";

export const POOL_FRAGMENT = gql`
    fragment PoolFields on Pool {
        id
        fee
        token0 {
            ...TokenFields
        }
        token1 {
            ...TokenFields
        }
        sqrtPrice
        liquidity
        tick
        tickSpacing
        totalValueLockedUSD
        volumeUSD
        feesUSD
        untrackedFeesUSD
        token0Price
        token1Price
    }
`;
export const TICK_FRAGMENT = gql`
    fragment TickFields on Tick {
        tickIdx
        liquidityNet
        liquidityGross
        price0
        price1
    }
`;

export const POOL_FEE_DATA_FRAGMENT = gql`
    fragment PoolFeeDataFields on PoolDayData {
        feesUSD
    }
`;

export const POOL_DAY_DATA_FRAGMENT = gql`
    fragment PoolDayDataFields on PoolDayData {
        feesUSD
        tvlUSD
        volumeUSD
        id
        date
    }
`;

export const POOLS_LIST = gql`
    query PoolsList {
        pools {
            ...PoolFields
            poolDayData(first: 1, orderBy: date, orderDirection: desc) {
                ...PoolDayDataFields
            }
        }
    }
`;

export const ALL_TICKS = gql`
    query allTicks($poolAddress: String!, $skip: Int!) {
        ticks(first: 1000, skip: $skip, where: { poolAddress: $poolAddress }, orderBy: tickIdx) {
            ...TickFields
        }
    }
`;

export const SINGLE_POOL = gql`
    query SinglePool($poolId: ID!) {
        pool(id: $poolId) {
            ...PoolFields
        }
    }
`;

export const MULTIPLE_POOLS = gql`
    query MultiplePools($poolIds: [ID!]) {
        pools(where: { id_in: $poolIds }) {
            ...PoolFields
        }
    }
`;

export const POOL_FEE_DATA = gql`
    query PoolFeeData($poolId: String) {
        poolDayDatas(where: { pool: $poolId }, orderBy: date, orderDirection: desc) {
            ...PoolFeeDataFields
        }
    }
`;

// export const POOLS_DAY_DATAS = gql`
//     query PoolsVolumeData {
//         poolDayDatas(orderBy: date, orderDirection: desc) {
//             date
//             pool {
//                 id
//             }
//             volumeUSD
//             ...PoolDayDataFields
//         }
//     }
// `;



================================================
File: src/graphql/queries/tokens.ts
================================================
import { gql } from "@apollo/client";

export const TOKEN_FRAGMENT = gql`
    fragment TokenFields on Token {
        id
        symbol
        name
        decimals
        derivedMatic
    }
`

export const SINGLE_TOKEN = gql`
    query SingleToken($tokenId: ID!){
        token(id: $tokenId) {
            ...TokenFields
        }
    }
`

export const ALL_TOKENS = gql`
    query AllTokens {
        tokens {
            ...TokenFields
        }
    }
`


================================================
File: src/graphql/schemas/algebra.graphql
================================================
"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

type AlgebraDayData {
  date: Int!
  feesUSD: BigDecimal!
  id: ID!
  tvlUSD: BigDecimal!
  txCount: BigInt!
  volumeMatic: BigDecimal!
  volumeUSD: BigDecimal!
  volumeUSDUntracked: BigDecimal!
}

input AlgebraDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AlgebraDayData_filter]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AlgebraDayData_filter]
  tvlUSD: BigDecimal
  tvlUSD_gt: BigDecimal
  tvlUSD_gte: BigDecimal
  tvlUSD_in: [BigDecimal!]
  tvlUSD_lt: BigDecimal
  tvlUSD_lte: BigDecimal
  tvlUSD_not: BigDecimal
  tvlUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  volumeMatic: BigDecimal
  volumeMatic_gt: BigDecimal
  volumeMatic_gte: BigDecimal
  volumeMatic_in: [BigDecimal!]
  volumeMatic_lt: BigDecimal
  volumeMatic_lte: BigDecimal
  volumeMatic_not: BigDecimal
  volumeMatic_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSDUntracked: BigDecimal
  volumeUSDUntracked_gt: BigDecimal
  volumeUSDUntracked_gte: BigDecimal
  volumeUSDUntracked_in: [BigDecimal!]
  volumeUSDUntracked_lt: BigDecimal
  volumeUSDUntracked_lte: BigDecimal
  volumeUSDUntracked_not: BigDecimal
  volumeUSDUntracked_not_in: [BigDecimal!]
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum AlgebraDayData_orderBy {
  date
  feesUSD
  id
  tvlUSD
  txCount
  volumeMatic
  volumeUSD
  volumeUSDUntracked
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type Bundle {
  id: ID!
  maticPriceUSD: BigDecimal!
}

input Bundle_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Bundle_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maticPriceUSD: BigDecimal
  maticPriceUSD_gt: BigDecimal
  maticPriceUSD_gte: BigDecimal
  maticPriceUSD_in: [BigDecimal!]
  maticPriceUSD_lt: BigDecimal
  maticPriceUSD_lte: BigDecimal
  maticPriceUSD_not: BigDecimal
  maticPriceUSD_not_in: [BigDecimal!]
  or: [Bundle_filter]
}

enum Bundle_orderBy {
  id
  maticPriceUSD
}

type Burn {
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal
  id: ID!
  logIndex: BigInt
  origin: Bytes!
  owner: Bytes
  pool: Pool!
  tickLower: BigInt!
  tickUpper: BigInt!
  timestamp: BigInt!
  token0: Token!
  token1: Token!
  transaction: Transaction!
}

input Burn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [Burn_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Burn_filter]
  origin: Bytes
  origin_contains: Bytes
  origin_gt: Bytes
  origin_gte: Bytes
  origin_in: [Bytes!]
  origin_lt: Bytes
  origin_lte: Bytes
  origin_not: Bytes
  origin_not_contains: Bytes
  origin_not_in: [Bytes!]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tickLower: BigInt
  tickLower_gt: BigInt
  tickLower_gte: BigInt
  tickLower_in: [BigInt!]
  tickLower_lt: BigInt
  tickLower_lte: BigInt
  tickLower_not: BigInt
  tickLower_not_in: [BigInt!]
  tickUpper: BigInt
  tickUpper_gt: BigInt
  tickUpper_gte: BigInt
  tickUpper_in: [BigInt!]
  tickUpper_lt: BigInt
  tickUpper_lte: BigInt
  tickUpper_not: BigInt
  tickUpper_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Burn_orderBy {
  amount
  amount0
  amount1
  amountUSD
  id
  logIndex
  origin
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  tickLower
  tickUpper
  timestamp
  token0
  token0__decimals
  token0__derivedMatic
  token0__feesUSD
  token0__id
  token0__name
  token0__poolCount
  token0__symbol
  token0__totalSupply
  token0__totalValueLocked
  token0__totalValueLockedUSD
  token0__totalValueLockedUSDUntracked
  token0__txCount
  token0__untrackedVolumeUSD
  token0__volume
  token0__volumeUSD
  token1
  token1__decimals
  token1__derivedMatic
  token1__feesUSD
  token1__id
  token1__name
  token1__poolCount
  token1__symbol
  token1__totalSupply
  token1__totalValueLocked
  token1__totalValueLockedUSD
  token1__totalValueLockedUSDUntracked
  token1__txCount
  token1__untrackedVolumeUSD
  token1__volume
  token1__volumeUSD
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
}

scalar Bytes

type Collect {
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal
  id: ID!
  logIndex: BigInt
  owner: Bytes
  pool: Pool!
  tickLower: BigInt!
  tickUpper: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
}

input Collect_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Collect_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Collect_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tickLower: BigInt
  tickLower_gt: BigInt
  tickLower_gte: BigInt
  tickLower_in: [BigInt!]
  tickLower_lt: BigInt
  tickLower_lte: BigInt
  tickLower_not: BigInt
  tickLower_not_in: [BigInt!]
  tickUpper: BigInt
  tickUpper_gt: BigInt
  tickUpper_gte: BigInt
  tickUpper_in: [BigInt!]
  tickUpper_lt: BigInt
  tickUpper_lte: BigInt
  tickUpper_not: BigInt
  tickUpper_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Collect_orderBy {
  amount0
  amount1
  amountUSD
  id
  logIndex
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  tickLower
  tickUpper
  timestamp
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
}

type Factory {
  defaultCommunityFee: BigInt!
  id: ID!
  owner: ID!
  poolCount: BigInt!
  totalFeesMatic: BigDecimal!
  totalFeesUSD: BigDecimal!
  totalValueLockedMatic: BigDecimal!
  totalValueLockedMaticUntracked: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  totalValueLockedUSDUntracked: BigDecimal!
  totalVolumeMatic: BigDecimal!
  totalVolumeUSD: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
}

input Factory_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Factory_filter]
  defaultCommunityFee: BigInt
  defaultCommunityFee_gt: BigInt
  defaultCommunityFee_gte: BigInt
  defaultCommunityFee_in: [BigInt!]
  defaultCommunityFee_lt: BigInt
  defaultCommunityFee_lte: BigInt
  defaultCommunityFee_not: BigInt
  defaultCommunityFee_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Factory_filter]
  owner: ID
  owner_gt: ID
  owner_gte: ID
  owner_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_not: ID
  owner_not_in: [ID!]
  poolCount: BigInt
  poolCount_gt: BigInt
  poolCount_gte: BigInt
  poolCount_in: [BigInt!]
  poolCount_lt: BigInt
  poolCount_lte: BigInt
  poolCount_not: BigInt
  poolCount_not_in: [BigInt!]
  totalFeesMatic: BigDecimal
  totalFeesMatic_gt: BigDecimal
  totalFeesMatic_gte: BigDecimal
  totalFeesMatic_in: [BigDecimal!]
  totalFeesMatic_lt: BigDecimal
  totalFeesMatic_lte: BigDecimal
  totalFeesMatic_not: BigDecimal
  totalFeesMatic_not_in: [BigDecimal!]
  totalFeesUSD: BigDecimal
  totalFeesUSD_gt: BigDecimal
  totalFeesUSD_gte: BigDecimal
  totalFeesUSD_in: [BigDecimal!]
  totalFeesUSD_lt: BigDecimal
  totalFeesUSD_lte: BigDecimal
  totalFeesUSD_not: BigDecimal
  totalFeesUSD_not_in: [BigDecimal!]
  totalValueLockedMatic: BigDecimal
  totalValueLockedMaticUntracked: BigDecimal
  totalValueLockedMaticUntracked_gt: BigDecimal
  totalValueLockedMaticUntracked_gte: BigDecimal
  totalValueLockedMaticUntracked_in: [BigDecimal!]
  totalValueLockedMaticUntracked_lt: BigDecimal
  totalValueLockedMaticUntracked_lte: BigDecimal
  totalValueLockedMaticUntracked_not: BigDecimal
  totalValueLockedMaticUntracked_not_in: [BigDecimal!]
  totalValueLockedMatic_gt: BigDecimal
  totalValueLockedMatic_gte: BigDecimal
  totalValueLockedMatic_in: [BigDecimal!]
  totalValueLockedMatic_lt: BigDecimal
  totalValueLockedMatic_lte: BigDecimal
  totalValueLockedMatic_not: BigDecimal
  totalValueLockedMatic_not_in: [BigDecimal!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSDUntracked: BigDecimal
  totalValueLockedUSDUntracked_gt: BigDecimal
  totalValueLockedUSDUntracked_gte: BigDecimal
  totalValueLockedUSDUntracked_in: [BigDecimal!]
  totalValueLockedUSDUntracked_lt: BigDecimal
  totalValueLockedUSDUntracked_lte: BigDecimal
  totalValueLockedUSDUntracked_not: BigDecimal
  totalValueLockedUSDUntracked_not_in: [BigDecimal!]
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_not_in: [BigDecimal!]
  totalVolumeMatic: BigDecimal
  totalVolumeMatic_gt: BigDecimal
  totalVolumeMatic_gte: BigDecimal
  totalVolumeMatic_in: [BigDecimal!]
  totalVolumeMatic_lt: BigDecimal
  totalVolumeMatic_lte: BigDecimal
  totalVolumeMatic_not: BigDecimal
  totalVolumeMatic_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
}

enum Factory_orderBy {
  defaultCommunityFee
  id
  owner
  poolCount
  totalFeesMatic
  totalFeesUSD
  totalValueLockedMatic
  totalValueLockedMaticUntracked
  totalValueLockedUSD
  totalValueLockedUSDUntracked
  totalVolumeMatic
  totalVolumeUSD
  txCount
  untrackedVolumeUSD
}

type FeeHourData {
  changesCount: BigInt!
  endFee: BigInt!
  fee: BigInt!
  id: ID!
  maxFee: BigInt!
  minFee: BigInt!
  pool: String!
  startFee: BigInt!
  timestamp: BigInt!
}

input FeeHourData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FeeHourData_filter]
  changesCount: BigInt
  changesCount_gt: BigInt
  changesCount_gte: BigInt
  changesCount_in: [BigInt!]
  changesCount_lt: BigInt
  changesCount_lte: BigInt
  changesCount_not: BigInt
  changesCount_not_in: [BigInt!]
  endFee: BigInt
  endFee_gt: BigInt
  endFee_gte: BigInt
  endFee_in: [BigInt!]
  endFee_lt: BigInt
  endFee_lte: BigInt
  endFee_not: BigInt
  endFee_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maxFee: BigInt
  maxFee_gt: BigInt
  maxFee_gte: BigInt
  maxFee_in: [BigInt!]
  maxFee_lt: BigInt
  maxFee_lte: BigInt
  maxFee_not: BigInt
  maxFee_not_in: [BigInt!]
  minFee: BigInt
  minFee_gt: BigInt
  minFee_gte: BigInt
  minFee_in: [BigInt!]
  minFee_lt: BigInt
  minFee_lte: BigInt
  minFee_not: BigInt
  minFee_not_in: [BigInt!]
  or: [FeeHourData_filter]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  startFee: BigInt
  startFee_gt: BigInt
  startFee_gte: BigInt
  startFee_in: [BigInt!]
  startFee_lt: BigInt
  startFee_lte: BigInt
  startFee_not: BigInt
  startFee_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum FeeHourData_orderBy {
  changesCount
  endFee
  fee
  id
  maxFee
  minFee
  pool
  startFee
  timestamp
}

type Flash {
  amount0: BigDecimal!
  amount0Paid: BigDecimal!
  amount1: BigDecimal!
  amount1Paid: BigDecimal!
  amountUSD: BigDecimal!
  id: ID!
  logIndex: BigInt
  pool: Pool!
  recipient: Bytes!
  sender: Bytes!
  timestamp: BigInt!
  transaction: Transaction!
}

input Flash_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0: BigDecimal
  amount0Paid: BigDecimal
  amount0Paid_gt: BigDecimal
  amount0Paid_gte: BigDecimal
  amount0Paid_in: [BigDecimal!]
  amount0Paid_lt: BigDecimal
  amount0Paid_lte: BigDecimal
  amount0Paid_not: BigDecimal
  amount0Paid_not_in: [BigDecimal!]
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1Paid: BigDecimal
  amount1Paid_gt: BigDecimal
  amount1Paid_gte: BigDecimal
  amount1Paid_in: [BigDecimal!]
  amount1Paid_lt: BigDecimal
  amount1Paid_lte: BigDecimal
  amount1Paid_not: BigDecimal
  amount1Paid_not_in: [BigDecimal!]
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Flash_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Flash_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Flash_orderBy {
  amount0
  amount0Paid
  amount1
  amount1Paid
  amountUSD
  id
  logIndex
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  recipient
  sender
  timestamp
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
}

"8 bytes signed integer\n"
scalar Int8

type Mint {
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal
  id: ID!
  logIndex: BigInt
  origin: Bytes!
  owner: Bytes!
  pool: Pool!
  sender: Bytes
  tickLower: BigInt!
  tickUpper: BigInt!
  timestamp: BigInt!
  token0: Token!
  token1: Token!
  transaction: Transaction!
}

input Mint_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [Mint_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Mint_filter]
  origin: Bytes
  origin_contains: Bytes
  origin_gt: Bytes
  origin_gte: Bytes
  origin_in: [Bytes!]
  origin_lt: Bytes
  origin_lte: Bytes
  origin_not: Bytes
  origin_not_contains: Bytes
  origin_not_in: [Bytes!]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  tickLower: BigInt
  tickLower_gt: BigInt
  tickLower_gte: BigInt
  tickLower_in: [BigInt!]
  tickLower_lt: BigInt
  tickLower_lte: BigInt
  tickLower_not: BigInt
  tickLower_not_in: [BigInt!]
  tickUpper: BigInt
  tickUpper_gt: BigInt
  tickUpper_gte: BigInt
  tickUpper_in: [BigInt!]
  tickUpper_lt: BigInt
  tickUpper_lte: BigInt
  tickUpper_not: BigInt
  tickUpper_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Mint_orderBy {
  amount
  amount0
  amount1
  amountUSD
  id
  logIndex
  origin
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  sender
  tickLower
  tickUpper
  timestamp
  token0
  token0__decimals
  token0__derivedMatic
  token0__feesUSD
  token0__id
  token0__name
  token0__poolCount
  token0__symbol
  token0__totalSupply
  token0__totalValueLocked
  token0__totalValueLockedUSD
  token0__totalValueLockedUSDUntracked
  token0__txCount
  token0__untrackedVolumeUSD
  token0__volume
  token0__volumeUSD
  token1
  token1__decimals
  token1__derivedMatic
  token1__feesUSD
  token1__id
  token1__name
  token1__poolCount
  token1__symbol
  token1__totalSupply
  token1__totalValueLocked
  token1__totalValueLockedUSD
  token1__totalValueLockedUSDUntracked
  token1__txCount
  token1__untrackedVolumeUSD
  token1__volume
  token1__volumeUSD
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  burns(first: Int = 100, orderBy: Burn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Burn_filter): [Burn!]!
  collectedFeesToken0: BigDecimal!
  collectedFeesToken1: BigDecimal!
  collectedFeesUSD: BigDecimal!
  collects(first: Int = 100, orderBy: Collect_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Collect_filter): [Collect!]!
  communityFee: BigInt!
  createdAtBlockNumber: BigInt!
  createdAtTimestamp: BigInt!
  fee: BigInt!
  feeGrowthGlobal0X128: BigInt!
  feeGrowthGlobal1X128: BigInt!
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!
  id: ID!
  liquidity: BigInt!
  liquidityProviderCount: BigInt!
  mints(first: Int = 100, orderBy: Mint_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Mint_filter): [Mint!]!
  observationIndex: BigInt!
  poolDayData(first: Int = 100, orderBy: PoolDayData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolDayData_filter): [PoolDayData!]!
  poolHourData(first: Int = 100, orderBy: PoolHourData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolHourData_filter): [PoolHourData!]!
  sqrtPrice: BigInt!
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]!
  tick: BigInt!
  tickSpacing: BigInt!
  ticks(first: Int = 100, orderBy: Tick_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Tick_filter): [Tick!]!
  token0: Token!
  token0Price: BigDecimal!
  token1: Token!
  token1Price: BigDecimal!
  totalValueLockedMatic: BigDecimal!
  totalValueLockedToken0: BigDecimal!
  totalValueLockedToken1: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  totalValueLockedUSDUntracked: BigDecimal!
  txCount: BigInt!
  untrackedFeesUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

type PoolDayData {
  close: BigDecimal!
  date: Int!
  feeGrowthGlobal0X128: BigInt!
  feeGrowthGlobal1X128: BigInt!
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!
  high: BigDecimal!
  id: ID!
  liquidity: BigInt!
  low: BigDecimal!
  open: BigDecimal!
  pool: Pool!
  sqrtPrice: BigInt!
  tick: BigInt
  token0Price: BigDecimal!
  token1Price: BigDecimal!
  tvlUSD: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

input PoolDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolDayData_filter]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  feeGrowthGlobal0X128: BigInt
  feeGrowthGlobal0X128_gt: BigInt
  feeGrowthGlobal0X128_gte: BigInt
  feeGrowthGlobal0X128_in: [BigInt!]
  feeGrowthGlobal0X128_lt: BigInt
  feeGrowthGlobal0X128_lte: BigInt
  feeGrowthGlobal0X128_not: BigInt
  feeGrowthGlobal0X128_not_in: [BigInt!]
  feeGrowthGlobal1X128: BigInt
  feeGrowthGlobal1X128_gt: BigInt
  feeGrowthGlobal1X128_gte: BigInt
  feeGrowthGlobal1X128_in: [BigInt!]
  feeGrowthGlobal1X128_lt: BigInt
  feeGrowthGlobal1X128_lte: BigInt
  feeGrowthGlobal1X128_not: BigInt
  feeGrowthGlobal1X128_not_in: [BigInt!]
  feesToken0: BigDecimal
  feesToken0_gt: BigDecimal
  feesToken0_gte: BigDecimal
  feesToken0_in: [BigDecimal!]
  feesToken0_lt: BigDecimal
  feesToken0_lte: BigDecimal
  feesToken0_not: BigDecimal
  feesToken0_not_in: [BigDecimal!]
  feesToken1: BigDecimal
  feesToken1_gt: BigDecimal
  feesToken1_gte: BigDecimal
  feesToken1_in: [BigDecimal!]
  feesToken1_lt: BigDecimal
  feesToken1_lte: BigDecimal
  feesToken1_not: BigDecimal
  feesToken1_not_in: [BigDecimal!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [PoolDayData_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sqrtPrice: BigInt
  sqrtPrice_gt: BigInt
  sqrtPrice_gte: BigInt
  sqrtPrice_in: [BigInt!]
  sqrtPrice_lt: BigInt
  sqrtPrice_lte: BigInt
  sqrtPrice_not: BigInt
  sqrtPrice_not_in: [BigInt!]
  tick: BigInt
  tick_gt: BigInt
  tick_gte: BigInt
  tick_in: [BigInt!]
  tick_lt: BigInt
  tick_lte: BigInt
  tick_not: BigInt
  tick_not_in: [BigInt!]
  token0Price: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_lt: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_not: BigDecimal
  token0Price_not_in: [BigDecimal!]
  token1Price: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_lt: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_not: BigDecimal
  token1Price_not_in: [BigDecimal!]
  tvlUSD: BigDecimal
  tvlUSD_gt: BigDecimal
  tvlUSD_gte: BigDecimal
  tvlUSD_in: [BigDecimal!]
  tvlUSD_lt: BigDecimal
  tvlUSD_lte: BigDecimal
  tvlUSD_not: BigDecimal
  tvlUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum PoolDayData_orderBy {
  close
  date
  feeGrowthGlobal0X128
  feeGrowthGlobal1X128
  feesToken0
  feesToken1
  feesUSD
  high
  id
  liquidity
  low
  open
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  sqrtPrice
  tick
  token0Price
  token1Price
  tvlUSD
  txCount
  untrackedVolumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type PoolFeeData {
  fee: BigInt!
  id: ID!
  pool: String
  timestamp: BigInt!
}

input PoolFeeData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolFeeData_filter]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolFeeData_filter]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum PoolFeeData_orderBy {
  fee
  id
  pool
  timestamp
}

type PoolHourData {
  close: BigDecimal!
  feeGrowthGlobal0X128: BigInt!
  feeGrowthGlobal1X128: BigInt!
  feesUSD: BigDecimal!
  high: BigDecimal!
  id: ID!
  liquidity: BigInt!
  low: BigDecimal!
  open: BigDecimal!
  periodStartUnix: Int!
  pool: Pool!
  sqrtPrice: BigInt!
  tick: BigInt
  token0Price: BigDecimal!
  token1Price: BigDecimal!
  tvlUSD: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

input PoolHourData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolHourData_filter]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  feeGrowthGlobal0X128: BigInt
  feeGrowthGlobal0X128_gt: BigInt
  feeGrowthGlobal0X128_gte: BigInt
  feeGrowthGlobal0X128_in: [BigInt!]
  feeGrowthGlobal0X128_lt: BigInt
  feeGrowthGlobal0X128_lte: BigInt
  feeGrowthGlobal0X128_not: BigInt
  feeGrowthGlobal0X128_not_in: [BigInt!]
  feeGrowthGlobal1X128: BigInt
  feeGrowthGlobal1X128_gt: BigInt
  feeGrowthGlobal1X128_gte: BigInt
  feeGrowthGlobal1X128_in: [BigInt!]
  feeGrowthGlobal1X128_lt: BigInt
  feeGrowthGlobal1X128_lte: BigInt
  feeGrowthGlobal1X128_not: BigInt
  feeGrowthGlobal1X128_not_in: [BigInt!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [PoolHourData_filter]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sqrtPrice: BigInt
  sqrtPrice_gt: BigInt
  sqrtPrice_gte: BigInt
  sqrtPrice_in: [BigInt!]
  sqrtPrice_lt: BigInt
  sqrtPrice_lte: BigInt
  sqrtPrice_not: BigInt
  sqrtPrice_not_in: [BigInt!]
  tick: BigInt
  tick_gt: BigInt
  tick_gte: BigInt
  tick_in: [BigInt!]
  tick_lt: BigInt
  tick_lte: BigInt
  tick_not: BigInt
  tick_not_in: [BigInt!]
  token0Price: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_lt: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_not: BigDecimal
  token0Price_not_in: [BigDecimal!]
  token1Price: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_lt: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_not: BigDecimal
  token1Price_not_in: [BigDecimal!]
  tvlUSD: BigDecimal
  tvlUSD_gt: BigDecimal
  tvlUSD_gte: BigDecimal
  tvlUSD_in: [BigDecimal!]
  tvlUSD_lt: BigDecimal
  tvlUSD_lte: BigDecimal
  tvlUSD_not: BigDecimal
  tvlUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum PoolHourData_orderBy {
  close
  feeGrowthGlobal0X128
  feeGrowthGlobal1X128
  feesUSD
  high
  id
  liquidity
  low
  open
  periodStartUnix
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  sqrtPrice
  tick
  token0Price
  token1Price
  tvlUSD
  txCount
  untrackedVolumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type PoolPosition {
  id: ID!
  liquidity: BigInt!
  lowerTick: Tick!
  owner: Bytes!
  pool: Pool!
  upperTick: Tick!
}

input PoolPosition_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolPosition_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  lowerTick: String
  lowerTick_: Tick_filter
  lowerTick_contains: String
  lowerTick_contains_nocase: String
  lowerTick_ends_with: String
  lowerTick_ends_with_nocase: String
  lowerTick_gt: String
  lowerTick_gte: String
  lowerTick_in: [String!]
  lowerTick_lt: String
  lowerTick_lte: String
  lowerTick_not: String
  lowerTick_not_contains: String
  lowerTick_not_contains_nocase: String
  lowerTick_not_ends_with: String
  lowerTick_not_ends_with_nocase: String
  lowerTick_not_in: [String!]
  lowerTick_not_starts_with: String
  lowerTick_not_starts_with_nocase: String
  lowerTick_starts_with: String
  lowerTick_starts_with_nocase: String
  or: [PoolPosition_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  upperTick: String
  upperTick_: Tick_filter
  upperTick_contains: String
  upperTick_contains_nocase: String
  upperTick_ends_with: String
  upperTick_ends_with_nocase: String
  upperTick_gt: String
  upperTick_gte: String
  upperTick_in: [String!]
  upperTick_lt: String
  upperTick_lte: String
  upperTick_not: String
  upperTick_not_contains: String
  upperTick_not_contains_nocase: String
  upperTick_not_ends_with: String
  upperTick_not_ends_with_nocase: String
  upperTick_not_in: [String!]
  upperTick_not_starts_with: String
  upperTick_not_starts_with_nocase: String
  upperTick_starts_with: String
  upperTick_starts_with_nocase: String
}

enum PoolPosition_orderBy {
  id
  liquidity
  lowerTick
  lowerTick__collectedFeesToken0
  lowerTick__collectedFeesToken1
  lowerTick__collectedFeesUSD
  lowerTick__createdAtBlockNumber
  lowerTick__createdAtTimestamp
  lowerTick__feeGrowthOutside0X128
  lowerTick__feeGrowthOutside1X128
  lowerTick__feesUSD
  lowerTick__id
  lowerTick__liquidityGross
  lowerTick__liquidityNet
  lowerTick__liquidityProviderCount
  lowerTick__poolAddress
  lowerTick__price0
  lowerTick__price1
  lowerTick__tickIdx
  lowerTick__untrackedVolumeUSD
  lowerTick__volumeToken0
  lowerTick__volumeToken1
  lowerTick__volumeUSD
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  upperTick
  upperTick__collectedFeesToken0
  upperTick__collectedFeesToken1
  upperTick__collectedFeesUSD
  upperTick__createdAtBlockNumber
  upperTick__createdAtTimestamp
  upperTick__feeGrowthOutside0X128
  upperTick__feeGrowthOutside1X128
  upperTick__feesUSD
  upperTick__id
  upperTick__liquidityGross
  upperTick__liquidityNet
  upperTick__liquidityProviderCount
  upperTick__poolAddress
  upperTick__price0
  upperTick__price1
  upperTick__tickIdx
  upperTick__untrackedVolumeUSD
  upperTick__volumeToken0
  upperTick__volumeToken1
  upperTick__volumeUSD
}

input Pool_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Pool_filter]
  burns_: Burn_filter
  collectedFeesToken0: BigDecimal
  collectedFeesToken0_gt: BigDecimal
  collectedFeesToken0_gte: BigDecimal
  collectedFeesToken0_in: [BigDecimal!]
  collectedFeesToken0_lt: BigDecimal
  collectedFeesToken0_lte: BigDecimal
  collectedFeesToken0_not: BigDecimal
  collectedFeesToken0_not_in: [BigDecimal!]
  collectedFeesToken1: BigDecimal
  collectedFeesToken1_gt: BigDecimal
  collectedFeesToken1_gte: BigDecimal
  collectedFeesToken1_in: [BigDecimal!]
  collectedFeesToken1_lt: BigDecimal
  collectedFeesToken1_lte: BigDecimal
  collectedFeesToken1_not: BigDecimal
  collectedFeesToken1_not_in: [BigDecimal!]
  collectedFeesUSD: BigDecimal
  collectedFeesUSD_gt: BigDecimal
  collectedFeesUSD_gte: BigDecimal
  collectedFeesUSD_in: [BigDecimal!]
  collectedFeesUSD_lt: BigDecimal
  collectedFeesUSD_lte: BigDecimal
  collectedFeesUSD_not: BigDecimal
  collectedFeesUSD_not_in: [BigDecimal!]
  collects_: Collect_filter
  communityFee: BigInt
  communityFee_gt: BigInt
  communityFee_gte: BigInt
  communityFee_in: [BigInt!]
  communityFee_lt: BigInt
  communityFee_lte: BigInt
  communityFee_not: BigInt
  communityFee_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_not_in: [BigInt!]
  fee: BigInt
  feeGrowthGlobal0X128: BigInt
  feeGrowthGlobal0X128_gt: BigInt
  feeGrowthGlobal0X128_gte: BigInt
  feeGrowthGlobal0X128_in: [BigInt!]
  feeGrowthGlobal0X128_lt: BigInt
  feeGrowthGlobal0X128_lte: BigInt
  feeGrowthGlobal0X128_not: BigInt
  feeGrowthGlobal0X128_not_in: [BigInt!]
  feeGrowthGlobal1X128: BigInt
  feeGrowthGlobal1X128_gt: BigInt
  feeGrowthGlobal1X128_gte: BigInt
  feeGrowthGlobal1X128_in: [BigInt!]
  feeGrowthGlobal1X128_lt: BigInt
  feeGrowthGlobal1X128_lte: BigInt
  feeGrowthGlobal1X128_not: BigInt
  feeGrowthGlobal1X128_not_in: [BigInt!]
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  feesToken0: BigDecimal
  feesToken0_gt: BigDecimal
  feesToken0_gte: BigDecimal
  feesToken0_in: [BigDecimal!]
  feesToken0_lt: BigDecimal
  feesToken0_lte: BigDecimal
  feesToken0_not: BigDecimal
  feesToken0_not_in: [BigDecimal!]
  feesToken1: BigDecimal
  feesToken1_gt: BigDecimal
  feesToken1_gte: BigDecimal
  feesToken1_in: [BigDecimal!]
  feesToken1_lt: BigDecimal
  feesToken1_lte: BigDecimal
  feesToken1_not: BigDecimal
  feesToken1_not_in: [BigDecimal!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidityProviderCount: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_not_in: [BigInt!]
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  mints_: Mint_filter
  observationIndex: BigInt
  observationIndex_gt: BigInt
  observationIndex_gte: BigInt
  observationIndex_in: [BigInt!]
  observationIndex_lt: BigInt
  observationIndex_lte: BigInt
  observationIndex_not: BigInt
  observationIndex_not_in: [BigInt!]
  or: [Pool_filter]
  poolDayData_: PoolDayData_filter
  poolHourData_: PoolHourData_filter
  sqrtPrice: BigInt
  sqrtPrice_gt: BigInt
  sqrtPrice_gte: BigInt
  sqrtPrice_in: [BigInt!]
  sqrtPrice_lt: BigInt
  sqrtPrice_lte: BigInt
  sqrtPrice_not: BigInt
  sqrtPrice_not_in: [BigInt!]
  swaps_: Swap_filter
  tick: BigInt
  tickSpacing: BigInt
  tickSpacing_gt: BigInt
  tickSpacing_gte: BigInt
  tickSpacing_in: [BigInt!]
  tickSpacing_lt: BigInt
  tickSpacing_lte: BigInt
  tickSpacing_not: BigInt
  tickSpacing_not_in: [BigInt!]
  tick_gt: BigInt
  tick_gte: BigInt
  tick_in: [BigInt!]
  tick_lt: BigInt
  tick_lte: BigInt
  tick_not: BigInt
  tick_not_in: [BigInt!]
  ticks_: Tick_filter
  token0: String
  token0Price: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_lt: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_not: BigDecimal
  token0Price_not_in: [BigDecimal!]
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1Price: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_lt: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_not: BigDecimal
  token1Price_not_in: [BigDecimal!]
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalValueLockedMatic: BigDecimal
  totalValueLockedMatic_gt: BigDecimal
  totalValueLockedMatic_gte: BigDecimal
  totalValueLockedMatic_in: [BigDecimal!]
  totalValueLockedMatic_lt: BigDecimal
  totalValueLockedMatic_lte: BigDecimal
  totalValueLockedMatic_not: BigDecimal
  totalValueLockedMatic_not_in: [BigDecimal!]
  totalValueLockedToken0: BigDecimal
  totalValueLockedToken0_gt: BigDecimal
  totalValueLockedToken0_gte: BigDecimal
  totalValueLockedToken0_in: [BigDecimal!]
  totalValueLockedToken0_lt: BigDecimal
  totalValueLockedToken0_lte: BigDecimal
  totalValueLockedToken0_not: BigDecimal
  totalValueLockedToken0_not_in: [BigDecimal!]
  totalValueLockedToken1: BigDecimal
  totalValueLockedToken1_gt: BigDecimal
  totalValueLockedToken1_gte: BigDecimal
  totalValueLockedToken1_in: [BigDecimal!]
  totalValueLockedToken1_lt: BigDecimal
  totalValueLockedToken1_lte: BigDecimal
  totalValueLockedToken1_not: BigDecimal
  totalValueLockedToken1_not_in: [BigDecimal!]
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSDUntracked: BigDecimal
  totalValueLockedUSDUntracked_gt: BigDecimal
  totalValueLockedUSDUntracked_gte: BigDecimal
  totalValueLockedUSDUntracked_in: [BigDecimal!]
  totalValueLockedUSDUntracked_lt: BigDecimal
  totalValueLockedUSDUntracked_lte: BigDecimal
  totalValueLockedUSDUntracked_not: BigDecimal
  totalValueLockedUSDUntracked_not_in: [BigDecimal!]
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedFeesUSD: BigDecimal
  untrackedFeesUSD_gt: BigDecimal
  untrackedFeesUSD_gte: BigDecimal
  untrackedFeesUSD_in: [BigDecimal!]
  untrackedFeesUSD_lt: BigDecimal
  untrackedFeesUSD_lte: BigDecimal
  untrackedFeesUSD_not: BigDecimal
  untrackedFeesUSD_not_in: [BigDecimal!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum Pool_orderBy {
  burns
  collectedFeesToken0
  collectedFeesToken1
  collectedFeesUSD
  collects
  communityFee
  createdAtBlockNumber
  createdAtTimestamp
  fee
  feeGrowthGlobal0X128
  feeGrowthGlobal1X128
  feesToken0
  feesToken1
  feesUSD
  id
  liquidity
  liquidityProviderCount
  mints
  observationIndex
  poolDayData
  poolHourData
  sqrtPrice
  swaps
  tick
  tickSpacing
  ticks
  token0
  token0Price
  token0__decimals
  token0__derivedMatic
  token0__feesUSD
  token0__id
  token0__name
  token0__poolCount
  token0__symbol
  token0__totalSupply
  token0__totalValueLocked
  token0__totalValueLockedUSD
  token0__totalValueLockedUSDUntracked
  token0__txCount
  token0__untrackedVolumeUSD
  token0__volume
  token0__volumeUSD
  token1
  token1Price
  token1__decimals
  token1__derivedMatic
  token1__feesUSD
  token1__id
  token1__name
  token1__poolCount
  token1__symbol
  token1__totalSupply
  token1__totalValueLocked
  token1__totalValueLockedUSD
  token1__totalValueLockedUSDUntracked
  token1__txCount
  token1__untrackedVolumeUSD
  token1__volume
  token1__volumeUSD
  totalValueLockedMatic
  totalValueLockedToken0
  totalValueLockedToken1
  totalValueLockedUSD
  totalValueLockedUSDUntracked
  txCount
  untrackedFeesUSD
  untrackedVolumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type Position {
  collectedFeesToken0: BigDecimal!
  collectedFeesToken1: BigDecimal!
  collectedToken0: BigDecimal!
  collectedToken1: BigDecimal!
  depositedToken0: BigDecimal!
  depositedToken1: BigDecimal!
  feeGrowthInside0LastX128: BigInt!
  feeGrowthInside1LastX128: BigInt!
  id: ID!
  liquidity: BigInt!
  owner: Bytes!
  pool: Pool!
  tickLower: Tick!
  tickUpper: Tick!
  token0: Token!
  token0Tvl: BigDecimal
  token1: Token!
  token1Tvl: BigDecimal
  transaction: Transaction!
  withdrawnToken0: BigDecimal!
  withdrawnToken1: BigDecimal!
}

type PositionSnapshot {
  blockNumber: BigInt!
  collectedFeesToken0: BigDecimal!
  collectedFeesToken1: BigDecimal!
  depositedToken0: BigDecimal!
  depositedToken1: BigDecimal!
  feeGrowthInside0LastX128: BigInt!
  feeGrowthInside1LastX128: BigInt!
  id: ID!
  liquidity: BigInt!
  owner: Bytes!
  pool: Pool!
  position: Position!
  timestamp: BigInt!
  transaction: Transaction!
  withdrawnToken0: BigDecimal!
  withdrawnToken1: BigDecimal!
}

input PositionSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PositionSnapshot_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  collectedFeesToken0: BigDecimal
  collectedFeesToken0_gt: BigDecimal
  collectedFeesToken0_gte: BigDecimal
  collectedFeesToken0_in: [BigDecimal!]
  collectedFeesToken0_lt: BigDecimal
  collectedFeesToken0_lte: BigDecimal
  collectedFeesToken0_not: BigDecimal
  collectedFeesToken0_not_in: [BigDecimal!]
  collectedFeesToken1: BigDecimal
  collectedFeesToken1_gt: BigDecimal
  collectedFeesToken1_gte: BigDecimal
  collectedFeesToken1_in: [BigDecimal!]
  collectedFeesToken1_lt: BigDecimal
  collectedFeesToken1_lte: BigDecimal
  collectedFeesToken1_not: BigDecimal
  collectedFeesToken1_not_in: [BigDecimal!]
  depositedToken0: BigDecimal
  depositedToken0_gt: BigDecimal
  depositedToken0_gte: BigDecimal
  depositedToken0_in: [BigDecimal!]
  depositedToken0_lt: BigDecimal
  depositedToken0_lte: BigDecimal
  depositedToken0_not: BigDecimal
  depositedToken0_not_in: [BigDecimal!]
  depositedToken1: BigDecimal
  depositedToken1_gt: BigDecimal
  depositedToken1_gte: BigDecimal
  depositedToken1_in: [BigDecimal!]
  depositedToken1_lt: BigDecimal
  depositedToken1_lte: BigDecimal
  depositedToken1_not: BigDecimal
  depositedToken1_not_in: [BigDecimal!]
  feeGrowthInside0LastX128: BigInt
  feeGrowthInside0LastX128_gt: BigInt
  feeGrowthInside0LastX128_gte: BigInt
  feeGrowthInside0LastX128_in: [BigInt!]
  feeGrowthInside0LastX128_lt: BigInt
  feeGrowthInside0LastX128_lte: BigInt
  feeGrowthInside0LastX128_not: BigInt
  feeGrowthInside0LastX128_not_in: [BigInt!]
  feeGrowthInside1LastX128: BigInt
  feeGrowthInside1LastX128_gt: BigInt
  feeGrowthInside1LastX128_gte: BigInt
  feeGrowthInside1LastX128_in: [BigInt!]
  feeGrowthInside1LastX128_lt: BigInt
  feeGrowthInside1LastX128_lte: BigInt
  feeGrowthInside1LastX128_not: BigInt
  feeGrowthInside1LastX128_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  or: [PositionSnapshot_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  position: String
  position_: Position_filter
  position_contains: String
  position_contains_nocase: String
  position_ends_with: String
  position_ends_with_nocase: String
  position_gt: String
  position_gte: String
  position_in: [String!]
  position_lt: String
  position_lte: String
  position_not: String
  position_not_contains: String
  position_not_contains_nocase: String
  position_not_ends_with: String
  position_not_ends_with_nocase: String
  position_not_in: [String!]
  position_not_starts_with: String
  position_not_starts_with_nocase: String
  position_starts_with: String
  position_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  withdrawnToken0: BigDecimal
  withdrawnToken0_gt: BigDecimal
  withdrawnToken0_gte: BigDecimal
  withdrawnToken0_in: [BigDecimal!]
  withdrawnToken0_lt: BigDecimal
  withdrawnToken0_lte: BigDecimal
  withdrawnToken0_not: BigDecimal
  withdrawnToken0_not_in: [BigDecimal!]
  withdrawnToken1: BigDecimal
  withdrawnToken1_gt: BigDecimal
  withdrawnToken1_gte: BigDecimal
  withdrawnToken1_in: [BigDecimal!]
  withdrawnToken1_lt: BigDecimal
  withdrawnToken1_lte: BigDecimal
  withdrawnToken1_not: BigDecimal
  withdrawnToken1_not_in: [BigDecimal!]
}

enum PositionSnapshot_orderBy {
  blockNumber
  collectedFeesToken0
  collectedFeesToken1
  depositedToken0
  depositedToken1
  feeGrowthInside0LastX128
  feeGrowthInside1LastX128
  id
  liquidity
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  position
  position__collectedFeesToken0
  position__collectedFeesToken1
  position__collectedToken0
  position__collectedToken1
  position__depositedToken0
  position__depositedToken1
  position__feeGrowthInside0LastX128
  position__feeGrowthInside1LastX128
  position__id
  position__liquidity
  position__owner
  position__token0Tvl
  position__token1Tvl
  position__withdrawnToken0
  position__withdrawnToken1
  timestamp
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
  withdrawnToken0
  withdrawnToken1
}

input Position_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Position_filter]
  collectedFeesToken0: BigDecimal
  collectedFeesToken0_gt: BigDecimal
  collectedFeesToken0_gte: BigDecimal
  collectedFeesToken0_in: [BigDecimal!]
  collectedFeesToken0_lt: BigDecimal
  collectedFeesToken0_lte: BigDecimal
  collectedFeesToken0_not: BigDecimal
  collectedFeesToken0_not_in: [BigDecimal!]
  collectedFeesToken1: BigDecimal
  collectedFeesToken1_gt: BigDecimal
  collectedFeesToken1_gte: BigDecimal
  collectedFeesToken1_in: [BigDecimal!]
  collectedFeesToken1_lt: BigDecimal
  collectedFeesToken1_lte: BigDecimal
  collectedFeesToken1_not: BigDecimal
  collectedFeesToken1_not_in: [BigDecimal!]
  collectedToken0: BigDecimal
  collectedToken0_gt: BigDecimal
  collectedToken0_gte: BigDecimal
  collectedToken0_in: [BigDecimal!]
  collectedToken0_lt: BigDecimal
  collectedToken0_lte: BigDecimal
  collectedToken0_not: BigDecimal
  collectedToken0_not_in: [BigDecimal!]
  collectedToken1: BigDecimal
  collectedToken1_gt: BigDecimal
  collectedToken1_gte: BigDecimal
  collectedToken1_in: [BigDecimal!]
  collectedToken1_lt: BigDecimal
  collectedToken1_lte: BigDecimal
  collectedToken1_not: BigDecimal
  collectedToken1_not_in: [BigDecimal!]
  depositedToken0: BigDecimal
  depositedToken0_gt: BigDecimal
  depositedToken0_gte: BigDecimal
  depositedToken0_in: [BigDecimal!]
  depositedToken0_lt: BigDecimal
  depositedToken0_lte: BigDecimal
  depositedToken0_not: BigDecimal
  depositedToken0_not_in: [BigDecimal!]
  depositedToken1: BigDecimal
  depositedToken1_gt: BigDecimal
  depositedToken1_gte: BigDecimal
  depositedToken1_in: [BigDecimal!]
  depositedToken1_lt: BigDecimal
  depositedToken1_lte: BigDecimal
  depositedToken1_not: BigDecimal
  depositedToken1_not_in: [BigDecimal!]
  feeGrowthInside0LastX128: BigInt
  feeGrowthInside0LastX128_gt: BigInt
  feeGrowthInside0LastX128_gte: BigInt
  feeGrowthInside0LastX128_in: [BigInt!]
  feeGrowthInside0LastX128_lt: BigInt
  feeGrowthInside0LastX128_lte: BigInt
  feeGrowthInside0LastX128_not: BigInt
  feeGrowthInside0LastX128_not_in: [BigInt!]
  feeGrowthInside1LastX128: BigInt
  feeGrowthInside1LastX128_gt: BigInt
  feeGrowthInside1LastX128_gte: BigInt
  feeGrowthInside1LastX128_in: [BigInt!]
  feeGrowthInside1LastX128_lt: BigInt
  feeGrowthInside1LastX128_lte: BigInt
  feeGrowthInside1LastX128_not: BigInt
  feeGrowthInside1LastX128_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  or: [Position_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tickLower: String
  tickLower_: Tick_filter
  tickLower_contains: String
  tickLower_contains_nocase: String
  tickLower_ends_with: String
  tickLower_ends_with_nocase: String
  tickLower_gt: String
  tickLower_gte: String
  tickLower_in: [String!]
  tickLower_lt: String
  tickLower_lte: String
  tickLower_not: String
  tickLower_not_contains: String
  tickLower_not_contains_nocase: String
  tickLower_not_ends_with: String
  tickLower_not_ends_with_nocase: String
  tickLower_not_in: [String!]
  tickLower_not_starts_with: String
  tickLower_not_starts_with_nocase: String
  tickLower_starts_with: String
  tickLower_starts_with_nocase: String
  tickUpper: String
  tickUpper_: Tick_filter
  tickUpper_contains: String
  tickUpper_contains_nocase: String
  tickUpper_ends_with: String
  tickUpper_ends_with_nocase: String
  tickUpper_gt: String
  tickUpper_gte: String
  tickUpper_in: [String!]
  tickUpper_lt: String
  tickUpper_lte: String
  tickUpper_not: String
  tickUpper_not_contains: String
  tickUpper_not_contains_nocase: String
  tickUpper_not_ends_with: String
  tickUpper_not_ends_with_nocase: String
  tickUpper_not_in: [String!]
  tickUpper_not_starts_with: String
  tickUpper_not_starts_with_nocase: String
  tickUpper_starts_with: String
  tickUpper_starts_with_nocase: String
  token0: String
  token0Tvl: BigDecimal
  token0Tvl_gt: BigDecimal
  token0Tvl_gte: BigDecimal
  token0Tvl_in: [BigDecimal!]
  token0Tvl_lt: BigDecimal
  token0Tvl_lte: BigDecimal
  token0Tvl_not: BigDecimal
  token0Tvl_not_in: [BigDecimal!]
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1Tvl: BigDecimal
  token1Tvl_gt: BigDecimal
  token1Tvl_gte: BigDecimal
  token1Tvl_in: [BigDecimal!]
  token1Tvl_lt: BigDecimal
  token1Tvl_lte: BigDecimal
  token1Tvl_not: BigDecimal
  token1Tvl_not_in: [BigDecimal!]
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  withdrawnToken0: BigDecimal
  withdrawnToken0_gt: BigDecimal
  withdrawnToken0_gte: BigDecimal
  withdrawnToken0_in: [BigDecimal!]
  withdrawnToken0_lt: BigDecimal
  withdrawnToken0_lte: BigDecimal
  withdrawnToken0_not: BigDecimal
  withdrawnToken0_not_in: [BigDecimal!]
  withdrawnToken1: BigDecimal
  withdrawnToken1_gt: BigDecimal
  withdrawnToken1_gte: BigDecimal
  withdrawnToken1_in: [BigDecimal!]
  withdrawnToken1_lt: BigDecimal
  withdrawnToken1_lte: BigDecimal
  withdrawnToken1_not: BigDecimal
  withdrawnToken1_not_in: [BigDecimal!]
}

enum Position_orderBy {
  collectedFeesToken0
  collectedFeesToken1
  collectedToken0
  collectedToken1
  depositedToken0
  depositedToken1
  feeGrowthInside0LastX128
  feeGrowthInside1LastX128
  id
  liquidity
  owner
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  tickLower
  tickLower__collectedFeesToken0
  tickLower__collectedFeesToken1
  tickLower__collectedFeesUSD
  tickLower__createdAtBlockNumber
  tickLower__createdAtTimestamp
  tickLower__feeGrowthOutside0X128
  tickLower__feeGrowthOutside1X128
  tickLower__feesUSD
  tickLower__id
  tickLower__liquidityGross
  tickLower__liquidityNet
  tickLower__liquidityProviderCount
  tickLower__poolAddress
  tickLower__price0
  tickLower__price1
  tickLower__tickIdx
  tickLower__untrackedVolumeUSD
  tickLower__volumeToken0
  tickLower__volumeToken1
  tickLower__volumeUSD
  tickUpper
  tickUpper__collectedFeesToken0
  tickUpper__collectedFeesToken1
  tickUpper__collectedFeesUSD
  tickUpper__createdAtBlockNumber
  tickUpper__createdAtTimestamp
  tickUpper__feeGrowthOutside0X128
  tickUpper__feeGrowthOutside1X128
  tickUpper__feesUSD
  tickUpper__id
  tickUpper__liquidityGross
  tickUpper__liquidityNet
  tickUpper__liquidityProviderCount
  tickUpper__poolAddress
  tickUpper__price0
  tickUpper__price1
  tickUpper__tickIdx
  tickUpper__untrackedVolumeUSD
  tickUpper__volumeToken0
  tickUpper__volumeToken1
  tickUpper__volumeUSD
  token0
  token0Tvl
  token0__decimals
  token0__derivedMatic
  token0__feesUSD
  token0__id
  token0__name
  token0__poolCount
  token0__symbol
  token0__totalSupply
  token0__totalValueLocked
  token0__totalValueLockedUSD
  token0__totalValueLockedUSDUntracked
  token0__txCount
  token0__untrackedVolumeUSD
  token0__volume
  token0__volumeUSD
  token1
  token1Tvl
  token1__decimals
  token1__derivedMatic
  token1__feesUSD
  token1__id
  token1__name
  token1__poolCount
  token1__symbol
  token1__totalSupply
  token1__totalValueLocked
  token1__totalValueLockedUSD
  token1__totalValueLockedUSDUntracked
  token1__txCount
  token1__untrackedVolumeUSD
  token1__volume
  token1__volumeUSD
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
  withdrawnToken0
  withdrawnToken1
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  algebraDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AlgebraDayData
  algebraDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AlgebraDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AlgebraDayData_filter
  ): [AlgebraDayData!]!
  bundle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bundle_filter
  ): [Bundle!]!
  burn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burn
  burns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burn_filter
  ): [Burn!]!
  collect(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collect
  collects(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Collect_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Collect_filter
  ): [Collect!]!
  factories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Factory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Factory_filter
  ): [Factory!]!
  factory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Factory
  feeHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeHourData
  feeHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeHourData_filter
  ): [FeeHourData!]!
  flash(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Flash
  flashes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Flash_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Flash_filter
  ): [Flash!]!
  mint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Mint
  mints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Mint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Mint_filter
  ): [Mint!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolDayData
  poolDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolDayData_filter
  ): [PoolDayData!]!
  poolFeeData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolFeeData
  poolFeeDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolFeeData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolFeeData_filter
  ): [PoolFeeData!]!
  poolHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHourData
  poolHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHourData_filter
  ): [PoolHourData!]!
  poolPosition(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolPosition
  poolPositions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolPosition_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolPosition_filter
  ): [PoolPosition!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  position(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positionSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionSnapshot
  positionSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PositionSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PositionSnapshot_filter
  ): [PositionSnapshot!]!
  positions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Position_filter
  ): [Position!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  tick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tick
  tickDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TickDayData
  tickDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TickDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TickDayData_filter
  ): [TickDayData!]!
  tickHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TickHourData
  tickHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TickHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TickHourData_filter
  ): [TickHourData!]!
  ticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Tick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Tick_filter
  ): [Tick!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDayData
  tokenDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenDayData_filter
  ): [TokenDayData!]!
  tokenHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenHourData
  tokenHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenHourData_filter
  ): [TokenHourData!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  algebraDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AlgebraDayData
  algebraDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AlgebraDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AlgebraDayData_filter
  ): [AlgebraDayData!]!
  bundle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bundle_filter
  ): [Bundle!]!
  burn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burn
  burns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burn_filter
  ): [Burn!]!
  collect(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collect
  collects(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Collect_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Collect_filter
  ): [Collect!]!
  factories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Factory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Factory_filter
  ): [Factory!]!
  factory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Factory
  feeHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeHourData
  feeHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeHourData_filter
  ): [FeeHourData!]!
  flash(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Flash
  flashes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Flash_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Flash_filter
  ): [Flash!]!
  mint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Mint
  mints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Mint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Mint_filter
  ): [Mint!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolDayData
  poolDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolDayData_filter
  ): [PoolDayData!]!
  poolFeeData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolFeeData
  poolFeeDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolFeeData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolFeeData_filter
  ): [PoolFeeData!]!
  poolHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHourData
  poolHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHourData_filter
  ): [PoolHourData!]!
  poolPosition(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolPosition
  poolPositions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolPosition_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolPosition_filter
  ): [PoolPosition!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  position(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positionSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionSnapshot
  positionSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PositionSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PositionSnapshot_filter
  ): [PositionSnapshot!]!
  positions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Position_filter
  ): [Position!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  tick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tick
  tickDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TickDayData
  tickDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TickDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TickDayData_filter
  ): [TickDayData!]!
  tickHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TickHourData
  tickHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TickHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TickHourData_filter
  ): [TickHourData!]!
  ticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Tick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Tick_filter
  ): [Tick!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDayData
  tokenDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenDayData_filter
  ): [TokenDayData!]!
  tokenHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenHourData
  tokenHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenHourData_filter
  ): [TokenHourData!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
}

type Swap {
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal!
  id: ID!
  liquidity: BigInt!
  logIndex: BigInt
  origin: Bytes!
  pool: Pool!
  price: BigInt!
  recipient: Bytes!
  sender: Bytes!
  tick: BigInt!
  timestamp: BigInt!
  token0: Token!
  token1: Token!
  transaction: Transaction!
}

input Swap_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Swap_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Swap_filter]
  origin: Bytes
  origin_contains: Bytes
  origin_gt: Bytes
  origin_gte: Bytes
  origin_in: [Bytes!]
  origin_lt: Bytes
  origin_lte: Bytes
  origin_not: Bytes
  origin_not_contains: Bytes
  origin_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  price: BigInt
  price_gt: BigInt
  price_gte: BigInt
  price_in: [BigInt!]
  price_lt: BigInt
  price_lte: BigInt
  price_not: BigInt
  price_not_in: [BigInt!]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  tick: BigInt
  tick_gt: BigInt
  tick_gte: BigInt
  tick_in: [BigInt!]
  tick_lt: BigInt
  tick_lte: BigInt
  tick_not: BigInt
  tick_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Swap_orderBy {
  amount0
  amount1
  amountUSD
  id
  liquidity
  logIndex
  origin
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  price
  recipient
  sender
  tick
  timestamp
  token0
  token0__decimals
  token0__derivedMatic
  token0__feesUSD
  token0__id
  token0__name
  token0__poolCount
  token0__symbol
  token0__totalSupply
  token0__totalValueLocked
  token0__totalValueLockedUSD
  token0__totalValueLockedUSDUntracked
  token0__txCount
  token0__untrackedVolumeUSD
  token0__volume
  token0__volumeUSD
  token1
  token1__decimals
  token1__derivedMatic
  token1__feesUSD
  token1__id
  token1__name
  token1__poolCount
  token1__symbol
  token1__totalSupply
  token1__totalValueLocked
  token1__totalValueLockedUSD
  token1__totalValueLockedUSDUntracked
  token1__txCount
  token1__untrackedVolumeUSD
  token1__volume
  token1__volumeUSD
  transaction
  transaction__blockNumber
  transaction__gasLimit
  transaction__gasPrice
  transaction__id
  transaction__timestamp
}

type Tick {
  collectedFeesToken0: BigDecimal!
  collectedFeesToken1: BigDecimal!
  collectedFeesUSD: BigDecimal!
  createdAtBlockNumber: BigInt!
  createdAtTimestamp: BigInt!
  feeGrowthOutside0X128: BigInt!
  feeGrowthOutside1X128: BigInt!
  feesUSD: BigDecimal!
  id: ID!
  liquidityGross: BigInt!
  liquidityNet: BigInt!
  liquidityProviderCount: BigInt!
  pool: Pool!
  poolAddress: String
  price0: BigDecimal!
  price1: BigDecimal!
  tickIdx: BigInt!
  untrackedVolumeUSD: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

type TickDayData {
  date: Int!
  feeGrowthOutside0X128: BigInt!
  feeGrowthOutside1X128: BigInt!
  feesUSD: BigDecimal!
  id: ID!
  liquidityGross: BigInt!
  liquidityNet: BigInt!
  pool: Pool!
  tick: Tick!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

input TickDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TickDayData_filter]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  feeGrowthOutside0X128: BigInt
  feeGrowthOutside0X128_gt: BigInt
  feeGrowthOutside0X128_gte: BigInt
  feeGrowthOutside0X128_in: [BigInt!]
  feeGrowthOutside0X128_lt: BigInt
  feeGrowthOutside0X128_lte: BigInt
  feeGrowthOutside0X128_not: BigInt
  feeGrowthOutside0X128_not_in: [BigInt!]
  feeGrowthOutside1X128: BigInt
  feeGrowthOutside1X128_gt: BigInt
  feeGrowthOutside1X128_gte: BigInt
  feeGrowthOutside1X128_in: [BigInt!]
  feeGrowthOutside1X128_lt: BigInt
  feeGrowthOutside1X128_lte: BigInt
  feeGrowthOutside1X128_not: BigInt
  feeGrowthOutside1X128_not_in: [BigInt!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityGross: BigInt
  liquidityGross_gt: BigInt
  liquidityGross_gte: BigInt
  liquidityGross_in: [BigInt!]
  liquidityGross_lt: BigInt
  liquidityGross_lte: BigInt
  liquidityGross_not: BigInt
  liquidityGross_not_in: [BigInt!]
  liquidityNet: BigInt
  liquidityNet_gt: BigInt
  liquidityNet_gte: BigInt
  liquidityNet_in: [BigInt!]
  liquidityNet_lt: BigInt
  liquidityNet_lte: BigInt
  liquidityNet_not: BigInt
  liquidityNet_not_in: [BigInt!]
  or: [TickDayData_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tick: String
  tick_: Tick_filter
  tick_contains: String
  tick_contains_nocase: String
  tick_ends_with: String
  tick_ends_with_nocase: String
  tick_gt: String
  tick_gte: String
  tick_in: [String!]
  tick_lt: String
  tick_lte: String
  tick_not: String
  tick_not_contains: String
  tick_not_contains_nocase: String
  tick_not_ends_with: String
  tick_not_ends_with_nocase: String
  tick_not_in: [String!]
  tick_not_starts_with: String
  tick_not_starts_with_nocase: String
  tick_starts_with: String
  tick_starts_with_nocase: String
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum TickDayData_orderBy {
  date
  feeGrowthOutside0X128
  feeGrowthOutside1X128
  feesUSD
  id
  liquidityGross
  liquidityNet
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  tick
  tick__collectedFeesToken0
  tick__collectedFeesToken1
  tick__collectedFeesUSD
  tick__createdAtBlockNumber
  tick__createdAtTimestamp
  tick__feeGrowthOutside0X128
  tick__feeGrowthOutside1X128
  tick__feesUSD
  tick__id
  tick__liquidityGross
  tick__liquidityNet
  tick__liquidityProviderCount
  tick__poolAddress
  tick__price0
  tick__price1
  tick__tickIdx
  tick__untrackedVolumeUSD
  tick__volumeToken0
  tick__volumeToken1
  tick__volumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type TickHourData {
  feesUSD: BigDecimal!
  id: ID!
  liquidityGross: BigInt!
  liquidityNet: BigInt!
  periodStartUnix: Int!
  pool: Pool!
  tick: Tick!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

input TickHourData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TickHourData_filter]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityGross: BigInt
  liquidityGross_gt: BigInt
  liquidityGross_gte: BigInt
  liquidityGross_in: [BigInt!]
  liquidityGross_lt: BigInt
  liquidityGross_lte: BigInt
  liquidityGross_not: BigInt
  liquidityGross_not_in: [BigInt!]
  liquidityNet: BigInt
  liquidityNet_gt: BigInt
  liquidityNet_gte: BigInt
  liquidityNet_in: [BigInt!]
  liquidityNet_lt: BigInt
  liquidityNet_lte: BigInt
  liquidityNet_not: BigInt
  liquidityNet_not_in: [BigInt!]
  or: [TickHourData_filter]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tick: String
  tick_: Tick_filter
  tick_contains: String
  tick_contains_nocase: String
  tick_ends_with: String
  tick_ends_with_nocase: String
  tick_gt: String
  tick_gte: String
  tick_in: [String!]
  tick_lt: String
  tick_lte: String
  tick_not: String
  tick_not_contains: String
  tick_not_contains_nocase: String
  tick_not_ends_with: String
  tick_not_ends_with_nocase: String
  tick_not_in: [String!]
  tick_not_starts_with: String
  tick_not_starts_with_nocase: String
  tick_starts_with: String
  tick_starts_with_nocase: String
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum TickHourData_orderBy {
  feesUSD
  id
  liquidityGross
  liquidityNet
  periodStartUnix
  pool
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  tick
  tick__collectedFeesToken0
  tick__collectedFeesToken1
  tick__collectedFeesUSD
  tick__createdAtBlockNumber
  tick__createdAtTimestamp
  tick__feeGrowthOutside0X128
  tick__feeGrowthOutside1X128
  tick__feesUSD
  tick__id
  tick__liquidityGross
  tick__liquidityNet
  tick__liquidityProviderCount
  tick__poolAddress
  tick__price0
  tick__price1
  tick__tickIdx
  tick__untrackedVolumeUSD
  tick__volumeToken0
  tick__volumeToken1
  tick__volumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

input Tick_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Tick_filter]
  collectedFeesToken0: BigDecimal
  collectedFeesToken0_gt: BigDecimal
  collectedFeesToken0_gte: BigDecimal
  collectedFeesToken0_in: [BigDecimal!]
  collectedFeesToken0_lt: BigDecimal
  collectedFeesToken0_lte: BigDecimal
  collectedFeesToken0_not: BigDecimal
  collectedFeesToken0_not_in: [BigDecimal!]
  collectedFeesToken1: BigDecimal
  collectedFeesToken1_gt: BigDecimal
  collectedFeesToken1_gte: BigDecimal
  collectedFeesToken1_in: [BigDecimal!]
  collectedFeesToken1_lt: BigDecimal
  collectedFeesToken1_lte: BigDecimal
  collectedFeesToken1_not: BigDecimal
  collectedFeesToken1_not_in: [BigDecimal!]
  collectedFeesUSD: BigDecimal
  collectedFeesUSD_gt: BigDecimal
  collectedFeesUSD_gte: BigDecimal
  collectedFeesUSD_in: [BigDecimal!]
  collectedFeesUSD_lt: BigDecimal
  collectedFeesUSD_lte: BigDecimal
  collectedFeesUSD_not: BigDecimal
  collectedFeesUSD_not_in: [BigDecimal!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_not_in: [BigInt!]
  feeGrowthOutside0X128: BigInt
  feeGrowthOutside0X128_gt: BigInt
  feeGrowthOutside0X128_gte: BigInt
  feeGrowthOutside0X128_in: [BigInt!]
  feeGrowthOutside0X128_lt: BigInt
  feeGrowthOutside0X128_lte: BigInt
  feeGrowthOutside0X128_not: BigInt
  feeGrowthOutside0X128_not_in: [BigInt!]
  feeGrowthOutside1X128: BigInt
  feeGrowthOutside1X128_gt: BigInt
  feeGrowthOutside1X128_gte: BigInt
  feeGrowthOutside1X128_in: [BigInt!]
  feeGrowthOutside1X128_lt: BigInt
  feeGrowthOutside1X128_lte: BigInt
  feeGrowthOutside1X128_not: BigInt
  feeGrowthOutside1X128_not_in: [BigInt!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityGross: BigInt
  liquidityGross_gt: BigInt
  liquidityGross_gte: BigInt
  liquidityGross_in: [BigInt!]
  liquidityGross_lt: BigInt
  liquidityGross_lte: BigInt
  liquidityGross_not: BigInt
  liquidityGross_not_in: [BigInt!]
  liquidityNet: BigInt
  liquidityNet_gt: BigInt
  liquidityNet_gte: BigInt
  liquidityNet_in: [BigInt!]
  liquidityNet_lt: BigInt
  liquidityNet_lte: BigInt
  liquidityNet_not: BigInt
  liquidityNet_not_in: [BigInt!]
  liquidityProviderCount: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_not_in: [BigInt!]
  or: [Tick_filter]
  pool: String
  poolAddress: String
  poolAddress_contains: String
  poolAddress_contains_nocase: String
  poolAddress_ends_with: String
  poolAddress_ends_with_nocase: String
  poolAddress_gt: String
  poolAddress_gte: String
  poolAddress_in: [String!]
  poolAddress_lt: String
  poolAddress_lte: String
  poolAddress_not: String
  poolAddress_not_contains: String
  poolAddress_not_contains_nocase: String
  poolAddress_not_ends_with: String
  poolAddress_not_ends_with_nocase: String
  poolAddress_not_in: [String!]
  poolAddress_not_starts_with: String
  poolAddress_not_starts_with_nocase: String
  poolAddress_starts_with: String
  poolAddress_starts_with_nocase: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  price0: BigDecimal
  price0_gt: BigDecimal
  price0_gte: BigDecimal
  price0_in: [BigDecimal!]
  price0_lt: BigDecimal
  price0_lte: BigDecimal
  price0_not: BigDecimal
  price0_not_in: [BigDecimal!]
  price1: BigDecimal
  price1_gt: BigDecimal
  price1_gte: BigDecimal
  price1_in: [BigDecimal!]
  price1_lt: BigDecimal
  price1_lte: BigDecimal
  price1_not: BigDecimal
  price1_not_in: [BigDecimal!]
  tickIdx: BigInt
  tickIdx_gt: BigInt
  tickIdx_gte: BigInt
  tickIdx_in: [BigInt!]
  tickIdx_lt: BigInt
  tickIdx_lte: BigInt
  tickIdx_not: BigInt
  tickIdx_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum Tick_orderBy {
  collectedFeesToken0
  collectedFeesToken1
  collectedFeesUSD
  createdAtBlockNumber
  createdAtTimestamp
  feeGrowthOutside0X128
  feeGrowthOutside1X128
  feesUSD
  id
  liquidityGross
  liquidityNet
  liquidityProviderCount
  pool
  poolAddress
  pool__collectedFeesToken0
  pool__collectedFeesToken1
  pool__collectedFeesUSD
  pool__communityFee
  pool__createdAtBlockNumber
  pool__createdAtTimestamp
  pool__fee
  pool__feeGrowthGlobal0X128
  pool__feeGrowthGlobal1X128
  pool__feesToken0
  pool__feesToken1
  pool__feesUSD
  pool__id
  pool__liquidity
  pool__liquidityProviderCount
  pool__observationIndex
  pool__sqrtPrice
  pool__tick
  pool__tickSpacing
  pool__token0Price
  pool__token1Price
  pool__totalValueLockedMatic
  pool__totalValueLockedToken0
  pool__totalValueLockedToken1
  pool__totalValueLockedUSD
  pool__totalValueLockedUSDUntracked
  pool__txCount
  pool__untrackedFeesUSD
  pool__untrackedVolumeUSD
  pool__volumeToken0
  pool__volumeToken1
  pool__volumeUSD
  price0
  price1
  tickIdx
  untrackedVolumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type Token {
  decimals: BigInt!
  derivedMatic: BigDecimal!
  feesUSD: BigDecimal!
  id: ID!
  name: String!
  poolCount: BigInt!
  symbol: String!
  tokenDayData(first: Int = 100, orderBy: TokenDayData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenDayData_filter): [TokenDayData!]!
  totalSupply: BigInt!
  totalValueLocked: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  totalValueLockedUSDUntracked: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
  volume: BigDecimal!
  volumeUSD: BigDecimal!
  whitelistPools(first: Int = 100, orderBy: Pool_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Pool_filter): [Pool!]!
}

type TokenDayData {
  close: BigDecimal!
  date: Int!
  feesUSD: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal!
  priceUSD: BigDecimal!
  token: Token!
  totalValueLocked: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  volume: BigDecimal!
  volumeUSD: BigDecimal!
}

input TokenDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenDayData_filter]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [TokenDayData_filter]
  priceUSD: BigDecimal
  priceUSD_gt: BigDecimal
  priceUSD_gte: BigDecimal
  priceUSD_in: [BigDecimal!]
  priceUSD_lt: BigDecimal
  priceUSD_lte: BigDecimal
  priceUSD_not: BigDecimal
  priceUSD_not_in: [BigDecimal!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalValueLocked: BigDecimal
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_not_in: [BigDecimal!]
  totalValueLocked_gt: BigDecimal
  totalValueLocked_gte: BigDecimal
  totalValueLocked_in: [BigDecimal!]
  totalValueLocked_lt: BigDecimal
  totalValueLocked_lte: BigDecimal
  totalValueLocked_not: BigDecimal
  totalValueLocked_not_in: [BigDecimal!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volume: BigDecimal
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}

enum TokenDayData_orderBy {
  close
  date
  feesUSD
  high
  id
  low
  open
  priceUSD
  token
  token__decimals
  token__derivedMatic
  token__feesUSD
  token__id
  token__name
  token__poolCount
  token__symbol
  token__totalSupply
  token__totalValueLocked
  token__totalValueLockedUSD
  token__totalValueLockedUSDUntracked
  token__txCount
  token__untrackedVolumeUSD
  token__volume
  token__volumeUSD
  totalValueLocked
  totalValueLockedUSD
  untrackedVolumeUSD
  volume
  volumeUSD
}

type TokenHourData {
  close: BigDecimal!
  feesUSD: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal!
  periodStartUnix: Int!
  priceUSD: BigDecimal!
  token: Token!
  totalValueLocked: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  volume: BigDecimal!
  volumeUSD: BigDecimal!
}

input TokenHourData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenHourData_filter]
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  or: [TokenHourData_filter]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  priceUSD: BigDecimal
  priceUSD_gt: BigDecimal
  priceUSD_gte: BigDecimal
  priceUSD_in: [BigDecimal!]
  priceUSD_lt: BigDecimal
  priceUSD_lte: BigDecimal
  priceUSD_not: BigDecimal
  priceUSD_not_in: [BigDecimal!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalValueLocked: BigDecimal
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_not_in: [BigDecimal!]
  totalValueLocked_gt: BigDecimal
  totalValueLocked_gte: BigDecimal
  totalValueLocked_in: [BigDecimal!]
  totalValueLocked_lt: BigDecimal
  totalValueLocked_lte: BigDecimal
  totalValueLocked_not: BigDecimal
  totalValueLocked_not_in: [BigDecimal!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volume: BigDecimal
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
}

enum TokenHourData_orderBy {
  close
  feesUSD
  high
  id
  low
  open
  periodStartUnix
  priceUSD
  token
  token__decimals
  token__derivedMatic
  token__feesUSD
  token__id
  token__name
  token__poolCount
  token__symbol
  token__totalSupply
  token__totalValueLocked
  token__totalValueLockedUSD
  token__totalValueLockedUSDUntracked
  token__txCount
  token__untrackedVolumeUSD
  token__volume
  token__volumeUSD
  totalValueLocked
  totalValueLockedUSD
  untrackedVolumeUSD
  volume
  volumeUSD
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  derivedMatic: BigDecimal
  derivedMatic_gt: BigDecimal
  derivedMatic_gte: BigDecimal
  derivedMatic_in: [BigDecimal!]
  derivedMatic_lt: BigDecimal
  derivedMatic_lte: BigDecimal
  derivedMatic_not: BigDecimal
  derivedMatic_not_in: [BigDecimal!]
  feesUSD: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_lt: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Token_filter]
  poolCount: BigInt
  poolCount_gt: BigInt
  poolCount_gte: BigInt
  poolCount_in: [BigInt!]
  poolCount_lt: BigInt
  poolCount_lte: BigInt
  poolCount_not: BigInt
  poolCount_not_in: [BigInt!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tokenDayData_: TokenDayData_filter
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  totalValueLocked: BigDecimal
  totalValueLockedUSD: BigDecimal
  totalValueLockedUSDUntracked: BigDecimal
  totalValueLockedUSDUntracked_gt: BigDecimal
  totalValueLockedUSDUntracked_gte: BigDecimal
  totalValueLockedUSDUntracked_in: [BigDecimal!]
  totalValueLockedUSDUntracked_lt: BigDecimal
  totalValueLockedUSDUntracked_lte: BigDecimal
  totalValueLockedUSDUntracked_not: BigDecimal
  totalValueLockedUSDUntracked_not_in: [BigDecimal!]
  totalValueLockedUSD_gt: BigDecimal
  totalValueLockedUSD_gte: BigDecimal
  totalValueLockedUSD_in: [BigDecimal!]
  totalValueLockedUSD_lt: BigDecimal
  totalValueLockedUSD_lte: BigDecimal
  totalValueLockedUSD_not: BigDecimal
  totalValueLockedUSD_not_in: [BigDecimal!]
  totalValueLocked_gt: BigDecimal
  totalValueLocked_gte: BigDecimal
  totalValueLocked_in: [BigDecimal!]
  totalValueLocked_lt: BigDecimal
  totalValueLocked_lte: BigDecimal
  totalValueLocked_not: BigDecimal
  totalValueLocked_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volume: BigDecimal
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
  volume_gt: BigDecimal
  volume_gte: BigDecimal
  volume_in: [BigDecimal!]
  volume_lt: BigDecimal
  volume_lte: BigDecimal
  volume_not: BigDecimal
  volume_not_in: [BigDecimal!]
  whitelistPools: [String!]
  whitelistPools_: Pool_filter
  whitelistPools_contains: [String!]
  whitelistPools_contains_nocase: [String!]
  whitelistPools_not: [String!]
  whitelistPools_not_contains: [String!]
  whitelistPools_not_contains_nocase: [String!]
}

enum Token_orderBy {
  decimals
  derivedMatic
  feesUSD
  id
  name
  poolCount
  symbol
  tokenDayData
  totalSupply
  totalValueLocked
  totalValueLockedUSD
  totalValueLockedUSDUntracked
  txCount
  untrackedVolumeUSD
  volume
  volumeUSD
  whitelistPools
}

type Transaction {
  blockNumber: BigInt!
  burns(first: Int = 100, orderBy: Burn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Burn_filter): [Burn!]!
  collects(first: Int = 100, orderBy: Collect_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Collect_filter): [Collect!]!
  flashed(first: Int = 100, orderBy: Flash_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Flash_filter): [Flash!]!
  gasLimit: BigInt!
  gasPrice: BigInt!
  id: ID!
  mints(first: Int = 100, orderBy: Mint_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Mint_filter): [Mint!]!
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]!
  timestamp: BigInt!
}

input Transaction_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  burns_: Burn_filter
  collects_: Collect_filter
  flashed_: Flash_filter
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  mints_: Mint_filter
  or: [Transaction_filter]
  swaps_: Swap_filter
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  burns
  collects
  flashed
  gasLimit
  gasPrice
  id
  mints
  swaps
  timestamp
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}


================================================
File: src/graphql/schemas/blocklytics.graphql
================================================
"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

type Block {
  author: String
  difficulty: BigInt
  gasLimit: BigInt
  gasUsed: BigInt
  id: ID!
  number: BigInt!
  parentHash: String
  receiptsRoot: String
  size: BigInt
  stateRoot: String
  timestamp: BigInt!
  totalDifficulty: BigInt
  transactionsRoot: String
  unclesHash: String
}

input BlockChangedFilter {
  number_gte: Int!
}

input Block_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Block_filter]
  author: String
  author_contains: String
  author_contains_nocase: String
  author_ends_with: String
  author_ends_with_nocase: String
  author_gt: String
  author_gte: String
  author_in: [String!]
  author_lt: String
  author_lte: String
  author_not: String
  author_not_contains: String
  author_not_contains_nocase: String
  author_not_ends_with: String
  author_not_ends_with_nocase: String
  author_not_in: [String!]
  author_not_starts_with: String
  author_not_starts_with_nocase: String
  author_starts_with: String
  author_starts_with_nocase: String
  difficulty: BigInt
  difficulty_gt: BigInt
  difficulty_gte: BigInt
  difficulty_in: [BigInt!]
  difficulty_lt: BigInt
  difficulty_lte: BigInt
  difficulty_not: BigInt
  difficulty_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_gt: BigInt
  gasUsed_gte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_lt: BigInt
  gasUsed_lte: BigInt
  gasUsed_not: BigInt
  gasUsed_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  number: BigInt
  number_gt: BigInt
  number_gte: BigInt
  number_in: [BigInt!]
  number_lt: BigInt
  number_lte: BigInt
  number_not: BigInt
  number_not_in: [BigInt!]
  or: [Block_filter]
  parentHash: String
  parentHash_contains: String
  parentHash_contains_nocase: String
  parentHash_ends_with: String
  parentHash_ends_with_nocase: String
  parentHash_gt: String
  parentHash_gte: String
  parentHash_in: [String!]
  parentHash_lt: String
  parentHash_lte: String
  parentHash_not: String
  parentHash_not_contains: String
  parentHash_not_contains_nocase: String
  parentHash_not_ends_with: String
  parentHash_not_ends_with_nocase: String
  parentHash_not_in: [String!]
  parentHash_not_starts_with: String
  parentHash_not_starts_with_nocase: String
  parentHash_starts_with: String
  parentHash_starts_with_nocase: String
  receiptsRoot: String
  receiptsRoot_contains: String
  receiptsRoot_contains_nocase: String
  receiptsRoot_ends_with: String
  receiptsRoot_ends_with_nocase: String
  receiptsRoot_gt: String
  receiptsRoot_gte: String
  receiptsRoot_in: [String!]
  receiptsRoot_lt: String
  receiptsRoot_lte: String
  receiptsRoot_not: String
  receiptsRoot_not_contains: String
  receiptsRoot_not_contains_nocase: String
  receiptsRoot_not_ends_with: String
  receiptsRoot_not_ends_with_nocase: String
  receiptsRoot_not_in: [String!]
  receiptsRoot_not_starts_with: String
  receiptsRoot_not_starts_with_nocase: String
  receiptsRoot_starts_with: String
  receiptsRoot_starts_with_nocase: String
  size: BigInt
  size_gt: BigInt
  size_gte: BigInt
  size_in: [BigInt!]
  size_lt: BigInt
  size_lte: BigInt
  size_not: BigInt
  size_not_in: [BigInt!]
  stateRoot: String
  stateRoot_contains: String
  stateRoot_contains_nocase: String
  stateRoot_ends_with: String
  stateRoot_ends_with_nocase: String
  stateRoot_gt: String
  stateRoot_gte: String
  stateRoot_in: [String!]
  stateRoot_lt: String
  stateRoot_lte: String
  stateRoot_not: String
  stateRoot_not_contains: String
  stateRoot_not_contains_nocase: String
  stateRoot_not_ends_with: String
  stateRoot_not_ends_with_nocase: String
  stateRoot_not_in: [String!]
  stateRoot_not_starts_with: String
  stateRoot_not_starts_with_nocase: String
  stateRoot_starts_with: String
  stateRoot_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalDifficulty: BigInt
  totalDifficulty_gt: BigInt
  totalDifficulty_gte: BigInt
  totalDifficulty_in: [BigInt!]
  totalDifficulty_lt: BigInt
  totalDifficulty_lte: BigInt
  totalDifficulty_not: BigInt
  totalDifficulty_not_in: [BigInt!]
  transactionsRoot: String
  transactionsRoot_contains: String
  transactionsRoot_contains_nocase: String
  transactionsRoot_ends_with: String
  transactionsRoot_ends_with_nocase: String
  transactionsRoot_gt: String
  transactionsRoot_gte: String
  transactionsRoot_in: [String!]
  transactionsRoot_lt: String
  transactionsRoot_lte: String
  transactionsRoot_not: String
  transactionsRoot_not_contains: String
  transactionsRoot_not_contains_nocase: String
  transactionsRoot_not_ends_with: String
  transactionsRoot_not_ends_with_nocase: String
  transactionsRoot_not_in: [String!]
  transactionsRoot_not_starts_with: String
  transactionsRoot_not_starts_with_nocase: String
  transactionsRoot_starts_with: String
  transactionsRoot_starts_with_nocase: String
  unclesHash: String
  unclesHash_contains: String
  unclesHash_contains_nocase: String
  unclesHash_ends_with: String
  unclesHash_ends_with_nocase: String
  unclesHash_gt: String
  unclesHash_gte: String
  unclesHash_in: [String!]
  unclesHash_lt: String
  unclesHash_lte: String
  unclesHash_not: String
  unclesHash_not_contains: String
  unclesHash_not_contains_nocase: String
  unclesHash_not_ends_with: String
  unclesHash_not_ends_with_nocase: String
  unclesHash_not_in: [String!]
  unclesHash_not_starts_with: String
  unclesHash_not_starts_with_nocase: String
  unclesHash_starts_with: String
  unclesHash_starts_with_nocase: String
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

enum Block_orderBy {
  author
  difficulty
  gasLimit
  gasUsed
  id
  number
  parentHash
  receiptsRoot
  size
  stateRoot
  timestamp
  totalDifficulty
  transactionsRoot
  unclesHash
}

scalar Bytes

"8 bytes signed integer\n"
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  block(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Block
  blocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Block_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Block_filter
  ): [Block!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  block(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Block
  blocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Block_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Block_filter
  ): [Block!]!
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}


================================================
File: src/graphql/schemas/farming.graphql
================================================
"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Deposit {
  eternalFarming: Bytes
  id: ID!
  liquidity: BigInt!
  owner: Bytes!
  pool: Bytes!
  rangeLength: BigInt!
}

input Deposit_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Deposit_filter]
  eternalFarming: Bytes
  eternalFarming_contains: Bytes
  eternalFarming_gt: Bytes
  eternalFarming_gte: Bytes
  eternalFarming_in: [Bytes!]
  eternalFarming_lt: Bytes
  eternalFarming_lte: Bytes
  eternalFarming_not: Bytes
  eternalFarming_not_contains: Bytes
  eternalFarming_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigInt
  liquidity_gt: BigInt
  liquidity_gte: BigInt
  liquidity_in: [BigInt!]
  liquidity_lt: BigInt
  liquidity_lte: BigInt
  liquidity_not: BigInt
  liquidity_not_in: [BigInt!]
  or: [Deposit_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  pool: Bytes
  pool_contains: Bytes
  pool_gt: Bytes
  pool_gte: Bytes
  pool_in: [Bytes!]
  pool_lt: Bytes
  pool_lte: Bytes
  pool_not: Bytes
  pool_not_contains: Bytes
  pool_not_in: [Bytes!]
  rangeLength: BigInt
  rangeLength_gt: BigInt
  rangeLength_gte: BigInt
  rangeLength_in: [BigInt!]
  rangeLength_lt: BigInt
  rangeLength_lte: BigInt
  rangeLength_not: BigInt
  rangeLength_not_in: [BigInt!]
}

enum Deposit_orderBy {
  eternalFarming
  id
  liquidity
  owner
  pool
  rangeLength
}

type EternalFarming {
  bonusReward: BigInt!
  bonusRewardRate: BigInt!
  bonusRewardToken: Bytes!
  id: ID!
  isDeactivated: Boolean
  minRangeLength: BigInt!
  nonce: BigInt!
  pool: Bytes!
  reward: BigInt!
  rewardRate: BigInt!
  rewardToken: Bytes!
  virtualPool: Bytes!
}

input EternalFarming_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [EternalFarming_filter]
  bonusReward: BigInt
  bonusRewardRate: BigInt
  bonusRewardRate_gt: BigInt
  bonusRewardRate_gte: BigInt
  bonusRewardRate_in: [BigInt!]
  bonusRewardRate_lt: BigInt
  bonusRewardRate_lte: BigInt
  bonusRewardRate_not: BigInt
  bonusRewardRate_not_in: [BigInt!]
  bonusRewardToken: Bytes
  bonusRewardToken_contains: Bytes
  bonusRewardToken_gt: Bytes
  bonusRewardToken_gte: Bytes
  bonusRewardToken_in: [Bytes!]
  bonusRewardToken_lt: Bytes
  bonusRewardToken_lte: Bytes
  bonusRewardToken_not: Bytes
  bonusRewardToken_not_contains: Bytes
  bonusRewardToken_not_in: [Bytes!]
  bonusReward_gt: BigInt
  bonusReward_gte: BigInt
  bonusReward_in: [BigInt!]
  bonusReward_lt: BigInt
  bonusReward_lte: BigInt
  bonusReward_not: BigInt
  bonusReward_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isDeactivated: Boolean
  isDeactivated_in: [Boolean!]
  isDeactivated_not: Boolean
  isDeactivated_not_in: [Boolean!]
  minRangeLength: BigInt
  minRangeLength_gt: BigInt
  minRangeLength_gte: BigInt
  minRangeLength_in: [BigInt!]
  minRangeLength_lt: BigInt
  minRangeLength_lte: BigInt
  minRangeLength_not: BigInt
  minRangeLength_not_in: [BigInt!]
  nonce: BigInt
  nonce_gt: BigInt
  nonce_gte: BigInt
  nonce_in: [BigInt!]
  nonce_lt: BigInt
  nonce_lte: BigInt
  nonce_not: BigInt
  nonce_not_in: [BigInt!]
  or: [EternalFarming_filter]
  pool: Bytes
  pool_contains: Bytes
  pool_gt: Bytes
  pool_gte: Bytes
  pool_in: [Bytes!]
  pool_lt: Bytes
  pool_lte: Bytes
  pool_not: Bytes
  pool_not_contains: Bytes
  pool_not_in: [Bytes!]
  reward: BigInt
  rewardRate: BigInt
  rewardRate_gt: BigInt
  rewardRate_gte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_lt: BigInt
  rewardRate_lte: BigInt
  rewardRate_not: BigInt
  rewardRate_not_in: [BigInt!]
  rewardToken: Bytes
  rewardToken_contains: Bytes
  rewardToken_gt: Bytes
  rewardToken_gte: Bytes
  rewardToken_in: [Bytes!]
  rewardToken_lt: Bytes
  rewardToken_lte: Bytes
  rewardToken_not: Bytes
  rewardToken_not_contains: Bytes
  rewardToken_not_in: [Bytes!]
  reward_gt: BigInt
  reward_gte: BigInt
  reward_in: [BigInt!]
  reward_lt: BigInt
  reward_lte: BigInt
  reward_not: BigInt
  reward_not_in: [BigInt!]
  virtualPool: Bytes
  virtualPool_contains: Bytes
  virtualPool_gt: Bytes
  virtualPool_gte: Bytes
  virtualPool_in: [Bytes!]
  virtualPool_lt: Bytes
  virtualPool_lte: Bytes
  virtualPool_not: Bytes
  virtualPool_not_contains: Bytes
  virtualPool_not_in: [Bytes!]
}

enum EternalFarming_orderBy {
  bonusReward
  bonusRewardRate
  bonusRewardToken
  id
  isDeactivated
  minRangeLength
  nonce
  pool
  reward
  rewardRate
  rewardToken
  virtualPool
}

"8 bytes signed integer\n"
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  eternalFarming(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EternalFarming
  eternalFarmings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EternalFarming_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EternalFarming_filter
  ): [EternalFarming!]!
  reward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Reward
  rewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Reward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Reward_filter
  ): [Reward!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
}

type Reward {
  amount: BigInt!
  id: ID!
  owner: Bytes!
  rewardAddress: Bytes!
}

input Reward_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [Reward_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Reward_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  rewardAddress: Bytes
  rewardAddress_contains: Bytes
  rewardAddress_gt: Bytes
  rewardAddress_gte: Bytes
  rewardAddress_in: [Bytes!]
  rewardAddress_lt: Bytes
  rewardAddress_lte: Bytes
  rewardAddress_not: Bytes
  rewardAddress_not_contains: Bytes
  rewardAddress_not_in: [Bytes!]
}

enum Reward_orderBy {
  amount
  id
  owner
  rewardAddress
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  eternalFarming(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EternalFarming
  eternalFarmings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: EternalFarming_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: EternalFarming_filter
  ): [EternalFarming!]!
  reward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Reward
  rewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Reward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Reward_filter
  ): [Reward!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
}

type Token {
  decimals: BigInt!
  id: ID!
  name: String!
  symbol: String!
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Token_filter]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
}

enum Token_orderBy {
  decimals
  id
  name
  symbol
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}


================================================
File: src/graphql/utils/getBlocksFromTimestamps.ts
================================================
import { ApolloClient, NormalizedCacheObject } from "@apollo/client"
import { splitQuery } from "./splitQuery"
import { GET_BLOCKS } from "../queries/blocks"

export async function getBlocksFromTimestamps(
    timestamps: number[],
    blockClient: ApolloClient<NormalizedCacheObject>,
    skipCount = 500
) {
    if (timestamps?.length === 0) {
        return []
    }
    const fetchedData: any = await splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount)

    const blocks: any[] = []
    if (fetchedData) {
        for (const t in fetchedData) {
            if (fetchedData[t].length > 0) {
                blocks.push({
                    timestamp: t.split('t')[1],
                    number: fetchedData[t][0]['number']
                })
            }
        }
    }
    return blocks
}


================================================
File: src/graphql/utils/splitQuery.ts
================================================
import { ApolloClient, NormalizedCacheObject } from '@apollo/client'
import dayjs from 'dayjs'

/**
 * Used to get large amounts of data when
 * @param query
 * @param localClient
 * @param vars - any variables that are passed in every query
 * @param values - the keys that are used as the values to map over if
 * @param skipCount - amount of entities to skip per query
 */
export async function splitQuery<T>(
    query: any,
    client: ApolloClient<NormalizedCacheObject>,
    vars: any[],
    values: any[],
    skipCount = 1000
) {
    let fetchedData: { [key: string]: T } = {}
    let allFound = false
    let skip = 0
    try {
        while (!allFound) {
            let end = values.length
            if (skip + skipCount < values.length) {
                end = skip + skipCount
            }
            const sliced = values.slice(skip, end)
            const result = await client.query<any>({
                query: query(...vars, sliced),
                fetchPolicy: 'network-only'
            })
            fetchedData = {
                ...fetchedData,
                ...result.data
            }
            if (Object.keys(result.data).length < skipCount || skip + skipCount > values.length) {
                allFound = true
            } else {
                skip += skipCount
            }
        }
        return fetchedData
    } catch (e) {
        console.log(e)
        return undefined
    }
}

export function useDeltaTimestamps(): [number, number, number, number] {
    const utcCurrentTime = dayjs()
    const t1 = utcCurrentTime.subtract(1, 'day').startOf('minute').unix()
    const t2 = utcCurrentTime.subtract(2, 'day').startOf('minute').unix()
    const tWeek = utcCurrentTime.subtract(1, 'week').startOf('minute').unix()
    const tMonth = utcCurrentTime.subtract(1, 'month').startOf('minute').unix()
    return [t1, t2, tWeek, tMonth]
}



================================================
File: src/hooks/common/useAlgebraToken.ts
================================================
import { useMemo } from "react";
import { Address, useToken } from "wagmi";
import { Token } from "@glyph-exchange/integral-sdk";
import { ExtendedNative } from "@glyph-exchange/integral-sdk";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import {
    DEFAULT_CHAIN_ID,
    DEFAULT_NATIVE_NAME,
    DEFAULT_NATIVE_SYMBOL,
} from "@/constants/default-chain-id";

export function useAlgebraToken(address: Address | undefined) {
    const isETH = address === ADDRESS_ZERO;

    const { data: tokenData, isLoading } = useToken({
        address: isETH ? undefined : address,
        chainId: DEFAULT_CHAIN_ID,
    });

    return useMemo(() => {
        if (!address) return;

        if (address === ADDRESS_ZERO)
            return ExtendedNative.onChain(
                DEFAULT_CHAIN_ID,
                DEFAULT_NATIVE_SYMBOL,
                DEFAULT_NATIVE_NAME,
            );

        if (isLoading || !tokenData) return undefined;

        const { symbol, name, decimals } = tokenData;
        // console.log(tokenData, "tokenData");

        return new Token(DEFAULT_CHAIN_ID, address, decimals, symbol, name);
    }, [address, tokenData, isLoading]);
}



================================================
File: src/hooks/common/useApprove.ts
================================================
import { formatBalance } from "@/utils/common/formatBalance";
import { Currency, CurrencyAmount, Percent, Trade, TradeType } from "@glyph-exchange/integral-sdk";
import { useNeedAllowance } from "./useNeedAllowance";
import { ApprovalState, ApprovalStateType } from "@/types/approve-state";
import { useMemo } from "react";
import { Address, erc20ABI, useContractWrite, usePrepareContractWrite } from "wagmi";
import { ALGEBRA_ROUTER } from "@/constants/addresses";
import { useTransactionAwait } from "./useTransactionAwait";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { parseUnits } from "viem";
import { useMintState } from "@/state/mintStore";
import { PositionManager } from "@/types/position-state";

export function useApprove(
    amountToApprove: CurrencyAmount<Currency> | undefined,
    spender: Address,
) {
    const positionManager = useMintState((state) => state.positionManager);
    const token =
        positionManager === PositionManager.GAMMA
            ? amountToApprove?.currency
            : amountToApprove?.currency?.isToken
              ? amountToApprove.currency
              : undefined;

    const needAllowance = useNeedAllowance(token, amountToApprove, spender);

    const approvalState: ApprovalStateType = useMemo(() => {
        if (!amountToApprove || !spender) return ApprovalState.UNKNOWN;
        if (amountToApprove.currency.isNative && positionManager !== PositionManager.GAMMA)
            return ApprovalState.APPROVED;

        return needAllowance ? ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;
    }, [amountToApprove, needAllowance, spender, positionManager]);

    const { config } = usePrepareContractWrite({
        address: amountToApprove
            ? (amountToApprove.currency.wrapped.address as Address)
            : undefined,
        abi: erc20ABI,
        functionName: "approve",
        args: [
            spender,
            amountToApprove
                ? parseUnits(Number.MAX_SAFE_INTEGER.toString(), 18) // BigInt(amountToApprove.quotient.toString())
                : 0,
        ] as [Address, bigint],
    });

    const {
        data: approvalData,
        writeAsync: approve,
        isLoading: isConfirmLoading,
    } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(approvalData?.hash, {
        title: `Approve ${amountToApprove?.currency.symbol}`,
        tokenA: token?.address as Address,
        type: TransactionType.SWAP,
    });

    return {
        approvalState:
            isLoading || isConfirmLoading
                ? ApprovalState.PENDING
                : isSuccess && approvalState === ApprovalState.APPROVED
                  ? ApprovalState.APPROVED
                  : approvalState,
        approvalCallback: approve,
    };
}

export function useApproveCallbackFromTrade(
    trade: Trade<Currency, Currency, TradeType> | undefined,
    allowedSlippage: Percent,
) {
    const amountToApprove = useMemo(
        () =>
            trade && trade.inputAmount.currency.isToken
                ? trade.maximumAmountIn(allowedSlippage)
                : undefined,
        [trade, allowedSlippage],
    );
    return useApprove(amountToApprove, ALGEBRA_ROUTER);
}



================================================
File: src/hooks/common/useCurrency.ts
================================================
import { Address } from "wagmi";
import { Currency, ExtendedNative, WNATIVE } from "@glyph-exchange/integral-sdk";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import {
    DEFAULT_CHAIN_ID,
    DEFAULT_NATIVE_NAME,
    DEFAULT_NATIVE_SYMBOL,
} from "@/constants/default-chain-id";
import { useAlgebraToken } from "./useAlgebraToken";

export function useCurrency(
    address: Address | undefined,
    withNative?: boolean,
    isGamma?: boolean,
): Currency | ExtendedNative | undefined {
    const isWNative = address?.toLowerCase() === WNATIVE[DEFAULT_CHAIN_ID].address.toLowerCase();

    const isNative = address === ADDRESS_ZERO;

    const token = useAlgebraToken((isNative || isWNative) && !isGamma ? ADDRESS_ZERO : address);

    const extendedEther = ExtendedNative.onChain(
        DEFAULT_CHAIN_ID,
        DEFAULT_NATIVE_SYMBOL,
        DEFAULT_NATIVE_NAME,
    );

    if (withNative) return (isNative || isWNative) && !isGamma ? extendedEther : token;

    if (isWNative) return extendedEther.wrapped;

    return isNative && !isGamma ? extendedEther : token;
}



================================================
File: src/hooks/common/useDebounce.ts
================================================
import { useEffect, useState } from 'react'

/**
 * Debounces updates to a value.
 * Non-primitives *must* wrap the value in useMemo, or the value will be updated due to referential inequality.
 */
// modified from https://usehooks.com/useDebounce/
export default function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    // Update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    // Cancel the timeout if value changes (also on delay change or unmount)
    // This is how we prevent debounced value from updating if value is changed ...
    // .. within the delay period. Timeout gets cleared and restarted.
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}


================================================
File: src/hooks/common/useFuse.ts
================================================
import Fuse, { IFuseOptions } from 'fuse.js'
import { useMemo, useState } from 'react'
import { Address } from 'viem'

export function useFuse<T>({ data, options }: { data: T[], options: IFuseOptions<unknown> }) {

    const [pattern, setPattern] = useState<string | Address | undefined>(undefined)

    const fuse = useMemo(() => new Fuse(data, options), [data, options])

    const result = useMemo(() => pattern ? fuse.search(pattern).map(v => v.item) : data, [data, fuse, pattern])

    const clear = () => setPattern('')

    return {
        result,
        search: setPattern,
        pattern,
        clear
    }

}


================================================
File: src/hooks/common/useGamma.ts
================================================
import { usePrepareWrappedNativeDeposit, useWrappedNativeDeposit } from "@/generated";
import { useMintState } from "@/state/mintStore";
import { GammaUserDatas, HypervisorsData, WrapState, WrapStateType } from "@/types/gamma-state";
import { PositionManager } from "@/types/position-state";
import { useEffect, useMemo, useState } from "react";
import { useParams } from "react-router-dom";
import { Address, useAccount, useBalance, useQuery } from "wagmi";
import { useTransactionAwait } from "./useTransactionAwait";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { Currency, CurrencyAmount, Fraction } from "@glyph-exchange/integral-sdk";

export const useHypervisorsData = (enabled = false) => {
    return useQuery(["allDataSummary"], {
        async queryFn() {
            const result = await fetch("https://wire2.gamma.xyz/glyph/core/hypervisors/allData");
            const allData: HypervisorsData = await result.json();
            return { ...allData };
        },
        enabled,
        refetchInterval: 30_000,
    });
};

export const useGammaUserData = (user: Address, enabled = false) => {
    return useQuery(["userDataSummary"], {
        async queryFn() {
            const result = await fetch(`https://wire2.gamma.xyz/glyph/core/user/${user}`);
            const allData: GammaUserDatas = await result.json();
            return { ...allData };
        },
        enabled,
        refetchInterval: 30_000,
    });
};

type NewPositionPageParams = Record<"pool", Address>;
export const useCheckPool = () => {
    const { pool: poolAddress } = useParams<NewPositionPageParams>();

    const {
        positionManager,
        actions: { setPositionManager, setHypervisor },
    } = useMintState();
    const { data: hypervisors } = useHypervisorsData(!!poolAddress);
    const [inited, setInited] = useState(false);

    useEffect(() => {
        setPositionManager(PositionManager.ALGEBRA);
        if (hypervisors && poolAddress) {
            const hypervisor = hypervisors[poolAddress.toLowerCase()];
            if (hypervisor) {
                hypervisor.address = poolAddress;
                setHypervisor(hypervisor);
                setPositionManager(PositionManager.GAMMA);
            }
            setInited(true);
        }
    }, [hypervisors, poolAddress]);

    useEffect(() => {
        return () => {
            setPositionManager(PositionManager.ALGEBRA);
        };
    }, []);

    return {
        inited,
        poolAddress,
        positionManager,
    };
};

export const useNativeWrap = (
    amountToWrap: CurrencyAmount<Currency> | undefined,
    enabled = true,
) => {
    const [needWrap, diffAmount] = useNeedWrap(amountToWrap, enabled);

    const wrapState: WrapStateType = useMemo(() => {
        if (!amountToWrap) return WrapState.UNKNOWN;
        return needWrap ? WrapState.NOT_WRAPPED : WrapState.WRAPPED;
    }, [needWrap, amountToWrap]);

    const { config } = usePrepareWrappedNativeDeposit({
        enabled: enabled && needWrap,
        address: amountToWrap?.wrapped.currency.address as Address,
        value: BigInt(diffAmount.numerator.toString()),
    });

    const {
        data: wrapData,
        writeAsync: wrap,
        isLoading: isConfirmLoading,
    } = useWrappedNativeDeposit(config);

    const { isLoading, isSuccess } = useTransactionAwait(wrapData?.hash, {
        title: `Wrap ${amountToWrap?.currency.symbol}`,
        tokenA: amountToWrap?.wrapped.currency.address as Address,
        type: TransactionType.POOL,
    });

    return {
        wrapState:
            isLoading || isConfirmLoading
                ? WrapState.PENDING
                : isSuccess && wrapState === WrapState.WRAPPED
                  ? WrapState.WRAPPED
                  : wrapState,
        wrapCallback: wrap,
    };
};

const useNeedWrap = (
    currencyAmount: CurrencyAmount<Currency> | undefined,
    enabled = true,
): [boolean, Fraction] => {
    const { address } = useAccount();

    const { data: tokenBalance } = useBalance({
        address,
        token: currencyAmount?.wrapped.currency.address as Address,
        watch: true,
        enabled: enabled && !!currencyAmount,
    });

    const diffAmount = useMemo(() => {
        if (currencyAmount && tokenBalance) {
            return new Fraction(currencyAmount.numerator.toString()).subtract(
                tokenBalance.value.toString(),
            );
        }
        return new Fraction(0);
    }, [currencyAmount, tokenBalance]);

    return [
        Boolean(enabled && tokenBalance && currencyAmount && diffAmount.greaterThan(0)),
        diffAmount,
    ];
};



================================================
File: src/hooks/common/useMediaQuery.ts
================================================
import * as React from "react";

const queries = {
    mobile: "(max-width: 431px)",
    desktop: "(min-width: 768px)",
} as const;
type Query = keyof typeof queries;

export function useMediaQuery(query: Query) {
    const [value, setValue] = React.useState(matchMedia(queries[query]).matches);

    React.useEffect(() => {
        function onChange(event: MediaQueryListEvent) {
            setValue(event.matches);
        }

        const result = matchMedia(queries[query]);
        result.addEventListener("change", onChange);
        setValue(result.matches);

        return () => result.removeEventListener("change", onChange);
    }, []);

    return value;
}



================================================
File: src/hooks/common/useNeedAllowance.ts
================================================
import { useMintState } from "@/state/mintStore";
import { PositionManager } from "@/types/position-state";
import { Currency, CurrencyAmount } from "@glyph-exchange/integral-sdk";
import { erc20ABI, useAccount, useContractRead } from "wagmi";

export function useNeedAllowance(
    currency: Currency | null | undefined,
    amount: CurrencyAmount<Currency> | undefined,
    spender: Account | undefined,
) {
    const { address: account } = useAccount();

    const positionManager = useMintState((state) => state.positionManager);

    const { data: allowance } = useContractRead({
        address: currency?.wrapped.address as Account,
        abi: erc20ABI,
        functionName: "allowance",
        watch: true,
        args: account && spender && [account, spender],
    });

    const condition =
        typeof allowance === "bigint" && amount && amount.greaterThan(allowance.toString());

    return Boolean(
        positionManager === PositionManager.ALGEBRA ? !currency?.isNative && condition : condition,
    );
}



================================================
File: src/hooks/common/useTransactionAwait.tsx
================================================
import { useToast } from "@/components/ui/use-toast";
import { TransactionInfo, usePendingTransactionsStore } from "@/state/pendingTransactionsStore";
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { Address, useAccount, useWaitForTransaction } from "wagmi";
import { useExplorer } from "./useWeb3";
import Image from "@/components/common/Image";
import { useMediaQuery } from "./useMediaQuery";

export const ViewTxOnExplorer = ({
    hash,
    action,
}: {
    hash: Address | undefined;
    action: (address: string) => void;
}) => {
    const isMobile = useMediaQuery("mobile");

    return hash ? (
        <div
            onClick={() => action(hash)}
            className="flex h-[16px] w-[16px] cursor-pointer items-center justify-center m:h-[14px] m:w-[14px]"
        >
            <Image width={isMobile ? 14 : 16} src="/link.svg" alt="" />
        </div>
    ) : (
        // <ToastAction altText="View on explorer" asChild>
        //     <Link
        //         to={`https://scan.test.btcs.network/tx/${hash}`}
        //         target={'_blank'}
        //         className="border-none gap-2 hover:bg-transparent hover:text-blue-400"
        //     >
        //         View on explorer
        //         <
        //         <ExternalLinkIcon size={16} />
        //     </Link>
        // </ToastAction>
        <></>
    );
};

export function useTransactionAwait(
    hash: Address | undefined,
    transactionInfo: TransactionInfo,
    redirectPath?: string,
) {
    const { toast } = useToast();

    const navigate = useNavigate();

    const { address: account } = useAccount();

    const {
        actions: { addPendingTransaction, updatePendingTransaction },
    } = usePendingTransactionsStore();

    const { data, isError, isLoading, isSuccess } = useWaitForTransaction({
        hash,
    });

    const { toHash } = useExplorer();

    useEffect(() => {
        if (isLoading && hash && account) {
            toast({
                title: transactionInfo.title,
                description: transactionInfo.description || "Transaction was sent",
                action: <ViewTxOnExplorer hash={hash} action={toHash} />,
            });
            addPendingTransaction(account, hash);
            updatePendingTransaction(account, hash, {
                data: transactionInfo,
                loading: true,
                success: null,
                error: null,
            });
        }
    }, [isLoading, hash, account]);

    useEffect(() => {
        if (isError && hash) {
            toast({
                title: transactionInfo.title,
                description: transactionInfo.description || "Transaction failed",
                action: <ViewTxOnExplorer hash={hash} action={toHash} />,
            });
        }
    }, [isError]);

    useEffect(() => {
        if (isSuccess && hash) {
            toast({
                title: transactionInfo.title,
                description: transactionInfo.description || "Transaction confirmed",
                action: <ViewTxOnExplorer hash={hash} action={toHash} />,
            });
            if (redirectPath) {
                navigate(redirectPath);
            }
        }
    }, [isSuccess]);

    return {
        data,
        isError,
        isLoading,
        isSuccess,
    };
}



================================================
File: src/hooks/common/useUSDCValue.ts
================================================
import { STABLECOINS } from "@/constants/tokens"
import { useNativePriceQuery, useSingleTokenQuery } from "@/graphql/generated/graphql"
import { Currency, CurrencyAmount, Price, tryParseAmount } from "@glyph-exchange/integral-sdk"
import { useMemo } from "react"

export function useUSDCPrice(currency: Currency | undefined) {

    const { data: bundles } = useNativePriceQuery()

    const { data: token } = useSingleTokenQuery({
        variables: {
            tokenId: currency ? currency.wrapped.address.toLowerCase() : ''
        }
    })

    return useMemo(() => {

        if (!currency || !bundles?.bundles?.[0] || !token?.token) return {
            price: undefined,
            formatted: 0
        }

        if (STABLECOINS.USDT.address.toLowerCase() === currency.wrapped.address.toLowerCase()) return {
            price: new Price(STABLECOINS.USDT, STABLECOINS.USDT, '1', '1'),
            formatted: 1
        }

        const tokenUSDValue = Number(token.token.derivedMatic) * Number(bundles.bundles[0].maticPriceUSD)

        const usdAmount = tryParseAmount(tokenUSDValue.toString(), currency)

        if (usdAmount) {
            return {
                price: new Price(currency, STABLECOINS.USDT, usdAmount.denominator, usdAmount.numerator),
                formatted: Number(usdAmount.toSignificant())
            }
        }

        return {
            price: undefined,
            formatted: 0
        }

    }, [currency, bundles, token])

}

export function useUSDCValue(currencyAmount: CurrencyAmount<Currency> | undefined | null) {

    const { price, formatted } = useUSDCPrice(currencyAmount?.currency)

    return useMemo(() => {

        if (!price || !currencyAmount) return {
            price: null,
            formatted: null
        }

        try {
            return {
                price: price.quote(currencyAmount),
                formatted: Number(currencyAmount.toSignificant()) * formatted
            }
        } catch {
            return {
                price: null,
                formatted: null
            }
        }

    }, [currencyAmount, price])

}


================================================
File: src/hooks/common/useWeb3.ts
================================================
import { coreChain } from "@/App";
import { useCallback, useMemo } from "react";

export const useExplorer = () => {
    const explorer = useMemo(() => coreChain.blockExplorers?.default.url, []);

    const toUrl = useCallback(
        (address: string, type: "token" | "address" | "tx") => {
            if (explorer) window.open(`${explorer}/${type}/${address}`);
        },
        [explorer],
    );

    const toToken = useCallback((address: string) => toUrl(address, "token"), [toUrl]);
    const toHash = useCallback((address: string) => toUrl(address, "tx"), [toUrl]);
    const toAddress = useCallback((address: string) => toUrl(address, "address"), [toUrl]);

    return {
        explorer,
        toAddress,
        toHash,
        toToken,
    };
};



================================================
File: src/hooks/farming/useActiveFarming.ts
================================================
import { Address, useAccount } from "wagmi";
import { useClients } from "../graphql/useClients";
import { useEffect, useState } from "react";
import {
    useDepositsQuery,
    useEternalFarmingsQuery,
    useSingleTokenQuery,
    SinglePoolQuery,
} from "@/graphql/generated/graphql";
import { Farming } from "@/types/farming-info";
import { INTEGRALCOINS } from "@/constants/tokens";

export function useActiveFarming({
    poolId,
    poolInfo,
    enabled = true,
}: {
    poolId: Address;
    poolInfo: SinglePoolQuery | undefined;
    enabled?: boolean;
}) {
    const { address: account } = useAccount();

    const [farmingInfo, setFarmingInfo] = useState<Farming | null>();

    const { farmingClient } = useClients();

    const { data: farmings, loading: isFarmingLoading } = useEternalFarmingsQuery({
        variables: {
            pool: poolId,
        },
        client: farmingClient,
        skip: !poolInfo || !enabled,
    });

    const activeFarming = farmings?.eternalFarmings.filter((farming) => !farming.isDeactivated)[0];

    const { data: rewardToken } = useSingleTokenQuery({
        skip: !activeFarming,
        variables: {
            tokenId: activeFarming?.rewardToken,
        },
    });

    const { data: bonusRewardToken } = useSingleTokenQuery({
        skip: !activeFarming || !activeFarming?.bonusRewardToken,
        variables: {
            tokenId: activeFarming?.bonusRewardToken,
        },
    });

    const { data: deposits, loading: areDepositsLoading } = useDepositsQuery({
        variables: {
            owner: account,
            pool: poolId,
        },
        client: farmingClient,
        skip: !poolInfo || !enabled,
    });

    useEffect(() => {
        let curRewardToken = rewardToken?.token;
        if (!farmings?.eternalFarmings) return;
        if (!poolInfo) return;

        if (!curRewardToken) {
            if (
                activeFarming?.rewardToken &&
                activeFarming.rewardToken.toLowerCase() === INTEGRALCOINS.GP.address.toLowerCase()
            ) {
                curRewardToken = {
                    ...INTEGRALCOINS.GP,
                    derivedMatic: 0,
                    id: INTEGRALCOINS.GP.address,
                    symbol: INTEGRALCOINS.GP.symbol ?? "",
                    name: INTEGRALCOINS.GP.name ?? "",
                };
            } else {
                return;
            }
        }
        if (!bonusRewardToken) return;
        if (!activeFarming || !curRewardToken) {
            console.debug("Active farming not found");
            setFarmingInfo(null);
            return;
        }

        setFarmingInfo({
            farming: activeFarming,
            rewardToken: curRewardToken,
            bonusRewardToken: bonusRewardToken.token ?? null,
            pool: poolInfo.pool,
        });
    }, [farmings, rewardToken, bonusRewardToken, poolInfo, activeFarming]);

    return {
        farmingInfo,
        deposits,
        isFarmingLoading,
        areDepositsLoading,
    };
}



================================================
File: src/hooks/farming/useClosedFarmings.ts
================================================
import {
    EternalFarming,
    SinglePoolQuery,
    useEternalFarmingsQuery,
} from "@/graphql/generated/graphql";
import { useMemo, useState } from "react";
import { Address } from "viem";
import { useClients } from "../graphql/useClients";

export function useClosedFarmings({
    poolId,
    poolInfo,
    enabled = true,
}: {
    poolId: Address;
    poolInfo: SinglePoolQuery | undefined;
    enabled?: boolean;
}) {
    const [closedFarmings, setClosedFarmings] = useState<EternalFarming[] | null>();

    const { farmingClient } = useClients();

    const { data: initialData, loading: isLoading } = useEternalFarmingsQuery({
        variables: {
            pool: poolId,
        },
        client: farmingClient,
        skip: !poolInfo || !enabled,
    });

    useMemo(() => {
        if (initialData && initialData.eternalFarmings) {
            const filteredFarmings = initialData.eternalFarmings.filter(
                (farming) => farming.isDeactivated,
            );
            setClosedFarmings(filteredFarmings);
        }
    }, [initialData]);

    return {
        closedFarmings,
        isLoading,
    };
}



================================================
File: src/hooks/farming/useFarmApprove.ts
================================================
import {
    ALGEBRA_POSITION_MANAGER,
    FARMING_CENTER,
} from '@/constants/addresses';
import { algebraPositionManagerABI } from '@/generated';
import { useContractWrite, usePrepareContractWrite } from 'wagmi';
import { useTransactionAwait } from '../common/useTransactionAwait';
import { useEffect } from 'react';
import { useFarmCheckApprove } from './useFarmCheckApprove';
import { TransactionType } from '@/state/pendingTransactionsStore';

export function useFarmApprove(tokenId: bigint) {
    const APPROVE = true;

    const { config } = usePrepareContractWrite({
        address: tokenId ? ALGEBRA_POSITION_MANAGER : undefined,
        abi: algebraPositionManagerABI,
        functionName: 'approveForFarming',
        args: [tokenId, APPROVE, FARMING_CENTER],
    });

    const { data: data, writeAsync: onApprove } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(
        data?.hash,
        {
            title: `Approve Position #${tokenId}`,
            tokenId: tokenId.toString(),
            type: TransactionType.FARM
        }
    );

    const { handleCheckApprove } = useFarmCheckApprove(tokenId);

    useEffect(() => {
        if (isSuccess) {
            handleCheckApprove();
        }
    }, [isSuccess]);

    return {
        isLoading,
        isSuccess,
        onApprove,
    };
}



================================================
File: src/hooks/farming/useFarmCheckApprove.ts
================================================
import { useAlgebraPositionManagerFarmingApprovals } from '@/generated';
import { ADDRESS_ZERO } from '@glyph-exchange/integral-sdk';
import { useEffect, useState } from 'react';

export function useFarmCheckApprove(tokenId: bigint) {
    const [approved, setApproved] = useState<boolean>();

    const {
        data,
        isLoading: isApproveLoading,
        refetch,
    } = useAlgebraPositionManagerFarmingApprovals({
        args: [tokenId],
    });

    useEffect(() => {
        setApproved(data !== ADDRESS_ZERO);
    }, [tokenId, data]);

    return {
        approved,
        handleCheckApprove: refetch,
        isLoading: approved === undefined || isApproveLoading,
    };
}



================================================
File: src/hooks/farming/useFarmHarvest.ts
================================================
import { FARMING_CENTER } from "@/constants/addresses";
import { farmingCenterABI } from "@/generated";
import { getRewardsCalldata } from "@/utils/farming/getRewardsCalldata";
import { Address, useContractWrite, usePrepareContractWrite } from "wagmi";
import { useTransactionAwait } from "../common/useTransactionAwait";
import { encodeFunctionData } from "viem";
import { Deposit } from "@/graphql/generated/graphql";
import { TransactionType } from "@/state/pendingTransactionsStore";

export function useFarmHarvest({
    tokenId,
    rewardToken,
    bonusRewardToken,
    pool,
    nonce,
    account,
}: {
    tokenId: bigint;
    rewardToken: Address;
    bonusRewardToken: Address;
    pool: Address;
    nonce: bigint;
    account: Address;
}) {
    const calldata = getRewardsCalldata({
        rewardToken,
        bonusRewardToken,
        pool,
        nonce,
        tokenId,
        account,
    });

    const { config } = usePrepareContractWrite({
        address: account && tokenId ? FARMING_CENTER : undefined,
        abi: farmingCenterABI,
        functionName: "multicall",
        args: [calldata],
    });

    const {
        data: data,
        writeAsync: onHarvest,
        isLoading: isConfirmLoading,
    } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(data?.hash, {
        title: `Harvest Position #${tokenId}`,
        tokenId: tokenId.toString(),
        type: TransactionType.FARM,
    });

    return {
        isLoading: isLoading || isConfirmLoading,
        isSuccess,
        onHarvest,
    };
}

export function useFarmHarvestAll(
    {
        rewardToken,
        bonusRewardToken,
        pool,
        nonce,
        account,
    }: {
        rewardToken: Address;
        bonusRewardToken: Address;
        pool: Address;
        nonce: bigint;
        account: Address;
    },
    deposits: Deposit[],
) {
    const calldatas: Address[] = [];

    deposits.forEach((deposit) => {
        if (deposit.eternalFarming !== null) {
            const rewardsCalldata = getRewardsCalldata({
                rewardToken,
                bonusRewardToken,
                pool,
                nonce,
                tokenId: BigInt(deposit.id),
                account,
            });

            const calldata = encodeFunctionData({
                abi: farmingCenterABI,
                functionName: "multicall",
                args: [rewardsCalldata],
            });
            calldatas.push(calldata);
        }
    });

    const { config } = usePrepareContractWrite({
        address: FARMING_CENTER,
        abi: farmingCenterABI,
        functionName: "multicall",
        args: [calldatas],
    });

    const {
        data: data,
        writeAsync: onHarvestAll,
        isLoading: isConfirmLoading,
    } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(data?.hash, {
        title: `Harvest All Positions`,
        type: TransactionType.FARM,
        tokenId: "0",
    });

    return {
        isLoading: isLoading || isConfirmLoading,
        isSuccess,
        onHarvestAll,
    };
}



================================================
File: src/hooks/farming/useFarmStake.ts
================================================
import { FARMING_CENTER } from "@/constants/addresses";
import { farmingCenterABI } from "@/generated";
import { Address, useContractWrite, usePrepareContractWrite } from "wagmi";
import { useTransactionAwait } from "../common/useTransactionAwait";
import { encodeFunctionData } from "viem";
import { MaxUint128 } from "@glyph-exchange/integral-sdk";
import { useFarmCheckApprove } from "./useFarmCheckApprove";
import { useEffect, useState } from "react";
import { farmingClient } from "@/graphql/clients";
import { Deposit } from "@/graphql/generated/graphql";
import { TransactionType } from "@/state/pendingTransactionsStore";

export function useFarmStake({
    tokenId,
    rewardToken,
    bonusRewardToken,
    pool,
    nonce,
}: {
    tokenId: bigint;
    rewardToken: Address;
    bonusRewardToken: Address;
    pool: Address;
    nonce: bigint;
}) {
    const { approved } = useFarmCheckApprove(tokenId);

    const [isQueryLoading, setIsQueryLoading] = useState<boolean>(false);

    const address = tokenId && approved ? FARMING_CENTER : undefined;

    const { config } = usePrepareContractWrite({
        address,
        abi: farmingCenterABI,
        functionName: "enterFarming",
        args: [
            {
                rewardToken,
                bonusRewardToken,
                pool,
                nonce,
            },
            tokenId,
        ],
    });

    const { data: data, writeAsync: onStake } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(data?.hash, {
        title: `Stake Position #${tokenId}`,
        tokenId: tokenId.toString(),
        type: TransactionType.FARM,
    });

    useEffect(() => {
        if (!isSuccess) return;

        setIsQueryLoading(true);
        const interval: NodeJS.Timeout = setInterval(
            () =>
                farmingClient.refetchQueries({
                    include: ["Deposits"],
                    onQueryUpdated: (query, { result: diff }) => {
                        const currentPos = diff.deposits.find(
                            (deposit: Deposit) => deposit.id.toString() === tokenId.toString(),
                        );
                        if (!currentPos) return;

                        if (currentPos.eternalFarming !== null) {
                            setIsQueryLoading(false);
                            clearInterval(interval);
                        } else {
                            query.refetch().then();
                        }
                    },
                }),
            2000,
        );

        return () => clearInterval(interval);
    }, [isSuccess]);

    return {
        isLoading: isQueryLoading || isLoading,
        isSuccess,
        onStake,
    };
}

export function useFarmUnstake({
    tokenId,
    rewardToken,
    bonusRewardToken,
    pool,
    nonce,
    account,
}: {
    tokenId: bigint;
    rewardToken: Address;
    bonusRewardToken: Address;
    pool: Address;
    nonce: bigint;
    account: Address;
}) {
    const [isQueryLoading, setIsQueryLoading] = useState<boolean>(false);

    const exitFarmingCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "exitFarming",
        args: [
            {
                rewardToken,
                bonusRewardToken,
                pool,
                nonce,
            },
            tokenId,
        ],
    });

    const rewardClaimCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "claimReward",
        args: [rewardToken, account, BigInt(MaxUint128)],
    });

    const bonusRewardClaimCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "claimReward",
        args: [bonusRewardToken, account, BigInt(MaxUint128)],
    });

    const calldatas = [exitFarmingCalldata, rewardClaimCalldata, bonusRewardClaimCalldata];

    const { config } = usePrepareContractWrite({
        address: account && tokenId ? FARMING_CENTER : undefined,
        abi: farmingCenterABI,
        functionName: "multicall",
        args: [calldatas],
    });

    const {
        data: data,
        writeAsync: onUnstake,
        isLoading: isConfirmLoading,
    } = useContractWrite(config);

    const { isLoading, isSuccess } = useTransactionAwait(data?.hash, {
        title: `Unstake Position #${tokenId}`,
        tokenId: tokenId.toString(),
        type: TransactionType.FARM,
    });

    useEffect(() => {
        if (!isSuccess) return;

        setIsQueryLoading(true);
        const interval: NodeJS.Timeout = setInterval(
            () =>
                farmingClient.refetchQueries({
                    include: ["Deposits"],
                    onQueryUpdated: (query, { result: diff }) => {
                        const currentPos = diff.deposits.find(
                            (deposit: Deposit) => deposit.id.toString() === tokenId.toString(),
                        );
                        if (!currentPos) return;

                        if (currentPos.eternalFarming === null) {
                            setIsQueryLoading(false);
                            clearInterval(interval);
                        } else {
                            query.refetch().then();
                        }
                    },
                }),
            2000,
        );

        return () => clearInterval(interval);
    }, [isSuccess]);

    return {
        isLoading: isLoading || isQueryLoading || isConfirmLoading,
        isSuccess,
        onUnstake,
    };
}



================================================
File: src/hooks/farming/useFarmingAPR.ts
================================================
import { ETERNAL_FARMINGS_API, fetcher } from '@/constants/api';
import { useMemo } from 'react';
import useSWR from 'swr';

export function useFarmingAPR({ farmingId }: { farmingId: string }): string {
    const { data: farmingsAPR } = useSWR(ETERNAL_FARMINGS_API, fetcher);

    return useMemo(() => {
        if (!farmingsAPR) {
            return 0;
        }

        const farmingAPR = farmingsAPR[farmingId];

        if (farmingAPR === -1) return 0;

        if (farmingAPR >= 100) return farmingAPR.toFixed();

        if (farmingAPR < 100) return farmingAPR.toFixed(2);
    }, [farmingId, farmingsAPR]);
}



================================================
File: src/hooks/farming/useRewardEarnedUSD.ts
================================================
import {
    TokenFieldsFragment,
    useNativePriceQuery,
} from '@/graphql/generated/graphql';
import { useMemo } from 'react';
import { formatUnits } from 'viem';

export function useRewardEarnedUSD({
    token,
    reward,
}: {
    token: TokenFieldsFragment | null;
    reward: bigint;
}): number {
    const { data: nativePrice } = useNativePriceQuery();

    return useMemo(() => {
        if (!token || !nativePrice) return 0;

        const formattedRewardEarned = Number(
            formatUnits(reward, token.decimals)
        );

        const rewardUSD =
            token.derivedMatic *
            formattedRewardEarned *
            nativePrice.bundles[0].maticPriceUSD;

        return rewardUSD;
    }, [nativePrice, token, reward]);
}



================================================
File: src/hooks/graphql/useClients.ts
================================================
import { infoClient, blocksClient, farmingClient } from '@/graphql/clients';

export function useClients() {
    return {
        infoClient,
        blocksClient,
        farmingClient,
    };
}



================================================
File: src/hooks/pools/usePool.ts
================================================
import {
    useAlgebraPoolGlobalState,
    useAlgebraPoolLiquidity,
    useAlgebraPoolTickSpacing,
    useAlgebraPoolToken0,
    useAlgebraPoolToken1,
} from "@/generated";
import { Pool } from "@glyph-exchange/integral-sdk";
import { Address } from "wagmi";
import { useCurrency } from "../common/useCurrency";
import { useMemo } from "react";

export const PoolState = {
    LOADING: "LOADING",
    NOT_EXISTS: "NOT_EXISTS",
    EXISTS: "EXISTS",
    INVALID: "INVALID",
} as const;

export type PoolStateType = (typeof PoolState)[keyof typeof PoolState];

export function usePool(
    address: Address | undefined,
    enabled = true,
): [PoolStateType, Pool | null] {
    const {
        data: tickSpacing,
        isLoading: isTickSpacingLoading,
        isError: isTickSpacingError,
    } = useAlgebraPoolTickSpacing({
        address,
        enabled,
    });
    const {
        data: globalState,
        isLoading: isGlobalStateLoading,
        isError: isGlobalStateError,
    } = useAlgebraPoolGlobalState({
        address,
        enabled,
    });
    const {
        data: liquidity,
        isLoading: isLiquidityLoading,
        isError: isLiquidityError,
    } = useAlgebraPoolLiquidity({
        address,
        enabled,
    });

    const {
        data: token0Address,
        isLoading: isLoadingToken0,
        isError: isToken0Error,
    } = useAlgebraPoolToken0({
        address,
        enabled,
    });
    const {
        data: token1Address,
        isLoading: isLoadingToken1,
        isError: isToken1Error,
    } = useAlgebraPoolToken1({
        address,
        enabled,
    });

    const token0 = useCurrency(token0Address);
    const token1 = useCurrency(token1Address);

    const isPoolError =
        isTickSpacingError ||
        isGlobalStateError ||
        isLiquidityError ||
        isToken0Error ||
        isToken1Error ||
        !address;

    const isPoolLoading =
        isTickSpacingLoading ||
        isGlobalStateLoading ||
        isLiquidityLoading ||
        isLoadingToken0 ||
        isLoadingToken1;
    const isTokensLoading = !token0 || !token1;

    return useMemo(() => {
        if ((isPoolLoading || isTokensLoading) && !isPoolError) return [PoolState.LOADING, null];

        if (!tickSpacing || !globalState || liquidity === undefined)
            return [PoolState.NOT_EXISTS, null];

        if (globalState[0] === 0n || !token0 || !token1) return [PoolState.NOT_EXISTS, null];

        try {
            return [
                PoolState.EXISTS,
                new Pool(
                    token0.wrapped,
                    token1.wrapped,
                    globalState[2],
                    globalState[0].toString(),
                    Number(liquidity),
                    globalState[1],
                    tickSpacing,
                ),
            ];
        } catch (error) {
            return [PoolState.NOT_EXISTS, null];
        }
    }, [
        token0,
        token1,
        globalState,
        liquidity,
        tickSpacing,
        isPoolError,
        isPoolLoading,
        isTokensLoading,
    ]);
}



================================================
File: src/hooks/pools/usePoolPlugins.ts
================================================
import {
    useAlgebraPoolGlobalState,
    useAlgebraPoolPlugin,
    useAlgebraBasePluginIncentive,
} from '@/generated';
import { usePoolsStore } from '@/state/poolsStore';
import { ADDRESS_ZERO } from '@glyph-exchange/integral-sdk';
import { useEffect } from 'react';
import { Address } from 'wagmi';

export function usePoolPlugins(poolId: Address | undefined) {
    const { pluginsForPools, setPluginsForPool } = usePoolsStore();

    const skipFetch = Boolean(poolId && pluginsForPools[poolId]);

    const { data: globalState, isLoading: globalStateLoading } =
        useAlgebraPoolGlobalState({
            address: skipFetch ? undefined : poolId,
        });

    const { data: plugin, isLoading: pluginLoading } = useAlgebraPoolPlugin({
        address: skipFetch ? undefined : poolId,
    });

    const { data: hasFarmingPlugin, isLoading: farmingLoading } =
        useAlgebraBasePluginIncentive({
            address: skipFetch ? undefined : plugin,
        });

    // const { data: hasLimitOrderPlugin, isLoading: limitLoading } =
    //     useAlgebraBasePluginLimitOrderPlugin({
    //         address: skipFetch ? undefined : plugin,
    //     });

    const isLoading = globalStateLoading || pluginLoading || farmingLoading;

    const hasDynamicFee = globalState && Number(globalState[3]) >> 7 === 1;

    useEffect(() => {
        if (!poolId || isLoading || pluginsForPools[poolId]) return;

        setPluginsForPool(poolId, {
            dynamicFeePlugin: Boolean(hasDynamicFee),
            farmingPlugin: hasFarmingPlugin !== ADDRESS_ZERO,
            limitOrderPlugin: false,
        });
    }, [poolId, isLoading, pluginsForPools]);

    if (poolId && pluginsForPools[poolId]) {
        return {
            ...pluginsForPools[poolId],
            isLoading: false,
        };
    }

    return {
        dynamicFeePlugin: Boolean(hasDynamicFee),
        farmingPlugin: hasFarmingPlugin !== ADDRESS_ZERO,
        limitOrderPlugin: false,
        isLoading,
    };
}



================================================
File: src/hooks/pools/usePoolTickData.ts
================================================
import { TickFieldsFragment, useAllTicksLazyQuery, useSinglePoolLazyQuery } from "@/graphql/generated/graphql"
import { Currency, TickMath, Token, computePoolAddress, tickToPrice } from "@glyph-exchange/integral-sdk"
import { useState } from "react"
import { Address } from "wagmi"
import keyBy from 'lodash.keyby'

interface TickProcessed {
    liquidityActive: bigint;
    tickIdx: number;
    liquidityNet: bigint;
    price0: string;
    price1: string;
    liquidityGross: bigint;
}

interface TicksResult {
    ticksProcessed: TickProcessed[];
    tickSpacing: number;
    activeTickIdx: number;
    token0: Token;
    token1: Token;
}

export function useInfoTickData() {

    const numSurroundingTicks = 500
    const PRICE_FIXED_DIGITS = 8

    const [ticksResult, setTicksResult] = useState<TicksResult | null>(null)
    const [ticksLoading, setTicksLoading] = useState(false)

    const [getPool] = useSinglePoolLazyQuery()
    const [getAllTicks] = useAllTicksLazyQuery()

    async function fetchInitializedTicks(poolAddress: Address) {
        let surroundingTicks: TickFieldsFragment[] = []
        let surroundingTicksResult: TickFieldsFragment[] = []

        let skip = 0
        do {

            const { data: ticks } = await getAllTicks({
                variables: {
                    poolAddress,
                    skip
                }
            })

            if (!ticks?.ticks) {
                return {
                    loading: true,
                    ticks: surroundingTicksResult,
                }
            }

            surroundingTicks = ticks.ticks
            surroundingTicksResult = surroundingTicksResult.concat(surroundingTicks)
            skip += 1000
        } while (surroundingTicks.length > 0)

        return { ticks: surroundingTicksResult, loading: false, error: false }
    }

    async function fetchTicksSurroundingPrice(currencyA: Currency, currencyB: Currency) {
        setTicksLoading(true)

        const poolId = computePoolAddress({
            tokenA: currencyA.wrapped,
            tokenB: currencyB.wrapped,
        }).toLowerCase() as Address

        const { data: pool } = await getPool({
            variables: {
                poolId
            }
        })

        try {

            if (!pool?.pool) return

            const {
                tick: poolCurrentTick,
                liquidity,
                token0: { id: token0Address, decimals: token0Decimals },
                token1: { id: token1Address, decimals: token1Decimals },
            } = pool.pool

            const tickSpacing = Number(pool.pool.tickSpacing)

            const poolCurrentTickIdx = parseInt(poolCurrentTick)

            const activeTickIdx = Math.floor(poolCurrentTickIdx / tickSpacing) * tickSpacing

            const initializedTicksResult = await fetchInitializedTicks(poolId)

            if (initializedTicksResult.error || initializedTicksResult.loading) {
                return {
                    error: initializedTicksResult.error,
                    loading: initializedTicksResult.loading,
                }
            }

            const { ticks: initializedTicks } = initializedTicksResult

            const tickIdxToInitializedTick = keyBy(initializedTicks, 'tickIdx')

            const token0 = new Token(1, token0Address, parseInt(token0Decimals))
            const token1 = new Token(1, token1Address, parseInt(token1Decimals))

            let activeTickIdxForPrice = activeTickIdx
            if (activeTickIdxForPrice < TickMath.MIN_TICK) {
                activeTickIdxForPrice = TickMath.MIN_TICK
            }
            if (activeTickIdxForPrice > TickMath.MAX_TICK) {
                activeTickIdxForPrice = TickMath.MAX_TICK
            }

            const activeTickProcessed = {
                liquidityActive: BigInt(liquidity),
                tickIdx: activeTickIdx,
                liquidityNet: BigInt(0),
                price0: tickToPrice(token0, token1, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),
                price1: tickToPrice(token1, token0, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),
                liquidityGross: BigInt(0),
            }

            const activeTick = tickIdxToInitializedTick[activeTickIdx]
            if (activeTick) {
                activeTickProcessed.liquidityGross = BigInt(activeTick.liquidityGross)
                activeTickProcessed.liquidityNet = BigInt(activeTick.liquidityNet)
            }

            const Direction = {
                ASC: 'ASC',
                DESC: 'DESC',
            }

            // Computes the numSurroundingTicks above or below the active tick.
            const computeSurroundingTicks = (activeTickProcessed: TickProcessed, tickSpacing: number, numSurroundingTicks: number, direction: string) => {
                let previousTickProcessed = {
                    ...activeTickProcessed,
                }

                // Iterate outwards (either up or down depending on 'Direction') from the active tick,
                // building active liquidity for every tick.
                let processedTicks = []
                for (let i = 0; i < numSurroundingTicks; i++) {
                    const currentTickIdx =
                        direction == Direction.ASC
                            ? previousTickProcessed.tickIdx + tickSpacing
                            : previousTickProcessed.tickIdx - tickSpacing

                    if (currentTickIdx < TickMath.MIN_TICK || currentTickIdx > TickMath.MAX_TICK) {
                        break
                    }

                    const currentTickProcessed = {
                        liquidityActive: previousTickProcessed.liquidityActive,
                        tickIdx: currentTickIdx,
                        liquidityNet: BigInt(0),
                        price0: tickToPrice(token0, token1, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),
                        price1: tickToPrice(token1, token0, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),
                        liquidityGross: BigInt(0),
                    }

                    const currentInitializedTick = tickIdxToInitializedTick[currentTickIdx.toString()]
                    if (currentInitializedTick) {
                        currentTickProcessed.liquidityGross = BigInt(currentInitializedTick.liquidityGross)
                        currentTickProcessed.liquidityNet = BigInt(currentInitializedTick.liquidityNet)
                    }

                    if (direction == Direction.ASC && currentInitializedTick) {
                        currentTickProcessed.liquidityActive = BigInt(previousTickProcessed.liquidityActive) + BigInt(currentInitializedTick.liquidityNet)
                    } else if (direction == Direction.DESC && BigInt(previousTickProcessed.liquidityNet) !== BigInt(0)) {
                        currentTickProcessed.liquidityActive = BigInt(previousTickProcessed.liquidityActive) - BigInt(previousTickProcessed.liquidityNet)
                    }

                    processedTicks.push(currentTickProcessed)
                    previousTickProcessed = currentTickProcessed
                }

                if (direction == Direction.DESC) {
                    processedTicks = processedTicks.reverse()
                }

                return processedTicks
            }

            const subsequentTicks = computeSurroundingTicks(
                activeTickProcessed,
                tickSpacing,
                numSurroundingTicks,
                Direction.ASC
            )

            const previousTicks = computeSurroundingTicks(
                activeTickProcessed,
                tickSpacing,
                numSurroundingTicks,
                Direction.DESC
            )

            const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)

            setTicksResult({
                ticksProcessed,
                tickSpacing: Number(tickSpacing),
                activeTickIdx,
                token0,
                token1,
            })
        } catch (err: any) {
            throw new Error(err)
        } finally {
            setTicksLoading(false)
        }
    }

    return {
        fetchTicksSurroundingPrice: {
            ticksResult,
            ticksLoading,
            fetchTicksSurroundingPrice,
        },
    }
}



================================================
File: src/hooks/pools/usePoolsList.ts
================================================
import { algebraFactoryABI } from "@/abis/algebraFactory"
import { ALGEBRA_FACTORY } from "@/constants/addresses"
import { useEffect, useState } from "react"
import { Address, decodeEventLog, parseAbiItem } from "viem"
import { usePublicClient } from "wagmi"

interface IPools {
    readonly token0: Address,
    readonly token1: Address,
    readonly pool: Address
}

// const ALGEBRA_FACTORY_CREATION_BLOCK = 18455522n
const ALGEBRA_FACTORY_CREATION_BLOCK = 32610688n

export function usePoolsList() {

    const publicClient = usePublicClient()

    const [pools, updatePools] = useState<IPools[]>()

    useEffect(() => {

        publicClient.getLogs({
            address: ALGEBRA_FACTORY,
            event: parseAbiItem('event Pool(address, address, address)'),
            fromBlock: ALGEBRA_FACTORY_CREATION_BLOCK,
            toBlock: 'latest'
        }).then(logs => logs.map(({ data, topics }) => decodeEventLog({
            abi: algebraFactoryABI,
            eventName: 'Pool',
            data,
            topics,
        }).args))
            .then(v => {
                updatePools(v)
            }
            )
            .catch(console.error)

    }, [])

    return { pools }

}


================================================
File: src/hooks/positions/usePositionAPR.ts
================================================
import { useAlgebraPoolLiquidity } from "@/generated"
import { useNativePriceQuery, usePoolFeeDataQuery, useSinglePoolQuery } from "@/graphql/generated/graphql"
import { Position } from "@glyph-exchange/integral-sdk"
import { Address } from "wagmi"

export function usePositionAPR(
    poolId: Address | undefined,
    position: Position | undefined,
    positionId?: string | undefined
) {

    const { data: liquidity } = useAlgebraPoolLiquidity({
        address: poolId
    })

    const { data: pool } = useSinglePoolQuery({
        variables: {
            poolId: poolId as string
        }
    })

    const { data: poolFeeData } = usePoolFeeDataQuery({
        variables: {
            poolId
        }
    })

    const { data: bundles } = useNativePriceQuery()

    const nativePrice = bundles?.bundles[0] && Number(bundles.bundles[0].maticPriceUSD)

    // Today fees
    const poolDayFees = poolFeeData && Boolean(poolFeeData.poolDayDatas.length) && Number(poolFeeData.poolDayDatas[0].feesUSD)

    // Avg fees
    // const poolDayFees = poolFeeData && Boolean(poolFeeData.poolDayDatas.length) && poolFeeData.poolDayDatas.reduce((acc, v) => acc + Number(v.feesUSD), 0) / poolFeeData.poolDayDatas.length

    const yearFee = poolDayFees && poolDayFees * 365

    const liquidityRelation = position && liquidity && Number(position.liquidity.toString()) / (Number(liquidity) + (positionId ? 0 : Number(position.liquidity.toString()))) 

    const [amount0, amount1] = position ? [position.amount0.toSignificant(), position.amount1.toSignificant()] : [0, 0]

    const tvl = 
        pool?.pool && nativePrice && 
        (Number(pool.pool.token0.derivedMatic) * nativePrice * Number(amount0) + 
        Number(pool.pool.token1.derivedMatic) * nativePrice * Number(amount1))

    return liquidityRelation && yearFee && tvl && ((yearFee * liquidityRelation) / tvl) * 100

}


================================================
File: src/hooks/positions/usePositionFees.ts
================================================
import { MAX_UINT128 } from "@/constants/max-uint128"
import { useAlgebraPositionManagerOwnerOf, usePrepareAlgebraPositionManagerCollect } from "@/generated"
import { Currency, CurrencyAmount, Pool, unwrappedToken } from "@glyph-exchange/integral-sdk"
import { useMemo } from "react"
import { Address } from "wagmi"

interface PositionFeesResult {
    amount0: CurrencyAmount<Currency> | undefined
    amount1: CurrencyAmount<Currency> | undefined
}

export function usePositionFees(
    pool?: Pool,
    tokenId?: number,
    asWNative = false
): PositionFeesResult {

    const { data: owner } = useAlgebraPositionManagerOwnerOf({
        args: tokenId ? [BigInt(tokenId)] : undefined,
    })

    const isReady = tokenId && owner;

    const { config: amountsConfig } = usePrepareAlgebraPositionManagerCollect({
        args: Boolean(isReady) ? [
            {
                tokenId: BigInt(tokenId || 0),
                recipient: owner as Address,
                amount0Max: MAX_UINT128,
                amount1Max: MAX_UINT128,
            }
        ] : undefined,
        enabled: Boolean(isReady)
    })

    const amounts = amountsConfig?.result

    return useMemo(() => {

        if (pool && amounts) {
            return {
                amount0: CurrencyAmount.fromRawAmount(!asWNative ? unwrappedToken(pool.token0) : pool.token0, amounts[0].toString()),
                amount1: CurrencyAmount.fromRawAmount(!asWNative ? unwrappedToken(pool.token1) : pool.token1, amounts[1].toString()),
            }
        } else {
            return {
                amount0: undefined,
                amount1: undefined
            }
        }
    }, [pool, amounts])
}



================================================
File: src/hooks/positions/usePositions.ts
================================================
import { algebraPositionManagerABI } from "@/abis";
import { ALGEBRA_POSITION_MANAGER } from "@/constants/addresses";
import { DEFAULT_CHAIN_ID } from "@/constants/default-chain-id";
import { useAlgebraPositionManagerBalanceOf } from "@/generated";
import { farmingClient } from "@/graphql/clients";
import { useDepositsQuery } from "@/graphql/generated/graphql";
import { Token, computePoolAddress } from "@glyph-exchange/integral-sdk";
import { useCallback, useEffect, useMemo, useState } from "react";
import { Address, useAccount, useContractReads } from "wagmi";
import { useGammaUserData, useHypervisorsData } from "../common/useGamma";
import { formatAmount } from "@/utils/common/formatAmount";
import { FormattedPosition } from "@/types/formatted-position";

export interface PositionFromTokenId {
    tokenId: number;
    feeGrowthInside0LastX128: bigint;
    feeGrowthInside1LastX128: bigint;
    liquidity: bigint;
    nonce: string;
    operator: string;
    tickLower: bigint;
    tickUpper: bigint;
    token0: Address;
    token1: Address;
    tokensOwed0: bigint;
    tokensOwed1: bigint;
    pool: Address;
}

function usePositionsFromTokenIds(tokenIds: any[] | undefined): {
    isLoading: boolean;
    positions: PositionFromTokenId[] | undefined;
    refetch: () => void;
} {
    const inputs = useMemo(() => (tokenIds ? tokenIds.map((tokenId) => tokenId) : []), [tokenIds]);

    const {
        data: results,
        isLoading,
        isError,
        error,
        refetch,
    } = useContractReads({
        contracts: inputs.map((x) => ({
            address: ALGEBRA_POSITION_MANAGER,
            abi: algebraPositionManagerABI,
            functionName: "positions",
            args: [[Number(x)]],
        })),
        cacheTime: 10_000,
    });

    const { address: account } = useAccount();

    const positions = useMemo(() => {
        if (!isLoading && !isError && tokenIds && !error) {
            return results
                ?.filter((v) => !v.error)
                .map((call, i) => {
                    const tokenId = tokenIds[i];
                    const result = call.result as any;

                    const pool = computePoolAddress({
                        tokenA: new Token(DEFAULT_CHAIN_ID, result[2], 18),
                        tokenB: new Token(DEFAULT_CHAIN_ID, result[3], 18),
                    }) as Address;

                    return {
                        tokenId,
                        feeGrowthInside0LastX128: result[7],
                        feeGrowthInside1LastX128: result[8],
                        liquidity: result[6],
                        nonce: result[0],
                        operator: result[1],
                        tickLower: result[4],
                        tickUpper: result[5],
                        token0: result[2],
                        token1: result[3],
                        tokensOwed0: result[9],
                        tokensOwed1: result[10],
                        pool,
                    };
                });
        }
        return undefined;
    }, [isLoading, isError, error, results, tokenIds, account, refetch]);

    return useMemo(() => {
        return {
            isLoading,
            positions,
            refetch,
        };
    }, [isLoading, positions, refetch]);
}

export function usePositions(enabled = true) {
    const { address: account } = useAccount();

    const { data: balanceResult, isLoading: balanceLoading } = useAlgebraPositionManagerBalanceOf({
        args: account && enabled ? [account] : undefined,
        cacheTime: 10_000,
    });

    const tokenIdsArgs: [Address, number][] = useMemo(() => {
        if (!balanceResult || !account) return [];

        const tokenRequests: any[] = [];

        for (let i = 0; i < balanceResult; i++) {
            tokenRequests.push([account, i]);
        }

        return tokenRequests;
    }, [account, balanceResult]);

    const { data: tokenIdResults, isLoading: someTokenIdsLoading } = useContractReads({
        contracts: tokenIdsArgs.map((args) => ({
            address: ALGEBRA_POSITION_MANAGER,
            abi: algebraPositionManagerABI,
            functionName: "tokenOfOwnerByIndex",
            args,
        })),
        cacheTime: 10_000,
    });

    const tokenIds = useMemo(() => {
        if (account) {
            return tokenIdResults
                ?.map(({ result }) => result)
                .filter((result) => !!result)
                .map((result) => result);
        }
        return [];
    }, [account, tokenIdResults]);

    const { positions, isLoading: positionsLoading, refetch } = usePositionsFromTokenIds(tokenIds);

    return {
        loading: someTokenIdsLoading || balanceLoading || positionsLoading,
        positions,
        refetch,
    };
}

export function useUserGammaPositions(enabled = true) {
    const { address: account } = useAccount();

    const {
        data: hypervisors,
        refetch: hypervisorsRefetch,
        isLoading: hypervisorsLoading,
    } = useHypervisorsData(!!account && enabled);
    const {
        data: userData,
        refetch: userDataRefetch,
        isLoading: userDataLoading,
    } = useGammaUserData(account, !!account && enabled);
    const [loading, setLoading] = useState(true);
    const [positions, setPositions] = useState<FormattedPosition[]>([]);

    const refetch = useCallback(() => {
        return Promise.all([hypervisorsRefetch(), userDataRefetch()]);
    }, [hypervisorsRefetch, userDataRefetch]);

    useEffect(() => {
        if (hypervisors && userData && account) {
            const currUserData = userData[account.toLowerCase()];

            if (currUserData) {
                const userPools = Object.keys(currUserData).filter((key) => key.startsWith("0x"));
                if (userPools?.length) {
                    let positionId = 1;
                    const positions: FormattedPosition[] = [];
                    userPools.map((item) => {
                        const curUserPositionData = currUserData[item as Address];
                        const curHypervisor = hypervisors[item];

                        const currPositons = {
                            id: positionId,
                            isClosed: Number(curUserPositionData.shares) == 0 ? true : false,
                            outOfRange: false,
                            range: `${formatAmount(Number(curHypervisor.baseLower).toFixed(6), 6)} — ${formatAmount(Number(curHypervisor.baseUpper).toFixed(6), 6)}`,
                            liquidityUSD:
                                Number(curHypervisor.tvlUSD) * curUserPositionData.shareOfSupply,
                            feesUSD:
                                Number(curHypervisor.grossFeesClaimedUSD) *
                                curUserPositionData.shareOfSupply,
                            apr: curHypervisor.returns.allTime.feeApr * 100,
                            inFarming: false,
                            inGamma: true,
                            hypervisor: curHypervisor,
                            userPositionData: curUserPositionData,
                            gammaPoolId: item as Address,
                            associatePoolId: curHypervisor.poolAddress,
                        } as FormattedPosition;

                        positionId++;
                        positions.push(currPositons);

                        setLoading(false);
                    });

                    if (positions?.length) {
                        setPositions(positions);
                    }
                }
            }
        }
    }, [hypervisors, userData, account]);

    return {
        loading,
        positions,
        refetch,
    };
}

export function usePosition(tokenId: string | number | undefined): {
    loading: boolean;
    position: PositionFromTokenId | undefined;
    refetch: () => void;
} {
    const tokenIdArr = useMemo(() => {
        if (!tokenId) return;
        return [tokenId];
    }, [tokenId]);

    const { isLoading, positions, refetch } = usePositionsFromTokenIds(tokenIdArr);

    return useMemo(() => {
        return {
            loading: isLoading,
            position: positions?.[0],
            refetch,
        };
    }, [isLoading, positions, refetch]);
}

export function usePositionInFarming(tokenId: string | number | undefined) {
    const { position } = usePosition(tokenId);

    const { address: account } = useAccount();

    const { data: deposits } = useDepositsQuery({
        variables: {
            owner: account ? account : undefined,
            pool: position?.pool,
        },
        client: farmingClient,
    });

    if (!deposits) return;
    const openedPositions = deposits.deposits.filter((deposit) => deposit.eternalFarming !== null);

    const positionInFarming = openedPositions.find(
        (deposit) => Number(deposit.id) === Number(tokenId),
    );

    if (!positionInFarming) return;
    return positionInFarming;
}



================================================
File: src/hooks/swap/useAggregatorData.ts
================================================
import { n2bi } from "@/utils";
import { useQuery } from "wagmi";
import useDebounce from "../common/useDebounce";
import { useMemo } from "react";

export type RouterData = {
    swaps: { amount_in?: number; amount_out?: number; hops?: number }[];
    toAmount: bigint;
    tx: {
        data: `0x${string}`;
        from: `0x${string}`;
        to: `0x${string}`;
        value: bigint;
    };
};
export const useAggregatorData = ({
    from,
    src,
    dst,
    amountIn,
    slippage,
}: {
    from?: `0x${string}`;
    src?: string;
    dst?: string;
    amountIn?: string;
    slippage?: number;
}) => {
    const memoParams = useMemo(
        () => [from, src, dst, amountIn, slippage],
        [from, src, dst, amountIn, slippage],
    );
    const debounceParams = useDebounce(memoParams, 500);

    return useQuery<RouterData>(["aggregator-findRouter", ...(debounceParams ?? [])], {
        async queryFn() {
            const empty = {
                swaps: [],
                toAmount: 0n,
                tx: { data: "0x", from: "0x", to: "0x", value: 0n },
            };

            slippage ??= 0;
            if (!from || !src || !dst || !amountIn) return empty;

            const res = await fetch(
                `https://aggregator.icecreamswap.com/1116?src=${src}&dst=${dst}&amount=${amountIn}&from=${from}&slippage=${slippage}`,
            );

            if (res.ok) {
                const data = await res.json();
                data.toAmount = n2bi(data.toAmount);
                data.tx.value = n2bi(data.tx.value);
                return data;
            }

            return empty;
        },
        staleTime: 500,
        keepPreviousData: true,
    });
};



================================================
File: src/hooks/swap/useAllCurrencyCombinations.ts
================================================
import { BASES_TO_CHECK_TRADES_AGAINST } from "@/constants/routing";
import { Currency, Token } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { useChainId } from "wagmi";

export function useAllCurrencyCombinations(
    currencyA?: Currency,
    currencyB?: Currency,
): [Token, Token][] {
    const chainId = useChainId();

    const [tokenA, tokenB] = chainId
        ? [currencyA?.wrapped, currencyB?.wrapped]
        : [undefined, undefined];

    const bases: Token[] = useMemo(() => {
        if (!chainId) return [];

        return (BASES_TO_CHECK_TRADES_AGAINST[chainId].filter((t) => t) as Token[]) ?? [];
    }, [chainId]);

    const basePairs: [Token, Token][] = useMemo(
        () =>
            bases
                .filter((t) => t)
                .flatMap((base): [Token, Token][] => bases.map((otherBase) => [base, otherBase]))
                .filter(([t0, t1]) => !t0.equals(t1)),
        [bases],
    );

    return useMemo(
        () =>
            tokenA && tokenB
                ? [
                      [tokenA, tokenB] as [Token, Token],
                      ...bases.map((base): [Token, Token] => [tokenA, base]),
                      ...bases.map((base): [Token, Token] => [tokenB, base]),
                      ...basePairs,
                  ]
                      .filter(([t0, t1]) => !t0.equals(t1))
                      .filter(([t0, t1], i, otherPairs) => {
                          const firstIndexInOtherPairs = otherPairs.findIndex(
                              ([t0Other, t1Other]) => {
                                  return (
                                      (t0.equals(t0Other) && t1.equals(t1Other)) ||
                                      (t0.equals(t1Other) && t1.equals(t0Other))
                                  );
                              },
                          );
                          return firstIndexInOtherPairs === i;
                      })
                : [],
        [tokenA, tokenB, bases, basePairs, chainId],
    );
}



================================================
File: src/hooks/swap/useAllRoutes.ts
================================================
import { Currency, DEFAULT_TICK_SPACING, Pool, Route, Token } from "@glyph-exchange/integral-sdk"
import { useMemo } from "react"
import { useSwapPools } from "./useSwapPools"
import { Address, useChainId } from "wagmi"
import { useUserState } from "@/state/userStore"


/**
 * Returns true if poolA is equivalent to poolB
 * @param poolA one of the two pools
 * @param poolB the other pool
 */
function poolEquals(poolA: Pool, poolB: Pool): boolean {
    return (
        poolA === poolB ||
        (poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1))
    )
}

function computeAllRoutes(
    currencyIn: Currency,
    currencyOut: Currency,
    pools: { tokens: [Token, Token], pool: { address: Address, liquidity: string, price: string, tick: string, fee: string } }[],
    chainId: number,
    currentPath: Pool[] = [],
    allPaths: Route<Currency, Currency>[] = [],
    startCurrencyIn: Currency = currencyIn,
    maxHops = 2
): Route<Currency, Currency>[] {
    const tokenIn = currencyIn?.wrapped
    const tokenOut = currencyOut?.wrapped

    if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut')

    for (const pool of pools) {

        const [tokenA, tokenB] = pool.tokens

        const { liquidity, price, tick, fee } = pool.pool

        const newPool = new Pool(tokenA, tokenB, +fee as unknown as 100, price, liquidity, Number(tick), DEFAULT_TICK_SPACING)

        if (!newPool.involvesToken(tokenIn) || currentPath.find((pathPool) => poolEquals(newPool, pathPool))) continue

        const outputToken = newPool.token0.equals(tokenIn) ? newPool.token1 : newPool.token0
        if (outputToken.equals(tokenOut)) {
            allPaths.push(new Route([...currentPath, newPool], startCurrencyIn, currencyOut))
        } else if (maxHops > 1) {
            computeAllRoutes(
                outputToken,
                currencyOut,
                pools,
                chainId,
                [...currentPath, newPool],
                allPaths,
                startCurrencyIn,
                maxHops - 1
            )
        }
    }

    return allPaths
}

/**
 * Returns all the routes from an input currency to an output currency
 * @param currencyIn the input currency
 * @param currencyOut the output currency
 */
export function useAllRoutes(
    currencyIn?: Currency,
    currencyOut?: Currency
): { loading: boolean; routes: Route<Currency, Currency>[] } {

    const chainId = useChainId()

    const { pools, loading: poolsLoading } = useSwapPools(currencyIn, currencyOut)

    const { isMultihop } = useUserState();

    return useMemo(() => {
        if (poolsLoading || !chainId || !pools || !currencyIn || !currencyOut)
            return {
                loading: true,
                routes: [],
            }

        // Hack
        // const singleIfWrapped = (currencyIn.isNative || currencyOut.isNative)

        const routes = computeAllRoutes(
            currencyIn,
            currencyOut,
            pools,
            chainId,
            [],
            [],
            currencyIn,
            isMultihop ? 3 : 1
        )

        return { loading: false, routes }
    }, [chainId, currencyIn, currencyOut, pools, poolsLoading, isMultihop])
}



================================================
File: src/hooks/swap/useBestTrade.ts
================================================
import { Currency, CurrencyAmount, Route, Trade, TradeType } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { useAllRoutes } from "./useAllRoutes";
import { TradeState, TradeStateType } from "@/types/trade-state";
import { useQuotesResults } from "./useQuotesResults";


// const DEFAULT_GAS_QUOTE = 2_000_000

/**
 * Returns the best v3 trade for a desired exact input swap
 * @param amountIn the amount to swap in
 * @param currencyOut the desired output currency
 */
export function useBestTradeExactIn(
    amountIn?: CurrencyAmount<Currency>,
    currencyOut?: Currency
): { state: TradeStateType; trade: Trade<Currency, Currency, TradeType.EXACT_INPUT> | null; fee?: bigint[] | null, priceAfterSwap?: bigint[] | null } {

    const { routes, loading: routesLoading } = useAllRoutes(amountIn?.currency, currencyOut)

    const {
        data: quotesResults,
        isLoading: isQuotesLoading,
        refetch,
    } = useQuotesResults({
        exactInput: true,
        amountIn,
        currencyOut,
    });

    const trade = useMemo(() => {
        if (!amountIn || !currencyOut) {
            return {
                state: TradeState.INVALID,
                trade: null,
                refetch
            }
        }

        if (routesLoading || isQuotesLoading) {
            return {
                state: TradeState.LOADING,
                trade: null,
            }
        }

        const { bestRoute, amountOut, fee, priceAfterSwap } = (quotesResults || []).reduce(
            (currentBest: { bestRoute: Route<Currency, Currency> | null; amountOut: any | null; fee: bigint[] | null, priceAfterSwap: bigint[] | null }, { result }: any, i) => {
                if (!result) return currentBest

                if (currentBest.amountOut === null) {
                    return {
                        bestRoute: routes[i],
                        amountOut: result[0],
                        fee: result[5],
                        priceAfterSwap: result[2]
                    }
                } else if (currentBest.amountOut < result[0]) {
                    return {
                        bestRoute: routes[i],
                        amountOut: result[0],
                        fee: result[5],
                        priceAfterSwap: result[2]
                    }
                }

                return currentBest
            },
            {
                bestRoute: null,
                amountOut: null,
                fee: null,
                priceAfterSwap: null
            }
        )

        if (!bestRoute || !amountOut) {
            return {
                state: TradeState.NO_ROUTE_FOUND,
                trade: null,
                fee: null,
                priceAfterSwap: null
            }
        }

        return {
            state: TradeState.VALID,
            fee,
            trade: Trade.createUncheckedTrade({
                route: bestRoute,
                tradeType: TradeType.EXACT_INPUT,
                inputAmount: amountIn,
                outputAmount: CurrencyAmount.fromRawAmount(currencyOut, amountOut.toString()),
            }),
            priceAfterSwap,
            refetch
        }
    }, [amountIn, currencyOut, quotesResults, routes, routesLoading, isQuotesLoading, refetch])

    return trade
}

/**
 * Returns the best v3 trade for a desired exact output swap
 * @param currencyIn the desired input currency
 * @param amountOut the amount to swap out
 */
export function useBestTradeExactOut(
    currencyIn?: Currency,
    amountOut?: CurrencyAmount<Currency>
): { state: TradeStateType; trade: Trade<Currency, Currency, TradeType.EXACT_OUTPUT> | null; fee?: bigint[] | null, priceAfterSwap?: bigint[] | null } {

    const { routes, loading: routesLoading } = useAllRoutes(currencyIn, amountOut?.currency)

    const {
        data: quotesResults,
        isLoading: isQuotesLoading,
        refetch,
    } = useQuotesResults({
        exactInput: false,
        currencyIn,
        amountOut,
    });

    const trade = useMemo(() => {
        if (!amountOut || !currencyIn) {
            return {
                state: TradeState.INVALID,
                trade: null,
                refetch,
            };
        }

        if (routesLoading || isQuotesLoading) {
            return {
                state: TradeState.LOADING,
                trade: null,
            }
        }

        const { bestRoute, amountIn, fee, priceAfterSwap } = (quotesResults || []).reduce(
            (currentBest: { bestRoute: Route<Currency, Currency> | null; amountIn: any | null; fee: bigint[] | null, priceAfterSwap: bigint[] | null }, { result }: any, i) => {
                if (!result) return currentBest

                if (currentBest.amountIn === null) {
                    return {
                        bestRoute: routes[i],
                        amountIn: result[1],
                        fee: result[5],
                        priceAfterSwap: result[2]
                    }
                } else if (currentBest.amountIn > result[0]) {
                    return {
                        bestRoute: routes[i],
                        amountIn: result[1],
                        fee: result[5],
                        priceAfterSwap: result[2]
                    }
                }

                return currentBest
            },
            {
                bestRoute: null,
                amountIn: null,
                fee: null,
                priceAfterSwap: null
            }
        )

        if (!bestRoute || !amountIn) {
            return {
                state: TradeState.NO_ROUTE_FOUND,
                trade: null,
                fee: null,
                priceAfterSwap
            }
        }

        return {
            state: TradeState.VALID,
            fee,
            trade: Trade.createUncheckedTrade({
                route: bestRoute,
                tradeType: TradeType.EXACT_OUTPUT,
                inputAmount: CurrencyAmount.fromRawAmount(currencyIn, amountIn.toString()),
                outputAmount: amountOut,
            }),
            priceAfterSwap,
            refetch
        }
    }, [amountOut, currencyIn, quotesResults, routes, routesLoading, isQuotesLoading, refetch])


    return trade
}



================================================
File: src/hooks/swap/useQuotesResults.ts
================================================
import { algebraQuoterV2ABI } from '@/abis';
import { ALGEBRA_QUOTER_V2 } from '@/constants/addresses';
import {
    Currency,
    CurrencyAmount,
    encodeRouteToPath,
} from '@glyph-exchange/integral-sdk';
import { useMemo } from 'react';
import { useContractReads } from 'wagmi';
import { useAllRoutes } from './useAllRoutes';

export function useQuotesResults({
    exactInput,
    amountIn,
    amountOut,
    currencyIn,
    currencyOut,
}: {
    exactInput: boolean;
    amountIn?: CurrencyAmount<Currency>;
    amountOut?: CurrencyAmount<Currency>;
    currencyIn?: Currency;
    currencyOut?: Currency;
}) {
    const { routes, loading: routesLoading } = useAllRoutes(
        exactInput ? amountIn?.currency : currencyIn,
        !exactInput ? amountOut?.currency : currencyOut
    );

    const quoteInputs = useMemo(() => {
        return routes.map((route) => [
            encodeRouteToPath(route, !exactInput),
            exactInput
                ? amountIn
                    ? `0x${amountIn.quotient.toString(16)}`
                    : undefined
                : amountOut
                ? `0x${amountOut.quotient.toString(16)}`
                : undefined,
        ]);
    }, [amountIn, amountOut, routes, exactInput]);

    const functionName = exactInput ? 'quoteExactInput' : 'quoteExactOutput';

    const {
        data: quotesResults,
        isLoading,
        refetch,
    } = useContractReads({
        contracts: quoteInputs.map((quote: any) => ({
            address: ALGEBRA_QUOTER_V2,
            abi: algebraQuoterV2ABI,
            functionName: functionName,
            args: quote,
        })),
        watch: true,
        cacheTime: 5_000
    });

    return {
        data: quotesResults,
        isLoading: isLoading || routesLoading,
        refetch,
    };
}



================================================
File: src/hooks/swap/useSwapCallArguments.ts
================================================
import { useUserState } from "@/state/userStore";
import { Currency, Percent, SwapRouter, Trade, TradeType } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { useAccount } from "wagmi";

export function useSwapCallArguments(
    trade: Trade<Currency, Currency, TradeType> | undefined,
    allowedSlippage: Percent,
) {

    const { address: account } = useAccount()

    const { txDeadline } = useUserState()

    return useMemo(() => {

        if (!trade || !account) return []

        const swapMethods: any[] = []

        swapMethods.push(
            SwapRouter.swapCallParameters(trade, {
                feeOnTransfer: false,
                recipient: account,
                slippageTolerance: allowedSlippage,
                deadline: Date.now() + txDeadline * 1000
            })
        )

        if (trade.tradeType === TradeType.EXACT_INPUT) {
            swapMethods.push(
                SwapRouter.swapCallParameters(trade, {
                    feeOnTransfer: true,
                    recipient: account,
                    slippageTolerance: allowedSlippage,
                    deadline: Date.now() + txDeadline * 1000
                })
            )
        }

        return swapMethods.map(({ calldata, value }) => {
            return {
                calldata,
                value,
            }
        })

    }, [trade, account, txDeadline, allowedSlippage])


}


================================================
File: src/hooks/swap/useSwapCallback.ts
================================================
import { formatBalance } from "@/utils/common/formatBalance";
import { Currency, CurrencyAmount, Percent, Trade, TradeType } from "@glyph-exchange/integral-sdk";
import {
    Address,
    useAccount,
    useContractWrite,
    usePrepareSendTransaction,
    useSendTransaction,
} from "wagmi";
import { useSwapCallArguments } from "./useSwapCallArguments";
import { getAlgebraRouter, usePrepareAlgebraRouterMulticall } from "@/generated";
import { useEffect, useMemo, useState } from "react";
import { SwapCallbackState } from "@/types/swap-state";
import { useTransactionAwait } from "../common/useTransactionAwait";
import { ApprovalState, ApprovalStateType } from "@/types/approve-state";
import { TransactionType } from "@/state/pendingTransactionsStore";
import { RouterData } from "./useAggregatorData";
import { WrapType } from "./useWrapCallback";
import { DEFAULT_NATIVE_SYMBOL } from "@/constants/default-chain-id";

interface SwapCallEstimate {
    calldata: string;
    value: bigint;
}

interface SuccessfulCall extends SwapCallEstimate {
    calldata: string;
    value: bigint;
    gasEstimate: bigint;
}

interface FailedCall extends SwapCallEstimate {
    calldata: string;
    value: bigint;
    error: Error;
}

export function useSwapCallback(
    trade: Trade<Currency, Currency, TradeType> | undefined,
    allowedSlippage: Percent,
    approvalState: ApprovalStateType,
) {
    const { address: account } = useAccount();

    const [bestCall, setBestCall] = useState<any>();

    const swapCalldata = useSwapCallArguments(trade, allowedSlippage);

    useEffect(() => {
        async function findBestCall() {
            if (!swapCalldata || !account) return;

            setBestCall(undefined);

            const algebraRouter = getAlgebraRouter({});

            const calls = await Promise.all(
                swapCalldata.map(({ calldata, value: _value }) => {
                    const value = BigInt(_value);

                    return algebraRouter.estimateGas
                        .multicall([calldata], {
                            account,
                            value,
                        })
                        .then((gasEstimate) => ({
                            calldata,
                            value,
                            gasEstimate,
                        }))
                        .catch((gasError) => {
                            return algebraRouter.simulate
                                .multicall([calldata], {
                                    account,
                                    value,
                                })
                                .then(() => ({
                                    calldata,
                                    value,
                                    error: new Error(
                                        `Unexpected issue with estimating the gas. Please try again. ${gasError}`,
                                    ),
                                }))
                                .catch((callError) => ({
                                    calldata,
                                    value,
                                    error: new Error(callError),
                                }));
                        });
                }),
            );

            let bestCallOption: SuccessfulCall | SwapCallEstimate | undefined = calls.find(
                (el, ix, list): el is SuccessfulCall =>
                    "gasEstimate" in el &&
                    (ix === list.length - 1 || "gasEstimate" in list[ix + 1]),
            );

            if (!bestCallOption) {
                const errorCalls = calls.filter((call): call is FailedCall => "error" in call);
                if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error;
                const firstNoErrorCall = calls.find<any>((call): call is any => !("error" in call));
                if (!firstNoErrorCall)
                    throw new Error("Unexpected error. Could not estimate gas for the swap.");
                bestCallOption = firstNoErrorCall;
            }

            setBestCall(bestCallOption);
        }

        swapCalldata && findBestCall();
    }, [swapCalldata, approvalState, account]);

    const { config: swapConfig } = usePrepareAlgebraRouterMulticall({
        args: bestCall && [bestCall.calldata],
        value: BigInt(bestCall?.value || 0),
        enabled: Boolean(bestCall),
        gas: bestCall ? (bestCall.gasEstimate * (10000n + 2000n)) / 10000n : undefined,
    });

    const {
        data: swapData,
        writeAsync: swapCallback,
        isLoading: isConfirmLoading,
    } = useContractWrite(swapConfig);

    const { isLoading, isSuccess } = useTransactionAwait(swapData?.hash, {
        title: `Swap ${formatBalance(trade?.inputAmount.toSignificant() as string)} ${trade?.inputAmount.currency.symbol}`,
        tokenA: trade?.inputAmount.currency.wrapped.address as Address,
        tokenB: trade?.outputAmount.currency.wrapped.address as Address,
        type: TransactionType.SWAP,
    });

    return useMemo(() => {
        if (!trade)
            return {
                state: SwapCallbackState.INVALID,
                callback: null,
                error: "No trade was found",
                isLoading: false,
                isSuccess: false,
            };

        return {
            state: SwapCallbackState.VALID,
            callback: swapCallback,
            error: null,
            isLoading,
            isSuccess,
            confirmLoading: isConfirmLoading,
        };
    }, [trade, isLoading, swapCalldata, swapCallback, swapConfig, isSuccess]);
}

export const useAggregatorSwapCallback = (
    aggregatorData: RouterData | undefined,
    payAmount: CurrencyAmount<Currency> | undefined,
    receiveAmount: CurrencyAmount<Currency> | undefined,
    wrapType: string,
    approvalState: ApprovalStateType,
) => {
    const { config } = usePrepareSendTransaction({
        ...(aggregatorData?.tx ?? {}),
        enabled: approvalState === ApprovalState.APPROVED,
    });
    const {
        data: swapData,
        isLoading: isSwapConfirmLoading,
        sendTransactionAsync: swapCallback,
    } = useSendTransaction(config);

    const transactionTitle = useMemo(() => {
        if (wrapType === WrapType.WRAP)
            return `Wrap ${payAmount?.toSignificant(3)} ${DEFAULT_NATIVE_SYMBOL}`;
        else if (wrapType === WrapType.UNWRAP)
            return `Unwrap ${payAmount?.toSignificant(3)} W${DEFAULT_NATIVE_SYMBOL}`;
        else
            return `Swap ${formatBalance(payAmount?.toSignificant() as string)} ${payAmount?.currency.symbol}`;
    }, [wrapType, payAmount]);

    const { isLoading: isSwapLoading } = useTransactionAwait(swapData?.hash, {
        title: transactionTitle,
        tokenA: payAmount?.currency.wrapped.address as Address,
        tokenB:
            wrapType === WrapType.NOT_APPLICABLE
                ? (receiveAmount?.currency.wrapped.address as Address)
                : undefined,
        type: TransactionType.SWAP,
    });

    return { swapData, isSwapConfirmLoading, swapCallback, isSwapLoading };
};



================================================
File: src/hooks/swap/useSwapChart.ts
================================================
import { ApolloClient, InMemoryCache, gql } from "@apollo/client"

import dayjs from 'dayjs'
import { getBlocksFromTimestamps } from "@/graphql/utils/getBlocksFromTimestamps"

const mainnetInfoClient = new ApolloClient({
    uri: 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3',
    cache: new InMemoryCache(),
});

const mainnetBlocksClient = new ApolloClient({
    uri: 'https://api.thegraph.com/subgraphs/name/blocklytics/ethereum-blocks',
    cache: new InMemoryCache()
})

const CHART_STEPS = {
    day: 3600,
    week: 3600,
    month: 3600 * 24,
}

export function useSwapChart() {

    async function fetchPoolPriceData(address: string, span: 'day' | 'week' | 'month') {
        return fetchPriceData(address, span, 'pool')
    }

    async function fetchTokenPriceData(address: string, span: 'day' | 'week' | 'month') {
        return fetchPriceData(address, span, 'token')
    }

    async function fetchPriceData(
        address: string,
        span: 'day' | 'week' | 'month',
        field: string
    ): Promise<{
        data: any[]
        error: boolean
    }> {
        // start and end bounds

        const utcCurrentTime = dayjs()

        const startTimestamp = utcCurrentTime.subtract(1, span).startOf('hour').unix()

        const fetchEntity = span === 'day' || span === 'week' ? 'Hour' : 'Day'

        const timestamp = span === 'day' || span === 'week' ? 'periodStartUnix' : 'date'

        try {
            const endTimestamp = utcCurrentTime.unix()

            if (!startTimestamp) {
                console.log('Error constructing price start timestamp')
                return {
                    data: [],
                    error: false,
                }
            }

            const timestamps: any = []
            let time = startTimestamp
            while (time <= endTimestamp) {
                timestamps.push(time)
                time += CHART_STEPS[span]
            }

            if (timestamps.length === 0) {
                return {
                    data: [],
                    error: false,
                }
            }

            const blocks = await getBlocksFromTimestamps(timestamps, mainnetBlocksClient, 500)
            if (!blocks || blocks.length === 0) {
                console.log('Error fetching blocks')
                return {
                    data: [],
                    error: false,
                }
            }

            let data: {
                periodStartUnix: number
                high: string
                low: string
                open: string
                close: string
            }[] = []
            let skip = 0
            let allFound = false
            while (!allFound) {
                const {
                    data: priceData,
                    errors,
                    loading,
                } = await mainnetInfoClient.query<any>({
                    query: gql`
                        query ${field}${fetchEntity}Datas($startTime: Int!, $skip: Int!, $address: Bytes!) {
                            ${field}${fetchEntity}Datas(
                            first: 1000
                            skip: $skip
                            where: { ${field}: $address, ${timestamp}_gt: $startTime }
                            orderBy: ${timestamp}
                            orderDirection: asc
                          ) {
                            periodStartUnix: ${timestamp}
                            high
                            low
                            open
                            close
                            ${field === 'pool'
                            ? `token0Price
                            token1Price`
                            : 'priceUSD'
                        }
                          }
                        }
                      `,
                    variables: {
                        address: address.toLowerCase(),
                        startTime: startTimestamp,
                        skip,
                    },
                    fetchPolicy: 'no-cache',
                })

                if (!loading) {
                    skip += 100
                    if ((priceData && priceData[`${field}${fetchEntity}Datas`].length < 100) || errors) {
                        allFound = true
                    }
                    if (priceData) {
                        data = data.concat(priceData[`${field}${fetchEntity}Datas`])
                    }
                }
            }

            const periods = data.map((v) => v.periodStartUnix)

            return {
                data: data.filter((v, idx) => !periods.includes(v.periodStartUnix, idx + 1)),
                error: false,
            }
        } catch (e) {
            console.log(e)
            return {
                data: [],
                error: true,
            }
        }
    }


    return {
        fetchPoolPriceData, fetchTokenPriceData
    }

}


================================================
File: src/hooks/swap/useSwapPools.ts
================================================
import { Currency, Token, computePoolAddress } from "@glyph-exchange/integral-sdk"
import { useEffect, useMemo, useState } from "react"
import { useAllCurrencyCombinations } from "./useAllCurrencyCombinations"
import { Address } from "wagmi"
import { TokenFieldsFragment, useMultiplePoolsLazyQuery } from "@/graphql/generated/graphql"
import { DEFAULT_CHAIN_ID } from "@/constants/default-chain-id"

/**
 * Returns all the existing pools that should be considered for swapping between an input currency and an output currency
 * @param currencyIn the input currency
 * @param currencyOut the output currency
 */
export function useSwapPools(
    currencyIn?: Currency,
    currencyOut?: Currency
): {
    pools: { tokens: [Token, Token], pool: { address: Address, liquidity: string, price: string, tick: string, fee: string, token0: TokenFieldsFragment, token1: TokenFieldsFragment } }[]
    loading: boolean
} {

    const [existingPools, setExistingPools] = useState<any[]>()

    const allCurrencyCombinations = useAllCurrencyCombinations(currencyIn, currencyOut)

    const [getMultiplePools] = useMultiplePoolsLazyQuery()

    useEffect(() => {

        async function getPools() {

            const poolsAddresses = allCurrencyCombinations.map(([tokenA, tokenB]) => computePoolAddress({
                tokenA,
                tokenB
            }) as Address)

            const poolsData = await getMultiplePools({
                variables: {
                    poolIds: poolsAddresses.map(address => address.toLowerCase())
                }
            })

            // const poolsLiquidities = await Promise.allSettled(poolsAddresses.map(address => getAlgebraPool({
            //     address
            // }).read.liquidity()))

            // const poolsGlobalStates = await Promise.allSettled(poolsAddresses.map(address => getAlgebraPool({
            //     address
            // }).read.globalState()))

            const pools = poolsData.data && poolsData.data.pools.map(pool => ({ address: pool.id, liquidity: pool.liquidity, price: pool.sqrtPrice, tick: pool.tick, fee: pool.fee, token0: pool.token0, token1: pool.token1 }))

            setExistingPools(pools)

        }

        Boolean(allCurrencyCombinations.length) && getPools()

    }, [allCurrencyCombinations])

    return useMemo(() => {

        if (!existingPools) return {
            pools: [],
            loading: true
        }

        return {
            pools: existingPools.map((pool) => ({
                tokens: [
                    new Token(DEFAULT_CHAIN_ID, pool.token0.id, Number(pool.token0.decimals), pool.token0.symbol, pool.token0.name),
                    new Token(DEFAULT_CHAIN_ID, pool.token1.id, Number(pool.token1.decimals), pool.token1.symbol, pool.token1.name)
                ] as [Token, Token],
                pool: pool
            }))
                .filter(({ pool }) => {
                    return pool
                }),
            loading: false
        }
    }, [existingPools])
}



================================================
File: src/hooks/swap/useSwapSlippageTolerance.ts
================================================
import { useUserSlippageToleranceWithDefault } from "@/state/userStore"
import { Currency, Percent, Trade, TradeType } from "@glyph-exchange/integral-sdk"
import { useMemo } from "react"

const SWAP_DEFAULT_SLIPPAGE = new Percent(50, 10_000) // .50%
const ONE_TENTHS_PERCENT = new Percent(10, 10_000) // .10%

export default function useSwapSlippageTolerance(
    trade: Trade<Currency, Currency, TradeType> | undefined
): Percent {

    const defaultSlippageTolerance = useMemo(() => {
        if (!trade) return ONE_TENTHS_PERCENT
        return SWAP_DEFAULT_SLIPPAGE
    }, [trade])


    return useUserSlippageToleranceWithDefault(defaultSlippageTolerance)
}


================================================
File: src/hooks/swap/useWrapCallback.ts
================================================
import { WNATIVE_EXTENDED } from "@/constants/routing";
import { usePrepareWrappedNativeDeposit, usePrepareWrappedNativeWithdraw } from "@/generated";
import { Currency, WNATIVE, tryParseAmount } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { Address, useAccount, useBalance, useChainId, useContractWrite } from "wagmi";
import { useTransactionAwait } from "../common/useTransactionAwait";
import { DEFAULT_NATIVE_SYMBOL } from "@/constants/default-chain-id";
import { TransactionType } from "@/state/pendingTransactionsStore";

export const WrapType = {
    NOT_APPLICABLE: "NOT_APPLICABLE",
    WRAP: "WRAP",
    UNWRAP: "UNWRAP",
};

const NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };

export default function useWrapCallback(
    inputCurrency: Currency | undefined,
    outputCurrency: Currency | undefined,
    typedValue: string | undefined,
): {
    wrapType: (typeof WrapType)[keyof typeof WrapType];
    execute?: undefined | (() => void);
    loading?: boolean;
    inputError?: string;
    confirmLoading?: boolean;
} {
    const chainId = useChainId();
    const { address: account } = useAccount();

    const inputAmount = useMemo(
        () => tryParseAmount(typedValue, inputCurrency),
        [inputCurrency, typedValue],
    );

    const { config: wrapConfig } = usePrepareWrappedNativeDeposit({
        address: WNATIVE[chainId].address as Address,
        value: inputAmount ? BigInt(inputAmount.quotient.toString()) : undefined,
    });

    const {
        data: wrapData,
        write: wrap,
        isLoading: isWrapConfirmLoading,
    } = useContractWrite(wrapConfig);

    const { isLoading: isWrapLoading } = useTransactionAwait(wrapData?.hash, {
        title: `Wrap ${inputAmount?.toSignificant(3)} ${DEFAULT_NATIVE_SYMBOL}`,
        tokenA: WNATIVE[chainId].address as Address,
        type: TransactionType.SWAP,
    });

    const { config: unwrapConfig } = usePrepareWrappedNativeWithdraw({
        address: WNATIVE[chainId].address as Address,
        args: inputAmount ? [BigInt(inputAmount.quotient.toString())] : undefined,
    });

    const {
        data: unwrapData,
        write: unwrap,
        isLoading: isUnwrapConfirmLoading,
    } = useContractWrite(unwrapConfig);

    const { isLoading: isUnwrapLoading } = useTransactionAwait(unwrapData?.hash, {
        title: `Unwrap ${inputAmount?.toSignificant(3)} W${DEFAULT_NATIVE_SYMBOL}`,
        tokenA: WNATIVE[chainId].address as Address,
        type: TransactionType.SWAP,
    });

    const { data: balance } = useBalance({
        enabled: Boolean(inputCurrency),
        address: account,
        token: inputCurrency?.isNative ? undefined : (inputCurrency?.address as Address),
    });

    return useMemo(() => {
        if (!chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;
        const weth = WNATIVE_EXTENDED[chainId];
        if (!weth) return NOT_APPLICABLE;

        const hasInputAmount = Boolean(inputAmount?.greaterThan("0"));
        const sufficientBalance =
            inputAmount &&
            balance &&
            Number(balance.formatted) >= Number(inputAmount.toSignificant(18));

        if (inputCurrency.isNative && weth.equals(outputCurrency)) {
            return {
                wrapType: WrapType.WRAP,
                execute: sufficientBalance && inputAmount ? wrap : undefined,
                loading: isWrapLoading,
                confirmLoading: isWrapConfirmLoading,
                inputError: sufficientBalance
                    ? undefined
                    : hasInputAmount
                      ? `Insufficient Balance`
                      : `Input Amount`,
            };
        } else if (weth.equals(inputCurrency) && outputCurrency.isNative) {
            return {
                wrapType: WrapType.UNWRAP,
                execute: sufficientBalance && inputAmount ? unwrap : undefined,
                loading: isUnwrapLoading,
                confirmLoading: isUnwrapConfirmLoading,
                inputError: sufficientBalance
                    ? undefined
                    : hasInputAmount
                      ? `Insufficient Balance`
                      : `Input Amount`,
            };
        } else {
            return NOT_APPLICABLE;
        }
    }, [
        chainId,
        inputCurrency,
        outputCurrency,
        inputAmount,
        balance,
        isWrapLoading,
        isUnwrapLoading,
        wrap,
        unwrap,
        isWrapConfirmLoading,
        isUnwrapConfirmLoading,
    ]);
}

export function useAggregatorWrap(
    inputCurrency: Currency | undefined,
    outputCurrency: Currency | undefined,
) {
    const chainId = useChainId();
    return useMemo(() => {
        if (!chainId || !inputCurrency || !outputCurrency) return WrapType.NOT_APPLICABLE;
        const weth = WNATIVE_EXTENDED[chainId];
        if (inputCurrency.isNative && weth.equals(outputCurrency)) return WrapType.WRAP;
        else if (weth.equals(inputCurrency) && outputCurrency.isNative) return WrapType.UNWRAP;
        else return WrapType.NOT_APPLICABLE;
    }, [inputCurrency, outputCurrency, chainId]);
}



================================================
File: src/hooks/tokens/useAllTokens.ts
================================================
import { ADDRESSES } from "@/constants/addresses";
import { DEFAULT_NATIVE_NAME, DEFAULT_NATIVE_SYMBOL } from "@/constants/default-chain-id";
import { TokenFieldsFragment, useAllTokensQuery } from "@/graphql/generated/graphql";
import { useTokensState } from "@/state/tokensStore";
import { ADDRESS_ZERO } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { Address } from "viem";
import { useChainId } from "wagmi";

export function useAllTokens(showNativeToken: boolean = true) {
    const chainId = useChainId();

    const { data: allTokens, loading } = useAllTokensQuery();

    const { importedTokens } = useTokensState();

    const tokensBlackList: Address[] = useMemo(
        () => [ADDRESSES.GP, ADDRESSES.dualCORELP /* , ADDRESSES.aBTC */],
        [],
    );

    const mergedTokens = useMemo(() => {
        const tokens = new Map<Address, TokenFieldsFragment>();

        if (!allTokens) {
            const _importedTokens = Object.values(importedTokens[chainId] || []);
            for (const token of _importedTokens) {
                tokens.set(token.id.toLowerCase() as Address, {
                    ...token,
                    derivedMatic: 0,
                });
            }
            return [...tokens].map(([, token]) => ({ ...token }));
        }

        if (showNativeToken)
            tokens.set(ADDRESS_ZERO, {
                id: ADDRESS_ZERO,
                symbol: DEFAULT_NATIVE_SYMBOL,
                name: DEFAULT_NATIVE_NAME,
                decimals: 18,
                derivedMatic: 1,
            });

        for (const token of allTokens.tokens.filter(
            (token) => !tokensBlackList.includes(token.id.toLowerCase() as Address),
        )) {
            tokens.set(token.id.toLowerCase() as Address, { ...token });
        }

        const _importedTokens = Object.values(importedTokens[chainId] || []);

        for (const token of _importedTokens.filter(
            (t) => !tokensBlackList.includes(t.id.toLowerCase() as Address),
        )) {
            tokens.set(token.id.toLowerCase() as Address, {
                ...token,
                derivedMatic: 0,
            });
        }

        return [...tokens].map(([, token]) => ({ ...token }));
    }, [allTokens, importedTokens, tokensBlackList, chainId, showNativeToken]);

    return useMemo(
        () => ({
            tokens: mergedTokens,
            isLoading: loading || Boolean(allTokens && !mergedTokens.length),
        }),
        [mergedTokens, allTokens, loading],
    );
}



================================================
File: src/lib/utils.ts
================================================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

export const abbreviate = (str?: string, { prefix = 6, omit = 4, suffix = 4 } = {}) => {
    if (!str) return "";
    return str.slice(0, prefix) + ".".repeat(omit) + str.slice(-suffix);
};



================================================
File: src/pages/index.ts
================================================
export * from './Swap/index'
export * from './Page404/index'
export * from './Pools/index'


================================================
File: src/pages/CreatePool/index.tsx
================================================
import Image from "@/components/common/Image";
import PageSelector from "@/components/common/PageSelector";
import PanelBase from "@/components/common/Panel/PanelBase";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import CreatePoolForm from "@/components/create-pool/CreatePoolForm";
import tw, { styled } from "twin.macro";

const items = [
    {
        name: (
            <div className="flex items-center gap-[4px]">
                V2 Pools <Image width={16} height={16} src="/link.svg" alt="" />
            </div>
        ),
        action() {
            window.open("https://app.glyph.exchange/pool/v2/create");
        },
    },
    {
        name: "V4 Pools",
        active: true,
    },
];

const _CreatePoolPage = styled.div`
    ${() => tw`mx-auto max-w-[434px] pt-[50px] m:w-full m:pt-[20px]`}
`;

const CreatePoolPage = () => {
    return (
        <_CreatePoolPage>
            <PageSelector items={items} />

            <PanelBase className="mt-[24px] m:mt-[20px]">
                <PanelTitle title="CREATE POOL" />
                <PanelContainer>
                    <CreatePoolForm />
                </PanelContainer>
                <PanelFooter />
            </PanelBase>
        </_CreatePoolPage>
    );
};

export default CreatePoolPage;



================================================
File: src/pages/NewPosition/index.tsx
================================================
import PageContainer from "@/components/common/PageContainer";
import LiquidityChart from "@/components/create-position/LiquidityChart";
import RangeSelector from "@/components/create-position/RangeSelector";
import PresetTabs from "@/components/create-position/PresetTabs";
import { useAlgebraPoolToken0, useAlgebraPoolToken1 } from "@/generated";
import {
    IDerivedMintInfo,
    useDerivedMintInfo,
    useMintActionHandlers,
    useMintState,
    useRangeHopCallbacks,
} from "@/state/mintStore";
import { Bound, Currency, INITIAL_POOL_FEE } from "@glyph-exchange/integral-sdk";
import { memo, useEffect, useMemo, useState } from "react";
import AmountsSection from "@/components/create-position/AmountsSection";
import { ManageLiquidity } from "@/types/manage-liquidity";
import { useCurrency } from "@/hooks/common/useCurrency";
import Banner from "@/components/common/Banner";
import PanelBase from "@/components/common/Panel/PanelBase";
import tw, { styled } from "twin.macro";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import PanelContainer from "@/components/common/Panel/PanelContainer";
import PanelFooter from "@/components/common/Panel/PanelFooter";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { PositionManager } from "@/types/position-state";
import { useCheckPool } from "@/hooks/common/useGamma";
import Checkbox from "@/components/common/Checkbox";
import { Skeleton } from "@/components/ui/skeleton";
import { useNavigate } from "react-router-dom";
import { Address } from "viem";
import { BLACKLIST_POOLS } from "@/components/pools/PoolsList/blacklistPools";

const _SelectPriceRangePanelBase = styled(PanelBase)`
    ${() => tw`col-span-6 items-center`}
`;

const _CurrentPriceStyle = styled.div`
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    word-break: break-word;

    ${() => tw``}
`;

const _ManualCard = styled.div`
    ${() => tw`w-full`}
`;
const AlgebraCard: FCProps<{
    currencyA: Currency | undefined;
    currencyB: Currency | undefined;
    mintInfo: IDerivedMintInfo;
}> = memo(({ className, style, mintInfo, currencyA, currencyB }) => {
    const isMobile = useMediaQuery("mobile");

    const { [Bound.LOWER]: priceLower, [Bound.UPPER]: priceUpper } = mintInfo.pricesAtTicks;

    const price = useMemo(() => {
        if (!mintInfo.price) return;

        return mintInfo.invertPrice
            ? mintInfo.price.invert().toSignificant(5)
            : mintInfo.price.toSignificant(5);
    }, [mintInfo]);

    const currentPrice = useMemo(() => {
        if (!mintInfo.price) return;

        if (Number(price) <= 0.0001) {
            return `< 0.0001 ${currencyB?.symbol}`;
        } else {
            return `${price} ${currencyB?.symbol}`;
        }
    }, [mintInfo.price, price, currencyB]);

    const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = useMemo(() => {
        return mintInfo.ticks;
    }, [mintInfo]);

    const { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper } =
        useRangeHopCallbacks(
            currencyA ?? undefined,
            currencyB ?? undefined,
            mintInfo.tickSpacing,
            tickLower,
            tickUpper,
            mintInfo.pool,
        );

    const { onLeftRangeInput, onRightRangeInput } = useMintActionHandlers(mintInfo.noLiquidity);

    const { startPriceTypedValue } = useMintState();

    useEffect(() => {
        return () => {
            onLeftRangeInput("");
            onRightRangeInput("");
        };
    }, []);

    return (
        <_ManualCard className={className} style={style}>
            <div className="mb-[3px] w-full bg-[#F5F5F5] [border-bottom:1px_solid_#000] [padding:26px_23px] m:[padding:24px_20px]">
                <PresetTabs currencyA={currencyA} currencyB={currencyB} mintInfo={mintInfo} />
            </div>

            <div className="flex w-full flex-col items-center px-[24px] py-[32px] [border-top:1px_solid_#000] m:px-[20px] m:py-[20px]">
                <div className="flex w-full flex-col gap-[20px] md:flex-row m:gap-[24px]">
                    <RangeSelector
                        priceLower={priceLower}
                        priceUpper={priceUpper}
                        getDecrementLower={getDecrementLower}
                        getIncrementLower={getIncrementLower}
                        getDecrementUpper={getDecrementUpper}
                        getIncrementUpper={getIncrementUpper}
                        onLeftRangeInput={onLeftRangeInput}
                        onRightRangeInput={onRightRangeInput}
                        currencyA={currencyA}
                        currencyB={currencyB}
                        mintInfo={mintInfo}
                        disabled={!startPriceTypedValue && !mintInfo.price}
                    />
                    <div className="flex min-w-[154px] max-w-[198px] flex-col items-end gap-[18px] font-[FraktionMono-Bold] font-bold text-[#000] m:min-w-[unset] m:max-w-[unset] m:items-start m:gap-[12px]">
                        <div className="text-[14px] leading-[1]">CURRENT PRICE</div>
                        <_CurrentPriceStyle className="w-[100%] text-right text-[24px] leading-[1.2] m:text-left m:text-[20px]">{`${currentPrice}`}</_CurrentPriceStyle>
                    </div>
                </div>

                <LiquidityChart
                    currencyA={currencyA}
                    currencyB={currencyB}
                    currentPrice={price ? parseFloat(price) : undefined}
                    priceLower={priceLower}
                    priceUpper={priceUpper}
                    height={isMobile ? 179 : 395}
                    className="mt-[30px] !h-[395px] m:mt-[24px] m:!h-[179px]"
                />
            </div>
        </_ManualCard>
    );
});

const _GammaCard = styled.div`
    ${() => tw`w-full text-black`}
`;
const GammaCard: FCProps = memo(({ className, style }) => {
    const { hypervisor } = useMintState();
    const isMobile = useMediaQuery("mobile");
    const [preset, setPreset] = useState("Automatic");
    const [projectType, setProjectType] = useState(PositionManager.GAMMA);

    return (
        <_GammaCard className={className} style={style}>
            <div className="flex w-full items-center justify-start bg-[#F5F5F5] [border-bottom:1px_solid_#000] [padding:27px_23px_26px] m:[padding:24px_20px]">
                <Checkbox key={`preset-range-${preset}`} checked={preset === "Automatic"}>
                    {preset}
                </Checkbox>
            </div>
            <div className="mt-[4px] flex w-full items-center justify-start bg-[#F5F5F5] [border-bottom:1px_solid_#000] [border-top:1px_solid_#000] [padding:20px_23px_23px] m:mt-[3px] m:[padding:24px_20px]">
                <Checkbox key={`preset-range-${projectType}`} checked={projectType === projectType}>
                    <div className="flex items-center gap-[4px]">
                        Gamma
                        <img
                            width={isMobile ? 14 : 19}
                            height={isMobile ? 14 : 19}
                            src={"/gamma-icon.svg"}
                            alt=""
                        />
                    </div>
                </Checkbox>
            </div>
            <div className="flex w-full flex-col items-start [padding:20px_24px_34px] m:[padding:24px_20px]">
                <div className="flex items-center gap-[16px] m:gap-[8px]">
                    <div className="flex items-center gap-[8px] rounded-[6px] bg-[#000] px-[16px] font-[Geneva] font-normal leading-[35px] b1 m:gap-[4px] m:px-[12px] m:leading-[33px]">
                        <span className="text-[14px] text-[#FFF] m:text-[12px]">Narrow</span>
                        <span className="text-[10px] text-[#FF6B00] m:text-[12px]">
                            {hypervisor ? (hypervisor.returns.allTime.feeApr * 100).toFixed(2) : 0}%
                            APR
                        </span>
                    </div>
                </div>

                <div className="mt-[24px] flex w-full items-end bg-[#FFF0DA] [padding:0px_21px_0px_24px] m:flex-col m:items-start m:[padding:20px_20px_0px]">
                    <div className="flex flex-col items-start gap-[16px] [padding:20px_0px_18px_0px] m:gap-[20px] m:[padding:0px_0px_3px]">
                        <div className="flex items-center font-[FraktionMono-Bold] text-[16px] font-bold leading-[1] text-[#000] m:text-[14px]">
                            <span>Sit Back & Enjoy</span>
                            <span className="text-[#FF6B00]">&nbsp;Higher APR</span>
                        </div>
                        <div className="flex flex-col items-start font-[Geneva] text-[12px] font-normal leading-[1.3] text-[#000]">
                            <span>We take care of your liquidity position!</span>
                            <span className="text-start">
                                Liquidity ranges are automatically rebalanced when certain rebalance
                                triggers are met.
                                <a
                                    href="https://app.gamma.xyz/dashboard/glyph/core"
                                    target={"_blank"}
                                    className="underline"
                                >
                                    Learn more about Gamma
                                </a>
                            </span>
                        </div>
                    </div>
                    <img
                        width={isMobile ? 92 : 130}
                        height={isMobile ? 75 : 106}
                        src="/robot-icon.svg"
                        alt=""
                    />
                </div>

                <img src="/gamma-chart.svg" alt="" className="mt-[20px] w-full" />
            </div>
        </_GammaCard>
    );
});

const Page: FCProps<{ poolAddress?: `0x${string}`; positionManager: PositionManager }> = memo(
    ({ poolAddress, positionManager }) => {
        const { data: token0 } = useAlgebraPoolToken0({
            address: poolAddress,
        });

        const { data: token1 } = useAlgebraPoolToken1({
            address: poolAddress,
        });

        const currencyA = useCurrency(token0, true, positionManager === PositionManager.GAMMA);
        const currencyB = useCurrency(token1, true, positionManager === PositionManager.GAMMA);

        const mintInfo = useDerivedMintInfo(
            currencyA ?? undefined,
            currencyB ?? undefined,
            poolAddress,
            INITIAL_POOL_FEE,
            currencyA ?? undefined,
            undefined,
        );

        const CurrentCard = useMemo(() => {
            if (positionManager === PositionManager.ALGEBRA)
                return (
                    <AlgebraCard currencyA={currencyA} currencyB={currencyB} mintInfo={mintInfo} />
                );
            else if (positionManager === PositionManager.GAMMA) return <GammaCard />;
        }, [positionManager, currencyA, currencyB, mintInfo]);

        return (
            <>
                <PageContainer className="!items-center gap-[20px]">
                    <Banner
                        title={<span>Create Position</span>}
                        description={
                            <>
                                Create positions into pools to earn{" "}
                                <span className="text-[#F7931A]">Swap Fees</span> &{" "}
                                <span className="text-[#9747FF]">Extra Incentives</span>
                            </>
                        }
                        className="w-[100%] lg:w-[79.5%]"
                    />

                    <div className="grid w-full grid-cols-1 items-start gap-x-0 gap-y-[19px] lg:grid-cols-10 lg:gap-[19px]">
                        <_SelectPriceRangePanelBase>
                            <PanelTitle title="1.SELECT PRICE RANGE" />

                            {CurrentCard}
                        </_SelectPriceRangePanelBase>

                        <PanelBase className="col-span-4">
                            <PanelTitle title="2. Enter Amounts" />
                            <PanelContainer>
                                <AmountsSection
                                    currencyA={currencyA}
                                    currencyB={currencyB}
                                    mintInfo={mintInfo}
                                    manageLiquidity={ManageLiquidity.ADD}
                                />
                            </PanelContainer>
                            <PanelFooter />
                        </PanelBase>
                    </div>
                </PageContainer>
            </>
        );
    },
);

const LoadingState = () => (
    <div className="flex flex-col gap-4 p-4 w-full">
        {[1, 2, 3, 4].map((v) => (
            <Skeleton
                key={`position-skeleton-${v}`}
                className="h-[50px] w-full rounded-xl bg-[#999]"
            />
        ))}
    </div>
);

const NewPositionPage = () => {
    const { inited, poolAddress, positionManager } = useCheckPool();
    const navigate = useNavigate();

    useEffect(() => {
        if (poolAddress && BLACKLIST_POOLS.includes(poolAddress.toLowerCase() as Address)) {
            navigate("/pools");
        }
    }, [poolAddress]);

    return inited ? (
        <Page poolAddress={poolAddress} positionManager={positionManager} />
    ) : (
        <LoadingState />
    );
};

export default NewPositionPage;



================================================
File: src/pages/Page404/index.tsx
================================================
import { useRouteError } from "react-router-dom";

interface RouteError { 
    statusText: string; 
    message: string; 
}

const Page404 = () => {

    const error = useRouteError() as RouteError;

    console.error(error);

    return (
        <div id="error-page">
            <h1>Oops!</h1>
            <p>Sorry, an unexpected error has occurred.</p>
            <p>
                <i>{error?.statusText || error?.message}</i>
            </p>
        </div>
    );

}

export default Page404;


================================================
File: src/pages/Pool/index.tsx
================================================
import PageContainer from "@/components/common/PageContainer";
import ActiveFarming from "@/components/farming/ActiveFarming";
import MyPositions from "@/components/pool/MyPositions";
import MyPositionsToolbar from "@/components/pool/MyPositionsToolbar";
import PoolHeader from "@/components/pool/PoolHeader";
import PositionCard from "@/components/position/PositionCard";
import { Skeleton } from "@/components/ui/skeleton";
import {
    useNativePriceQuery,
    usePoolFeeDataQuery,
    useSinglePoolQuery,
} from "@/graphql/generated/graphql";
import { useActiveFarming } from "@/hooks/farming/useActiveFarming";
import { useClosedFarmings } from "@/hooks/farming/useClosedFarmings";
import { usePool } from "@/hooks/pools/usePool";
import { usePositions, useUserGammaPositions } from "@/hooks/positions/usePositions";
import { FormattedPosition } from "@/types/formatted-position";
import { getPositionAPR } from "@/utils/positions/getPositionAPR";
import { getPositionFees } from "@/utils/positions/getPositionFees";
import { formatAmount } from "@/utils/common/formatAmount";
import { Position, ZERO } from "@glyph-exchange/integral-sdk";
import { useWeb3Modal, useWeb3ModalState } from "@web3modal/wagmi/react";
import { useEffect, useMemo, useState } from "react";
import { Link, useNavigate, useParams } from "react-router-dom";
import { Address, useAccount } from "wagmi";
import JSBI from "jsbi";
import tw, { styled, theme } from "twin.macro";
import PanelTitle from "@/components/common/Panel/PanelTitle";
import PanelBase from "@/components/common/Panel/PanelBase";
import Image from "@/components/common/Image";
import { DEFAULT_CHAIN_ID, DEFAULT_CHAIN_NAME } from "@/constants/default-chain-id";
import { useMediaQuery } from "@/hooks/common/useMediaQuery";
import { useCheckPool } from "@/hooks/common/useGamma";
import { PositionManager } from "@/types/position-state";
import { useMintState } from "@/state/mintStore";
import { useGammaHypervisorGetBasePosition } from "@/generated";
import { BLACKLIST_POOLS } from "@/components/pools/PoolsList/blacklistPools";

const _PanelBase = styled(PanelBase)`
    ${() => tw`animate-fade-in items-start`}
`;

const _MyPositionsPanelBase = styled(PanelBase)`
    ${() => tw`items-start`}
`;

const _PositionBtn = styled.div`
    display: inline-flex;
    padding: 0 16px;
    justify-content: center;
    align-items: center;
    border-radius: 6px;
    border: 1px solid #000;
    background: #000;
    cursor: pointer;
    margin-top: 24px;

    color: #fff;
    font-family: Geneva;
    font-size: 14px;
    font-weight: 400;
    line-height: 35px;
    ${() => tw``}

    @media (max-width: ${theme`screens.mobile.max`}) {
        padding: 0 12px;
        font-size: 12px;
        line-height: 31px;
    }
`;

const PoolPage = ({
    poolId,
    associatePoolId,
    positionManager,
}: {
    poolId: Address;
    associatePoolId: Address;
    positionManager: PositionManager;
}) => {
    const { address: account } = useAccount();
    const { hypervisor } = useMintState();

    const { selectedNetworkId } = useWeb3ModalState();

    const isWrongChain = selectedNetworkId !== DEFAULT_CHAIN_ID;

    const [selectedPositionId, selectPosition] = useState<number | null>();

    const [, poolEntity] = usePool(associatePoolId);

    const { data: poolInfo } = useSinglePoolQuery({
        variables: {
            poolId: associatePoolId,
        },
    });

    const { data: poolFeeData } = usePoolFeeDataQuery({
        variables: {
            poolId: associatePoolId,
        },
    });

    const { data: bundles } = useNativePriceQuery();
    const nativePrice = bundles?.bundles[0].maticPriceUSD;

    const { farmingInfo, deposits, isFarmingLoading, areDepositsLoading } = useActiveFarming({
        poolId: poolId,
        poolInfo: poolInfo,
        enabled: positionManager === PositionManager.GAMMA ? false : true,
    });

    const { closedFarmings } = useClosedFarmings({
        poolId: poolId,
        poolInfo: poolInfo,
        enabled: positionManager === PositionManager.GAMMA ? false : true,
    });

    const [positionsFees, setPositionsFees] = useState<any>();
    const [positionsAPRs, setPositionsAPRs] = useState<any>();

    const { positions, loading: positionsLoading } = usePositions(
        positionManager === PositionManager.GAMMA ? false : true,
    );

    const { data: gammatBasePosition } = useGammaHypervisorGetBasePosition({
        address: poolId,
        enabled: positionManager === PositionManager.GAMMA ? true : false,
    });

    const { positions: gammaPositions, loading: gammaPositionsLoading } = useUserGammaPositions(
        positionManager === PositionManager.GAMMA ? true : false,
    );

    const filteredPositions = useMemo(() => {
        if (!positions || !poolEntity) return [];

        return positions
            .filter(({ pool }) => pool.toLowerCase() === associatePoolId.toLowerCase())
            .map((position) => ({
                positionId: position.tokenId,
                position: new Position({
                    pool: poolEntity,
                    liquidity: position.liquidity.toString(),
                    tickLower: Number(position.tickLower),
                    tickUpper: Number(position.tickUpper),
                }),
            }));
    }, [positions, poolEntity, associatePoolId]);

    useEffect(() => {
        async function getPositionsFees() {
            const fees = await Promise.all(
                filteredPositions.map(({ positionId, position }) =>
                    getPositionFees(position.pool, positionId),
                ),
            );
            setPositionsFees(fees);
        }

        if (filteredPositions) getPositionsFees();
    }, [filteredPositions]);

    useEffect(() => {
        async function getPositionsAPRs() {
            const aprs = await Promise.all(
                filteredPositions.map(({ position }) =>
                    getPositionAPR(
                        poolId,
                        position,
                        poolInfo?.pool,
                        poolFeeData?.poolDayDatas,
                        nativePrice,
                    ),
                ),
            );
            setPositionsAPRs(aprs);
        }

        if (
            filteredPositions &&
            poolInfo?.pool &&
            poolFeeData?.poolDayDatas &&
            bundles?.bundles &&
            associatePoolId
        )
            getPositionsAPRs();
    }, [filteredPositions, poolInfo, associatePoolId, poolFeeData, bundles]);

    const formatLiquidityUSD = (position: Position) => {
        if (!poolInfo?.pool) return 0;

        const amount0USD =
            Number(position.amount0.toSignificant()) *
            (Number(poolInfo.pool.token0.derivedMatic) * (Number(nativePrice) || 0));
        const amount1USD =
            Number(position.amount1.toSignificant()) *
            (Number(poolInfo.pool.token1.derivedMatic) * (Number(nativePrice) || 0));

        return amount0USD + amount1USD;
    };

    const formatFeesUSD = (idx: number) => {
        if (!positionsFees || !positionsFees[idx] || !poolInfo?.pool) return 0;

        const fees0USD = positionsFees[idx][0]
            ? Number(positionsFees[idx][0].toSignificant()) *
              (Number(poolInfo.pool.token0.derivedMatic) * Number(nativePrice))
            : 0;
        const fees1USD = positionsFees[idx][1]
            ? Number(positionsFees[idx][1].toSignificant()) *
              (Number(poolInfo.pool.token1.derivedMatic) * Number(nativePrice))
            : 0;

        return fees0USD + fees1USD;
    };

    const formatAPR = (idx: number) => {
        if (!positionsAPRs || !positionsAPRs[idx]) return 0;
        return positionsAPRs[idx];
    };

    const positionsData = useMemo(() => {
        if (positionManager === PositionManager.GAMMA && poolEntity && gammatBasePosition) {
            const curPositions = gammaPositions.filter(({ gammaPoolId }) => {
                return gammaPoolId && gammaPoolId.toLowerCase() === poolId.toLowerCase();
            });
            return curPositions.map((item) => {
                if (item.hypervisor) {
                    const curPosition = new Position({
                        pool: poolEntity,
                        liquidity: gammatBasePosition[0].toString(),
                        tickLower: Number(item.hypervisor.baseLower),
                        tickUpper: Number(item.hypervisor.baseUpper),
                    });

                    return {
                        ...item,
                        outOfRange:
                            poolEntity.tickCurrent < item.hypervisor.baseLower ||
                            poolEntity.tickCurrent > item.hypervisor.baseUpper,
                        range: `${formatAmount(curPosition.token0PriceLower.toFixed(6), 6)} — ${formatAmount(curPosition.token0PriceUpper.toFixed(6), 6)}`,
                        positionEntity: curPosition,
                    };
                } else {
                    return item;
                }
            });
        }
        if (!filteredPositions || !poolEntity || !deposits) return [];

        return filteredPositions.map(({ positionId, position }, idx) => {
            const currentPosition = deposits.deposits.find(
                (deposit) => Number(deposit.id) === Number(positionId),
            );

            return {
                id: positionId,
                isClosed: JSBI.EQ(position.liquidity, ZERO),
                outOfRange:
                    poolEntity.tickCurrent < position.tickLower ||
                    poolEntity.tickCurrent > position.tickUpper,
                range: `${formatAmount(position.token0PriceLower.toFixed(6), 6)} — ${formatAmount(position.token0PriceUpper.toFixed(6), 6)}`,
                liquidityUSD: formatLiquidityUSD(position),
                feesUSD: formatFeesUSD(idx),
                apr: formatAPR(idx),
                inFarming: Boolean(currentPosition?.eternalFarming),
            } as FormattedPosition;
        });
    }, [
        filteredPositions,
        poolEntity,
        poolInfo,
        positionsFees,
        positionsAPRs,
        deposits,
        gammaPositions,
        positionManager,
        gammatBasePosition,
        poolId,
    ]);

    const selectedPosition = useMemo(() => {
        if (!positionsData || !selectedPositionId) return;

        return positionsData.find(({ id }) => Number(id) === Number(selectedPositionId));
    }, [selectedPositionId, positionsData]);

    const noPositions =
        (!positionsLoading || !isFarmingLoading || !areDepositsLoading || gammaPositionsLoading) &&
        positionsData.length === 0 &&
        poolEntity;

    return (
        <PageContainer className="w-[100%]">
            <PoolHeader pool={poolEntity} poolAddress={poolId} />

            <div className="mt-[19px] grid w-full grid-cols-1 gap-x-0 gap-y-[19px] lg:mt-[19px] lg:grid-cols-10 lg:gap-[19px]">
                <div className="col-span-6">
                    {!account || isWrongChain ? (
                        <NoAccount isWrongChain={isWrongChain} />
                    ) : positionsLoading || isFarmingLoading || areDepositsLoading ? (
                        <LoadingState />
                    ) : noPositions ? (
                        <NoPositions poolId={poolId} />
                    ) : (
                        <>
                            <_MyPositionsPanelBase>
                                <PanelTitle title="MY POSITIONS" />
                                <MyPositionsToolbar positionsData={positionsData} poolId={poolId} />
                                <MyPositions
                                    positions={positionsData}
                                    poolId={poolId}
                                    selectedPosition={selectedPosition?.id}
                                    selectPosition={(positionId) =>
                                        selectPosition((prev) =>
                                            prev === positionId ? null : positionId,
                                        )
                                    }
                                />
                            </_MyPositionsPanelBase>

                            {farmingInfo &&
                                deposits &&
                                !isFarmingLoading &&
                                !areDepositsLoading && (
                                    <ActiveFarming
                                        deposits={deposits && deposits.deposits}
                                        farming={farmingInfo}
                                        positionsData={positionsData}
                                    />
                                )}
                        </>
                    )}
                </div>

                <div className="col-span-4 flex h-full flex-col gap-8">
                    <PositionCard
                        farming={farmingInfo}
                        closedFarmings={closedFarmings}
                        selectedPosition={selectedPosition}
                    />
                </div>
            </div>
        </PageContainer>
    );
};

const NoPositions = ({ poolId }: { poolId: Address }) => {
    const isMobile = useMediaQuery("mobile");

    return (
        <_PanelBase>
            <PanelTitle title="MY POSITIONS" />
            <div className="flex w-full flex-col items-center pb-[36px] pt-[32px] m:px-[40px] m:pb-[32px]">
                <Image
                    width={isMobile ? 80 : 100}
                    height={isMobile ? 80 : 100}
                    src="/my_position_panel_icon.svg"
                    className="mb-[16px] m:mb-[1px]"
                />
                <span className="font-[FraktionMono-Bold] text-[20px] font-bold leading-[1.2] text-[#000] m:text-[16px]">
                    YOU DON'T HAVE POSITIONS FOR THIS POOL
                </span>
                <span className="mt-[8px] font-[Geneva] text-[14px] leading-[1.2] text-[#000] m:text-[12px]">
                    Let's create one!
                </span>
                <Link to={`/pool/${poolId}/new-position`}>
                    <_PositionBtn>Create Position</_PositionBtn>
                </Link>
            </div>
        </_PanelBase>
    );
};

const NoAccount = ({ isWrongChain }: { isWrongChain: boolean }) => {
    const isMobile = useMediaQuery("mobile");
    const { open } = useWeb3Modal();

    return (
        <_PanelBase>
            <PanelTitle title="MY POSITIONS" />
            <div className="flex w-full flex-col items-center pb-[36px] pt-[32px] m:px-[21px] m:pb-[32px]">
                <Image
                    width={isMobile ? 80 : 100}
                    height={isMobile ? 80 : 100}
                    src="/wallet.svg"
                    className="mb-[16px] m:mb-[20px]"
                />
                <span className="font-[FraktionMono-Bold] text-[20px] font-bold leading-[1.2] text-[#000] m:text-[16px]">
                    CONNECT WALLET
                </span>
                <span className="mt-[8px] font-[Geneva] text-[14px] leading-[1.2] text-[#000] m:text-[12px]">
                    Connect your wallet to view or create positions
                </span>
                <_PositionBtn
                    onClick={() => (isWrongChain ? open({ view: "Networks" }) : open())}
                    className="cursor-pointer"
                >
                    {isWrongChain ? `Switch to ${DEFAULT_CHAIN_NAME}` : "Connect Wallet"}
                </_PositionBtn>
            </div>
        </_PanelBase>
    );
};

const LoadingState = () => (
    <div className="flex w-full flex-col gap-4 p-4">
        {[1, 2, 3, 4].map((v) => (
            <Skeleton
                key={`position-skeleton-${v}`}
                className="h-[50px] w-full rounded-xl bg-[#999]"
            />
        ))}
    </div>
);

const LoadingPoolPage = () => {
    const { inited, poolAddress: poolId, positionManager } = useCheckPool();
    const { hypervisor } = useMintState();
    const [loading, setLoading] = useState(true);
    const [associatePoolId, setAssociatePoolId] = useState<Address>();
    const navigate = useNavigate();

    useEffect(() => {
        if (poolId && BLACKLIST_POOLS.includes(poolId.toLowerCase() as Address)) {
            navigate("/pools");
        }
    }, [poolId]);

    useEffect(() => {
        if (inited && poolId) {
            if (positionManager === PositionManager.GAMMA) {
                if (hypervisor) {
                    setAssociatePoolId(hypervisor.poolAddress as Address);
                    setLoading(false);
                }
            } else {
                setAssociatePoolId(poolId);
                setLoading(false);
            }
        }
    }, [inited, poolId, hypervisor, positionManager]);

    return (
        <>
            {!loading ? (
                <PoolPage
                    poolId={poolId}
                    associatePoolId={associatePoolId}
                    positionManager={positionManager}
                />
            ) : (
                <LoadingState />
            )}
        </>
    );
};

export default LoadingPoolPage;



================================================
File: src/pages/Pools/index.tsx
================================================
import Banner from "@/components/common/Banner";
import PageContainer from "@/components/common/PageContainer";
import PoolsList from "@/components/pools/PoolsList";
import tw, { styled } from "twin.macro";

const PoolsPageContainer = styled(PageContainer)`
    margin: auto;
    ${() => tw`w-full max-w-[887px]`}
`;

const _V4Identifier = styled.div`
    border-radius: 4px;
    background: #f7931a;
    display: inline-flex;
    padding: 0 4px;
    justify-content: center;
    align-items: center;

    color: #fff;
    font-family: Geneva;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 17px;
    margin-left: 8px;

    ${() => tw``}
`;

const PoolsPage = () => {
    return (
        <PoolsPageContainer>
            <Banner
                title={
                    <>
                        <span>Pools</span>
                        <_V4Identifier>V4</_V4Identifier>
                    </>
                }
                description={
                    <>
                        Create positions into pools to earn{" "}
                        <span className="text-[#F7931A]">Swap Fees</span> &{" "}
                        <span className="text-[#9747FF]">Extra Incentives</span>
                    </>
                }
                className="w-[100%]"
            />

            <div className="mt-[20px] w-full lg:mt-[13px]">
                <PoolsList />
            </div>
        </PoolsPageContainer>
    );
};

export default PoolsPage;



================================================
File: src/pages/Swap/SwapSelector.tsx
================================================
import PageSelector from "@/components/common/PageSelector";
import Popver from "@/components/common/Popver";
import Svg from "@/components/common/Svg";
import { useSwapState } from "@/state/swapStore";
import { SwapPageSelector } from "@/types/page-selector";
import { memo, useMemo } from "react";
import { useShallow } from "zustand/react/shallow";

const SwapSelector: FCProps = ({ className, style }) => {
    const { pageSelector, setPageSelector } = useSwapState(
        useShallow((state) => ({
            pageSelector: state.pageSelector,
            setPageSelector: state.actions.setPageSelector,
        })),
    );

    const items = useMemo(
        () => [
            {
                name: (
                    <Popver
                        triger="Giga Swap"
                        title={
                            <>
                                <Svg
                                    $color="#9747FF"
                                    src="/search_money.svg"
                                    width={20}
                                    height={20}
                                />
                                <span className="text-[#9747FF]">Giga Swap</span>
                            </>
                        }
                        description="Giga Swap enables you to trade (nearly) any tokens on Core at the best price."
                    />
                ),
                active: pageSelector === SwapPageSelector.AGGREGATOR,
                action() {
                    setPageSelector(SwapPageSelector.AGGREGATOR);
                },
                color: "#9747FF" as `#${string}`,
            },
            {
                name: (
                    <Popver
                        triger="V4 AMM"
                        title={
                            <>
                                <Svg src="/search_money.svg" width={20} height={20} />
                                V4 AMM
                            </>
                        }
                        description="Trade through Glyph Exchange V4 local concentrated liquidity pools, designed for blue-chip assets like BTC & CORE."
                    />
                ),
                active: pageSelector === SwapPageSelector.V4AMM,
                action() {
                    setPageSelector(SwapPageSelector.V4AMM);
                },
            },
            {
                name: (
                    <Popver
                        triger={
                            <>
                                V2 AMM
                                <Svg src="/link.svg" alt="" width={16} height={16} />
                            </>
                        }
                        title={
                            <>
                                <Svg src="/search_money.svg" width={20} height={20} />
                                V2 AMM
                            </>
                        }
                        description="Trade through Glyph Exchange V2 local pools, designed for long tail assets."
                    />
                ),
                action() {
                    window.open("https://app.glyph.exchange");
                },
            },
        ],
        [pageSelector],
    );

    return <PageSelector className={className} style={style} items={items} />;
};

export default memo(SwapSelector);



================================================
File: src/pages/Swap/index.tsx
================================================
import tw, { styled } from "twin.macro";
import { memo } from "react";
import { useSwapState } from "@/state/swapStore";
import Bulletin from "@/components/common/Bulletin";
import { useShallow } from "zustand/react/shallow";
import { SwapPageSelector } from "@/types/page-selector";
import V4AMMPanel from "@/components/swap/V4AMMPanel";
import AggregatorPanel from "@/components/swap/AggregatorPanel";
import SwapSelector from "./SwapSelector";

const _SwapPage = styled.div`
    ${() => tw`relative mx-auto max-w-[434px] py-[55px] m:w-full m:py-[20px]`}
`;
const SwapPage = () => {
    const { showBulletin, pageSelector } = useSwapState(
        useShallow((state) => ({
            showBulletin: state.showBulletin,
            pageSelector: state.pageSelector,
        })),
    );

    return (
        <_SwapPage>
            {showBulletin && <Bulletin />}
            <SwapSelector />

            {pageSelector === SwapPageSelector.V4AMM && (
                <V4AMMPanel className="mt-[24px] m:mt-[20px]" />
            )}

            {pageSelector === SwapPageSelector.AGGREGATOR && (
                <AggregatorPanel className="mt-[24px] m:mt-[20px]" />
            )}
        </_SwapPage>
    );
};

export default memo(SwapPage);



================================================
File: src/pages/Swap/types.ts
================================================
export const SwapPageView = {
    SWAP: 'SWAP',
} as const

export type SwapPageViewType = typeof SwapPageView[keyof typeof SwapPageView]

export interface SwapPageProps {
    type: SwapPageViewType
}


================================================
File: src/scripts/loadSchema.js
================================================



================================================
File: src/state/burnStore.ts
================================================

import { useCurrency } from "@/hooks/common/useCurrency";
import { usePool } from "@/hooks/pools/usePool";
import { usePositionFees } from "@/hooks/positions/usePositionFees";
import { PositionFromTokenId } from "@/hooks/positions/usePositions";
import { Currency, CurrencyAmount, Percent, Position, computePoolAddress, unwrappedToken } from "@glyph-exchange/integral-sdk";
import { useCallback, useMemo } from "react";
import { Address, useAccount } from "wagmi";
import { create } from "zustand";


interface BurnState {
    readonly percent: number;
    actions: {
        selectPercent: (percent: number) => void,
    }
}


export const useBurnState = create<BurnState>((set) => ({
    percent: 0,
    actions: {
        selectPercent: (percent: number) => set({ percent }),
    }
})
)

export function useDerivedBurnInfo(
    position?: PositionFromTokenId,
    asWNative = false,
): {
    position?: Position;
    liquidityPercentage?: Percent;
    liquidityValue0?: CurrencyAmount<Currency>;
    liquidityValue1?: CurrencyAmount<Currency>;
    feeValue0?: CurrencyAmount<Currency>;
    feeValue1?: CurrencyAmount<Currency>;
    outOfRange: boolean;
    error?: string;
} {

    const { address: account } = useAccount();

    const { percent } = useBurnState();

    const currency0 = useCurrency(position?.token0);
    const currency1 = useCurrency(position?.token1);

    const poolId = currency0 && currency1 && computePoolAddress({
        tokenA: currency0.wrapped,
        tokenB: currency1.wrapped
    }) as Address

    const [, pool] = usePool(poolId);

    const positionSDK = useMemo(
        () =>
            pool &&
                position?.liquidity &&
                typeof position?.tickLower === 'number' &&
                typeof position?.tickUpper === 'number'
                ? new Position({
                    pool,
                    liquidity: position.liquidity.toString(),
                    tickLower: position.tickLower,
                    tickUpper: position.tickUpper,
                })
                : undefined,
        [pool, position],
    );


    const { liquidityPercentage, liquidityValue0, liquidityValue1 } = useMemo(() => {

        const liquidityPercentage = new Percent(percent, 100);

        const discountedAmount0 = positionSDK
            ? liquidityPercentage.multiply(positionSDK.amount0.quotient).quotient
            : undefined;
        const discountedAmount1 = positionSDK
            ? liquidityPercentage.multiply(positionSDK.amount1.quotient).quotient
            : undefined;

        const liquidityValue0 =
            currency0 && discountedAmount0
                ? CurrencyAmount.fromRawAmount(
                    asWNative ? currency0 : unwrappedToken(currency0),
                    discountedAmount0,
                )
                : undefined;
        const liquidityValue1 =
            currency1 && discountedAmount1
                ? CurrencyAmount.fromRawAmount(
                    asWNative ? currency1 : unwrappedToken(currency1),
                    discountedAmount1,
                )
                : undefined;

        return {
            liquidityPercentage,
            liquidityValue0,
            liquidityValue1
        }

    }, [percent, positionSDK, currency0, currency1])

    const { amount0: feeValue0, amount1: feeValue1 } = usePositionFees(
        pool ?? undefined,
        Number(position?.tokenId),
        asWNative,
    );

    const outOfRange =
        pool && position
            ? pool.tickCurrent < position.tickLower ||
            pool.tickCurrent > position.tickUpper
            : false;

    let error: string | undefined;

    if (!account) {
        error = `Connect Wallet`;
    }
    if (percent === 0) {
        error = error ?? `Enter a percent`;
    }

    return useMemo(() => ({
        position: positionSDK,
        liquidityPercentage,
        liquidityValue0,
        liquidityValue1,
        feeValue0,
        feeValue1,
        outOfRange,
        error,
    }),
        [
            positionSDK,
            liquidityPercentage,
            liquidityValue0,
            liquidityValue1,
            feeValue0,
            feeValue1,
            outOfRange,
            error
        ])
}

export function useBurnActionHandlers(): {
    onPercentSelect: (percent: number) => void;
} {

    const { actions: { selectPercent } } = useBurnState();

    const onPercentSelect = useCallback(
        (percent: number) => {
            selectPercent(percent);
        },
        [],
    );

    return {
        onPercentSelect,
    };
}



================================================
File: src/state/mintStore.ts
================================================
import {
    Currency,
    CurrencyAmount,
    Pool,
    Position,
    Price,
    Token,
} from "@glyph-exchange/integral-sdk";

import { ZERO } from "@glyph-exchange/integral-sdk";

import { Bound, Field, Rounding } from "@glyph-exchange/integral-sdk";
import { tryParseAmount, tryParseTick } from "@glyph-exchange/integral-sdk";
import {
    tickToPrice,
    priceToClosestTick,
    nearestUsableTick,
    encodeSqrtRatioX96,
    TickMath,
} from "@glyph-exchange/integral-sdk";

import { getTickToPrice } from "@glyph-exchange/integral-sdk";

import { useCallback, useMemo } from "react";
import { Address, useAccount, useBalance } from "wagmi";
import { create } from "zustand";
import { PoolState, PoolStateType, usePool } from "@/hooks/pools/usePool";
import { PresetsType } from "@/types/presets";
import { PositionManager } from "@/types/position-state";
import { useGammaUniProxyGetDepositAmount } from "@/generated";
import { parseUnits } from "viem";
import { HypervisorInfo } from "./../types/gamma-state";

export type FullRange = true;

export enum Presets {
    SAFE,
    RISK,
    NORMAL,
    FULL,
    STABLE,
}

interface MintState {
    readonly independentField: Field;
    readonly typedValue: string;
    readonly startPriceTypedValue: string; // for the case when there's no liquidity
    readonly leftRangeTypedValue: string | FullRange;
    readonly rightRangeTypedValue: string | FullRange;
    readonly dynamicFee: number;
    readonly preset: PresetsType | null;
    readonly txHash: string;
    readonly showNewestPosition: boolean;
    readonly initialUSDPrices: {
        [Field.CURRENCY_A]: string;
        [Field.CURRENCY_B]: string;
    };
    readonly initialTokenPrice: string;
    readonly currentStep: number;
    readonly positionManager: PositionManager;
    readonly hypervisor: HypervisorInfo;
    readonly actions: {
        updateDynamicFee: (dynamicFee: number) => void;
        resetMintState: () => void;
        setFullRange: () => void;
        typeStartPriceInput: (typedValue: string) => void;
        typeLeftRangeInput: (typedValue: string) => void;
        typeRightRangeInput: (typedValue: string) => void;
        typeInput: (field: Field, typedValue: string, noLiquidity: boolean) => void;
        updateSelectedPreset: (preset: PresetsType | null) => void;
        setAddLiquidityTxHash: (txHash: string) => void;
        setInitialTokenPrice: (typedValue: string) => void;
        updateCurrentStep: (currentStep: number) => void;
        setPositionManager: (positionManager: PositionManager) => void;
        setHypervisor: (hypervisor: HypervisorInfo) => void;
    };
}

export interface IDerivedMintInfo {
    pool?: Pool | null;
    poolState: PoolStateType;
    ticks: { [bound in Bound]?: number | undefined };
    price?: Price<Token, Token>;
    pricesAtTicks: {
        [bound in Bound]?: Price<Token, Token> | undefined;
    };
    currencies: { [field in Field]?: Currency };
    currencyBalances: { [field in Field]?: CurrencyAmount<Currency> };
    dependentField: Field;
    parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> };
    position: Position | undefined;
    noLiquidity?: boolean;
    errorMessage?: string;
    errorCode?: number;
    invalidPool: boolean;
    outOfRange: boolean;
    invalidRange: boolean;
    depositADisabled: boolean;
    depositBDisabled: boolean;
    invertPrice: boolean;
    ticksAtLimit: { [bound in Bound]?: boolean | undefined };
    dynamicFee: number;
    lowerPrice: any;
    upperPrice: any;
    tickSpacing: number;
    positionManager: PositionManager;
}

const initialState = {
    independentField: Field.CURRENCY_A,
    typedValue: "",
    startPriceTypedValue: "",
    leftRangeTypedValue: "",
    rightRangeTypedValue: "",
    dynamicFee: 0,
    preset: null,
    txHash: "",
    showNewestPosition: false,
    initialUSDPrices: { [Field.CURRENCY_A]: "", [Field.CURRENCY_B]: "" },
    initialTokenPrice: "",
    currentStep: 0,
    positionManager: PositionManager.ALGEBRA,
    hypervisor: {} as HypervisorInfo,
};

export const useMintState = create<MintState>((set, get) => ({
    ...initialState,
    actions: {
        updateDynamicFee: (dynamicFee: number) => set({ dynamicFee }),
        resetMintState: () => set(initialState),
        setFullRange: () => set({ leftRangeTypedValue: true, rightRangeTypedValue: true }),
        typeStartPriceInput: (typedValue: string) => set({ startPriceTypedValue: typedValue }),
        typeLeftRangeInput: (typedValue: string) => set({ leftRangeTypedValue: typedValue }),
        typeRightRangeInput: (typedValue: string) => set({ rightRangeTypedValue: typedValue }),
        typeInput: (field: Field, typedValue: string, noLiquidity: boolean) => {
            if (noLiquidity) {
                if (field === get().independentField) {
                    set({ independentField: field, typedValue });
                } else {
                    set({ independentField: field, typedValue });
                }
            } else {
                set({ independentField: field, typedValue });
            }
        },
        updateSelectedPreset: (preset: PresetsType | null) => set({ preset }),
        setAddLiquidityTxHash: (txHash: string) => set({ txHash }),
        setInitialTokenPrice: (typedValue: string) => set({ initialTokenPrice: typedValue }),
        updateCurrentStep: (currentStep: number) => set({ currentStep }),
        setPositionManager: (positionManager) => set({ positionManager }),
        setHypervisor: (hypervisor) => set({ hypervisor }),
    },
}));

export function useMintActionHandlers(noLiquidity: boolean | undefined): {
    onFieldAInput: (typedValue: string) => void;
    onFieldBInput: (typedValue: string) => void;
    onLeftRangeInput: (typedValue: string) => void;
    onRightRangeInput: (typedValue: string) => void;
    onStartPriceInput: (typedValue: string) => void;
} {
    const {
        actions: { typeInput, typeLeftRangeInput, typeRightRangeInput, typeStartPriceInput },
    } = useMintState();

    const onFieldAInput = useCallback(
        (typedValue: string) => typeInput(Field.CURRENCY_A, typedValue, noLiquidity === true),
        [noLiquidity],
    );

    const onFieldBInput = useCallback(
        (typedValue: string) => typeInput(Field.CURRENCY_B, typedValue, noLiquidity === true),
        [noLiquidity],
    );

    const onLeftRangeInput = useCallback(
        (typedValue: string) => typeLeftRangeInput(typedValue),
        [],
    );

    const onRightRangeInput = useCallback(
        (typedValue: string) => typeRightRangeInput(typedValue),
        [],
    );

    const onStartPriceInput = useCallback(
        (typedValue: string) => typeStartPriceInput(typedValue),
        [],
    );

    return {
        onFieldAInput,
        onFieldBInput,
        onLeftRangeInput,
        onRightRangeInput,
        onStartPriceInput,
    };
}

export function useDerivedMintInfo(
    currencyA?: Currency,
    currencyB?: Currency,
    poolAddress?: Address,
    feeAmount?: number,
    baseCurrency?: Currency,
    existingPosition?: Position,
): IDerivedMintInfo {
    const { address: account } = useAccount();

    const {
        independentField,
        typedValue,
        leftRangeTypedValue,
        rightRangeTypedValue,
        startPriceTypedValue,
        positionManager,
    } = useMintState();

    const dependentField =
        independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;

    // currencies
    const currencies: { [field in Field]?: Currency } = useMemo(
        () => ({
            [Field.CURRENCY_A]: currencyA,
            [Field.CURRENCY_B]: currencyB,
        }),
        [currencyA, currencyB],
    );

    // formatted with tokens
    const [tokenA, tokenB, baseToken] = useMemo(
        () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],
        [currencyA, currencyB, baseCurrency],
    );

    const [token0, token1] = useMemo(
        () =>
            tokenA && tokenB && !tokenA.equals(tokenB)
                ? tokenA.sortsBefore(tokenB)
                    ? [tokenA, tokenB]
                    : [tokenB, tokenA]
                : [undefined, undefined],
        [tokenA, tokenB],
    );

    const [addressA, addressB] = [
        currencyA?.isNative ? undefined : token0?.address || "",
        currencyB?.isNative ? undefined : token1?.address || "",
    ] as Address[];

    const { data: token0Balance } = useBalance({
        address: account,
        token: addressA,
        watch: true,
    });
    const { data: token1Balance } = useBalance({
        address: account,
        token: addressB,
        watch: true,
    });

    const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {
        [Field.CURRENCY_A]:
            currencyA && token0Balance
                ? CurrencyAmount.fromRawAmount(currencyA, token0Balance.value.toString())
                : undefined,
        [Field.CURRENCY_B]:
            currencyB && token1Balance
                ? CurrencyAmount.fromRawAmount(currencyB, token1Balance.value.toString())
                : undefined,
    };

    const [poolState, pool] = usePool(
        poolAddress as Address,
        positionManager === PositionManager.ALGEBRA,
    );

    const noLiquidity = poolState === PoolState.NOT_EXISTS;

    const dynamicFee = pool ? pool.fee : 100;

    const tickSpacing = pool ? pool.tickSpacing : 60;

    // note to parse inputs in reverse
    const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0));

    // always returns the price with 0 as base token
    const price: Price<Token, Token> | undefined = useMemo(() => {
        // if no liquidity use typed value
        if (noLiquidity) {
            const parsedQuoteAmount = tryParseAmount(
                startPriceTypedValue,
                invertPrice ? token0 : token1,
            );
            if (parsedQuoteAmount && token0 && token1) {
                const baseAmount = tryParseAmount("1", invertPrice ? token1 : token0);
                const price =
                    baseAmount && parsedQuoteAmount
                        ? new Price(
                              baseAmount.currency,
                              parsedQuoteAmount.currency,
                              baseAmount.quotient,
                              parsedQuoteAmount.quotient,
                          )
                        : undefined;
                return (invertPrice ? price?.invert() : price) ?? undefined;
            }
            return undefined;
        } else {
            // get the amount of quote currency
            return pool && token0 ? pool.priceOf(token0) : undefined;
        }
    }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool]);

    // check for invalid price input (converts to invalid ratio)
    const invalidPrice = useMemo(() => {
        const sqrtRatioX96 = price
            ? encodeSqrtRatioX96(price.numerator, price.denominator)
            : undefined;
        const invalid =
            price &&
            sqrtRatioX96 &&
            !(
                BigInt(sqrtRatioX96.toString()) >= BigInt(TickMath.MIN_SQRT_RATIO.toString()) &&
                BigInt(sqrtRatioX96.toString()) < BigInt(TickMath.MAX_SQRT_RATIO.toString())
            );
        return invalid;
    }, [price]);

    // used for ratio calculation when pool not initialized
    const mockPool = useMemo(() => {
        if (tokenA && tokenB && feeAmount && price && !invalidPrice) {
            const currentTick = priceToClosestTick(price);
            const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);
            return new Pool(tokenA, tokenB, feeAmount, currentSqrt, 0, currentTick, 60, []);
        } else {
            return undefined;
        }
    }, [feeAmount, invalidPrice, price, tokenA, tokenB]);

    // if pool exists use it, if not use the mock pool
    const poolForPosition: Pool | undefined = pool ?? mockPool;

    // lower and upper limits in the tick space
    const tickSpaceLimits: {
        [bound in Bound]: number | undefined;
    } = useMemo(
        () => ({
            [Bound.LOWER]: tickSpacing
                ? nearestUsableTick(TickMath.MIN_TICK, tickSpacing)
                : undefined,
            [Bound.UPPER]: tickSpacing
                ? nearestUsableTick(TickMath.MAX_TICK, tickSpacing)
                : undefined,
        }),
        [tickSpacing],
    );

    // parse typed range values and determine closest ticks
    // lower should always be a smaller tick
    const ticks: {
        [key: string]: number | undefined;
    } = useMemo(() => {
        return {
            [Bound.LOWER]:
                typeof existingPosition?.tickLower === "number"
                    ? existingPosition.tickLower
                    : (invertPrice && typeof rightRangeTypedValue === "boolean") ||
                        (!invertPrice && typeof leftRangeTypedValue === "boolean")
                      ? tickSpaceLimits[Bound.LOWER]
                      : invertPrice
                        ? tryParseTick(token1, token0, rightRangeTypedValue.toString(), tickSpacing)
                        : tryParseTick(token0, token1, leftRangeTypedValue.toString(), tickSpacing),
            [Bound.UPPER]:
                typeof existingPosition?.tickUpper === "number"
                    ? existingPosition.tickUpper
                    : (!invertPrice && typeof rightRangeTypedValue === "boolean") ||
                        (invertPrice && typeof leftRangeTypedValue === "boolean")
                      ? tickSpaceLimits[Bound.UPPER]
                      : invertPrice
                        ? tryParseTick(token1, token0, leftRangeTypedValue.toString(), tickSpacing)
                        : tryParseTick(
                              token0,
                              token1,
                              rightRangeTypedValue.toString(),
                              tickSpacing,
                          ),
        };
    }, [
        existingPosition,
        feeAmount,
        invertPrice,
        leftRangeTypedValue,
        rightRangeTypedValue,
        token0,
        token1,
        tickSpaceLimits,
        tickSpacing,
    ]);

    const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {};

    // specifies whether the lower and upper ticks is at the exteme bounds
    const ticksAtLimit = useMemo(
        () => ({
            [Bound.LOWER]: Boolean(feeAmount && tickLower === tickSpaceLimits.LOWER),
            [Bound.UPPER]: Boolean(feeAmount && tickUpper === tickSpaceLimits.UPPER),
        }),
        [tickSpaceLimits, tickLower, tickUpper, feeAmount],
    );

    // mark invalid range
    const invalidRange = Boolean(
        typeof tickLower === "number" && typeof tickUpper === "number" && tickLower >= tickUpper,
    );

    // always returns the price with 0 as base token
    const pricesAtTicks = useMemo(() => {
        return {
            [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),
            [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),
        };
    }, [token0, token1, ticks]);
    const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks;

    // liquidity range warning
    const outOfRange = Boolean(
        !invalidRange &&
            price &&
            lowerPrice &&
            upperPrice &&
            (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)),
    );

    const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(
        typedValue,
        currencies[independentField],
    );

    const independentToken = useMemo(
        () => (independentField === Field.CURRENCY_A ? token0 : token1),
        [independentField, token0, token1],
    );

    const independentAmountBN: bigint = useMemo(
        () => parseUnits(typedValue, independentToken?.decimals || 18),
        [typedValue, independentToken],
    );

    const { data: dependentAmountBN } = useGammaUniProxyGetDepositAmount({
        enabled: positionManager === PositionManager.GAMMA && independentAmountBN > 0n,
        args: [poolAddress as Address, independentToken?.address as Address, independentAmountBN],
    });

    const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {
        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;

        if (positionManager === PositionManager.ALGEBRA) {
            // we wrap the currencies just to get the price in terms of the other token
            const wrappedIndependentAmount = independentAmount?.wrapped;

            if (
                independentAmount &&
                wrappedIndependentAmount &&
                typeof tickLower === "number" &&
                typeof tickUpper === "number" &&
                poolForPosition
            ) {
                // if price is out of range or invalid range - return 0 (single deposit will be independent)
                if (outOfRange || invalidRange) {
                    return undefined;
                }

                const position: Position | undefined = wrappedIndependentAmount.currency.equals(
                    poolForPosition.token0,
                )
                    ? Position.fromAmount0({
                          pool: poolForPosition,
                          tickLower,
                          tickUpper,
                          amount0: independentAmount.quotient,
                          useFullPrecision: true, // we want full precision for the theoretical position
                      })
                    : Position.fromAmount1({
                          pool: poolForPosition,
                          tickLower,
                          tickUpper,
                          amount1: independentAmount.quotient,
                      });

                const dependentTokenAmount = wrappedIndependentAmount.currency.equals(
                    poolForPosition.token0,
                )
                    ? position.amount1
                    : position.amount0;
                return (
                    dependentCurrency &&
                    CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)
                );
            }
        } else if (positionManager === PositionManager.GAMMA) {
            if (!dependentAmountBN) return undefined;
            const [amountMin, amouontMax] = dependentAmountBN;
            return (
                dependentCurrency &&
                dependentAmountBN &&
                CurrencyAmount.fromRawAmount(
                    dependentCurrency,
                    String((amountMin + amouontMax) / 2n),
                )
            );
        }
        return undefined;
    }, [
        independentAmount,
        outOfRange,
        dependentField,
        currencyB,
        currencyA,
        tickLower,
        tickUpper,
        poolForPosition,
        invalidRange,
        positionManager,
        dependentAmountBN,
    ]);

    const parsedAmounts: {
        [field in Field]: CurrencyAmount<Currency> | undefined;
    } = useMemo(() => {
        return {
            [Field.CURRENCY_A]:
                independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,
            [Field.CURRENCY_B]:
                independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,
        };
    }, [dependentAmount, independentAmount, independentField]);

    // single deposit only if price is out of range
    const deposit0Disabled = Boolean(
        typeof tickUpper === "number" &&
            poolForPosition &&
            poolForPosition.tickCurrent >= tickUpper,
    );
    const deposit1Disabled = Boolean(
        typeof tickLower === "number" &&
            poolForPosition &&
            poolForPosition.tickCurrent <= tickLower,
    );

    // sorted for token order
    const depositADisabled =
        invalidRange ||
        Boolean(
            (deposit0Disabled &&
                poolForPosition &&
                tokenA &&
                poolForPosition.token0.equals(tokenA)) ||
                (deposit1Disabled &&
                    poolForPosition &&
                    tokenA &&
                    poolForPosition.token1.equals(tokenA)),
        );
    const depositBDisabled =
        invalidRange ||
        Boolean(
            (deposit0Disabled &&
                poolForPosition &&
                tokenB &&
                poolForPosition.token0.equals(tokenB)) ||
                (deposit1Disabled &&
                    poolForPosition &&
                    tokenB &&
                    poolForPosition.token1.equals(tokenB)),
        );

    // create position entity based on users selection
    const position: Position | undefined = useMemo(() => {
        if (
            !poolForPosition ||
            !tokenA ||
            !tokenB ||
            typeof tickLower !== "number" ||
            typeof tickUpper !== "number" ||
            invalidRange
        ) {
            return undefined;
        }

        // mark as 0 if disabled because out of range
        const amount0 = !deposit0Disabled
            ? parsedAmounts?.[
                  tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B
              ]?.quotient
            : ZERO;
        const amount1 = !deposit1Disabled
            ? parsedAmounts?.[
                  tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A
              ]?.quotient
            : ZERO;

        if (amount0 !== undefined && amount1 !== undefined) {
            return Position.fromAmounts({
                pool: poolForPosition,
                tickLower,
                tickUpper,
                amount0,
                amount1,
                useFullPrecision: true, // we want full precision for the theoretical position
            });
        } else {
            return undefined;
        }
    }, [
        parsedAmounts,
        poolForPosition,
        tokenA,
        tokenB,
        deposit0Disabled,
        deposit1Disabled,
        invalidRange,
        tickLower,
        tickUpper,
    ]);

    let errorMessage: string | undefined;
    let errorCode: number | undefined;

    if (!account) {
        errorMessage = `Connect Wallet`;
        errorCode = errorCode ?? 0;
    }

    if (poolState === PoolState.INVALID) {
        errorMessage = errorMessage ?? `Invalid pair`;
        errorCode = errorCode ?? 1;
    }

    if (invalidPrice) {
        errorMessage = errorMessage ?? `Invalid price input`;
        errorCode = errorCode ?? 2;
    }

    if (
        (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||
        (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled) ||
        parsedAmounts[Field.CURRENCY_A]?.equalTo(0) ||
        parsedAmounts[Field.CURRENCY_B]?.equalTo(0)
    ) {
        errorMessage = errorMessage ?? `Input Amount`;
        errorCode = errorCode ?? 3;
    }

    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } =
        parsedAmounts;

    if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {
        errorMessage = `Insufficient Balance`;
        errorCode = errorCode ?? 4;
    }

    if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {
        errorMessage = `Insufficient Balance`;
        errorCode = errorCode ?? 5;
    }

    const invalidPool = poolState === PoolState.INVALID;

    return {
        dependentField,
        currencies,
        pool: poolForPosition,
        poolState,
        currencyBalances,
        parsedAmounts,
        ticks,
        price,
        pricesAtTicks,
        position,
        noLiquidity,
        errorMessage,
        errorCode,
        invalidPool,
        invalidRange,
        outOfRange,
        depositADisabled,
        depositBDisabled,
        invertPrice,
        ticksAtLimit,
        dynamicFee,
        lowerPrice,
        upperPrice,
        tickSpacing,
        positionManager,
    };
}

export function useRangeHopCallbacks(
    baseCurrency: Currency | undefined,
    quoteCurrency: Currency | undefined,
    tickSpacing: number,
    tickLower: number | undefined,
    tickUpper: number | undefined,
    pool?: Pool | undefined | null,
) {
    const {
        actions: { setFullRange },
    } = useMintState();

    const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency]);
    const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency]);

    const getDecrementLower = useCallback(
        (rate = 1) => {
            if (baseToken && quoteToken && typeof tickLower === "number" && tickSpacing) {
                const newPrice = tickToPrice(baseToken, quoteToken, tickLower - tickSpacing * rate);
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            // use pool current tick as starting tick if we have pool but no tick input

            if (
                !(typeof tickLower === "number") &&
                baseToken &&
                quoteToken &&
                tickSpacing &&
                pool
            ) {
                const newPrice = tickToPrice(
                    baseToken,
                    quoteToken,
                    pool.tickCurrent - tickSpacing * rate,
                );
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            return "";
        },
        [baseToken, quoteToken, tickLower, tickSpacing, pool],
    );

    const getIncrementLower = useCallback(
        (rate = 1) => {
            if (baseToken && quoteToken && typeof tickLower === "number" && tickSpacing) {
                const newPrice = tickToPrice(baseToken, quoteToken, tickLower + tickSpacing * rate);
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            // use pool current tick as starting tick if we have pool but no tick input
            if (
                !(typeof tickLower === "number") &&
                baseToken &&
                quoteToken &&
                tickSpacing &&
                pool
            ) {
                const newPrice = tickToPrice(
                    baseToken,
                    quoteToken,
                    pool.tickCurrent + tickSpacing * rate,
                );
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            return "";
        },
        [baseToken, quoteToken, tickLower, tickSpacing, pool],
    );

    const getDecrementUpper = useCallback(
        (rate = 1) => {
            if (baseToken && quoteToken && typeof tickUpper === "number" && tickSpacing) {
                const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - tickSpacing * rate);
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            // use pool current tick as starting tick if we have pool but no tick input
            if (
                !(typeof tickUpper === "number") &&
                baseToken &&
                quoteToken &&
                tickSpacing &&
                pool
            ) {
                const newPrice = tickToPrice(
                    baseToken,
                    quoteToken,
                    pool.tickCurrent - tickSpacing * rate,
                );
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            return "";
        },
        [baseToken, quoteToken, tickUpper, tickSpacing, pool],
    );

    const getIncrementUpper = useCallback(
        (rate = 1) => {
            if (baseToken && quoteToken && typeof tickUpper === "number" && tickSpacing) {
                const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + tickSpacing * rate);
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            // use pool current tick as starting tick if we have pool but no tick input
            if (
                !(typeof tickUpper === "number") &&
                baseToken &&
                quoteToken &&
                tickSpacing &&
                pool
            ) {
                const newPrice = tickToPrice(
                    baseToken,
                    quoteToken,
                    pool.tickCurrent + tickSpacing * rate,
                );
                return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);
            }
            return "";
        },
        [baseToken, quoteToken, tickUpper, tickSpacing, pool],
    );

    const getSetRange = useCallback(
        (numTicks: number) => {
            if (baseToken && quoteToken && tickSpacing && pool) {
                // calculate range around current price given `numTicks`
                const newPriceLower = tickToPrice(
                    baseToken,
                    quoteToken,
                    Math.max(TickMath.MIN_TICK, pool.tickCurrent - numTicks),
                );
                const newPriceUpper = tickToPrice(
                    baseToken,
                    quoteToken,
                    Math.min(TickMath.MAX_TICK, pool.tickCurrent + numTicks),
                );

                return [
                    newPriceLower.toSignificant(5, undefined, Rounding.ROUND_UP),
                    newPriceUpper.toSignificant(5, undefined, Rounding.ROUND_UP),
                ];
            }
            return ["", ""];
        },
        [baseToken, quoteToken, tickSpacing, pool],
    );

    const getSetFullRange = useCallback(() => setFullRange(), []);

    return {
        getDecrementLower,
        getIncrementLower,
        getDecrementUpper,
        getIncrementUpper,
        getSetRange,
        getSetFullRange,
    };
}



================================================
File: src/state/pendingTransactionsStore.ts
================================================
import deepMerge from "lodash.merge";
import { useEffect } from "react";
import { Address, useAccount, usePublicClient } from "wagmi";
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { waitForTransactionReceipt } from "viem/actions";

export enum TransactionType {
    SWAP = "SWAP",
    FARM = "FARM",
    POOL = "POOL",
}

export interface TransactionInfo {
    title: string;
    description?: string;
    tokenA?: Address;
    tokenB?: Address;
    tokenId?: string;
    type: TransactionType;
}

export interface Transaction {
    data: TransactionInfo;
    success: boolean | null;
    loading: boolean;
    error: Error | null;
}

type PendingTransactions = Record<Address, Transaction>;

type UserTransactions = Record<Address, PendingTransactions>;

const MAX_TRANSACTIONS = 10;

interface UserState {
    pendingTransactions: UserTransactions;
    actions: {
        addPendingTransaction: (account: Address, hash: Address) => void;
        updatePendingTransaction: (
            account: Address,
            hash: Address,
            transaction: Transaction,
        ) => void;
        deletePendingTransaction: (account: Address, hash: Address) => void;
    };
}

export const usePendingTransactionsStore = create(
    persist<UserState>(
        (set, get) => ({
            pendingTransactions: {},
            actions: {
                addPendingTransaction: (account, hash) => {
                    const { pendingTransactions } = get();
                    const transactionKeys = pendingTransactions[account]
                        ? Object.keys(pendingTransactions[account])
                        : [];

                    if (transactionKeys.length >= MAX_TRANSACTIONS) {
                        delete pendingTransactions[account][transactionKeys[0] as Address];
                    }

                    set({
                        pendingTransactions: {
                            ...get().pendingTransactions,
                            [account]: {
                                ...get().pendingTransactions[account],
                                [hash]: {
                                    loading: true,
                                    success: null,
                                    error: null,
                                },
                            },
                        },
                    });
                },
                updatePendingTransaction: (account, hash, transaction) =>
                    set({
                        pendingTransactions: {
                            ...get().pendingTransactions,
                            [account]: {
                                ...get().pendingTransactions[account],
                                [hash]: transaction,
                            },
                        },
                    }),
                deletePendingTransaction: (account, hash) => {
                    const { pendingTransactions } = get();
                    delete pendingTransactions[account][hash];
                    set({
                        pendingTransactions,
                    });
                },
            },
        }),
        {
            name: "pending-transactions-storage",
            merge(persistedState, currentState) {
                return deepMerge(currentState, persistedState);
            },
        },
    ),
);

export function usePendingTransactions() {
    const {
        pendingTransactions,
        actions: { updatePendingTransaction },
    } = usePendingTransactionsStore();

    const { address: account } = useAccount();

    const config = usePublicClient();

    useEffect(() => {
        if (!account) return;
        const pendingTransactionsList = Object.entries(pendingTransactions[account]).filter(
            ([, transaction]) => transaction.loading,
        );
        for (const [txHash] of pendingTransactionsList) {
            waitForTransactionReceipt(config, { confirmations: 1, hash: txHash as Address })
                .then((receipt) =>
                    updatePendingTransaction(account, txHash as Address, {
                        ...pendingTransactions[account][txHash as Address],
                        loading: false,
                        success: receipt.status === "success",
                        error: receipt.status === "success" ? null : Error(receipt.status),
                    }),
                )
                .catch((error) =>
                    updatePendingTransaction(account, txHash as Address, {
                        ...pendingTransactions[account][txHash as Address],
                        loading: false,
                        success: false,
                        error,
                    }),
                );
        }
    }, [config, pendingTransactions, updatePendingTransaction, account]);

    return pendingTransactions;
}



================================================
File: src/state/poolsStore.ts
================================================
import { Address } from "wagmi";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware"

interface PoolPlugins {
    dynamicFeePlugin: boolean;
    limitOrderPlugin: boolean;
    farmingPlugin: boolean;
}

interface PoolsState {
    readonly pluginsForPools: { [key: Address]: PoolPlugins };
    setPluginsForPool: (poolId: Address, plugins: PoolPlugins) => void;
}

export const usePoolsStore = create(persist<PoolsState>((set, get) => ({
    pluginsForPools: {},
    setPluginsForPool: (poolId: Address, plugins: PoolPlugins) => set({
        pluginsForPools: {
            ...get().pluginsForPools,
            [poolId.toLowerCase()]: plugins
        }
    })
}), {
    name: 'pools-plugins',
    storage: createJSONStorage(() => sessionStorage)
})
)






================================================
File: src/state/positionFilterStore.ts
================================================
import { create } from "zustand";
import { PositionsStatus } from "@/types/position-filter-status";
import { createJSONStorage, persist } from "zustand/middleware";
import deepMerge from "lodash.merge";

type FilteredPositions = {
    [key in PositionsStatus]: boolean;
};

interface FilterStore {
    filterStatus: FilteredPositions;
    actions: {
        setFilterStatus: (positionStatus: PositionsStatus) => void;
        reset: () => void;
    };
}

export const usePositionFilterStore = create(
    persist<FilterStore>(
        (set) => ({
            filterStatus: {
                [PositionsStatus.OPEN]: true,
                [PositionsStatus.ON_FARMING]: true,
                [PositionsStatus.CLOSED]: false,
                [PositionsStatus.ON_GAMMA]: true,
            },
            actions: {
                setFilterStatus: (positionStatus: PositionsStatus) => {
                    set((state) => ({
                        filterStatus: {
                            ...state.filterStatus,
                            [positionStatus]: !state.filterStatus[positionStatus],
                        },
                    }));
                },
                reset: () =>
                    set({
                        filterStatus: {
                            [PositionsStatus.OPEN]: true,
                            [PositionsStatus.ON_FARMING]: true,
                            [PositionsStatus.CLOSED]: false,
                            [PositionsStatus.ON_GAMMA]: true,
                        },
                    }),
            },
        }),
        {
            name: "position-filter-storage",
            storage: createJSONStorage(() => localStorage),
            merge: (persistedState, currentState) => deepMerge(currentState, persistedState),
        },
    ),
);



================================================
File: src/state/swapStore.ts
================================================
import { STABLECOINS } from "@/constants/tokens";
import { useAlgebraPoolGlobalState, useAlgebraPoolTickSpacing } from "@/generated";
import { useCurrency } from "@/hooks/common/useCurrency";
import { RouterData, useAggregatorData } from "@/hooks/swap/useAggregatorData";
import { useBestTradeExactIn, useBestTradeExactOut } from "@/hooks/swap/useBestTrade";
import useSwapSlippageTolerance from "@/hooks/swap/useSwapSlippageTolerance";
import { SwapPageSelector, SwapPageSelectorType } from "@/types/page-selector";
import { SwapField, SwapFieldType } from "@/types/swap-field";
import { TradeStateType } from "@/types/trade-state";
import {
    ADDRESS_ZERO,
    Currency,
    CurrencyAmount,
    Percent,
    TickMath,
    Trade,
    TradeType,
    computePoolAddress,
} from "@glyph-exchange/integral-sdk";
import JSBI from "jsbi";
import { useCallback, useEffect, useMemo, useState } from "react";
import { formatUnits, parseUnits, zeroAddress } from "viem";
import { Address, useAccount, useBalance } from "wagmi";
import { create } from "zustand";
import { useUserState } from "./userStore";
import { n2bi } from "@/utils";

interface SwapState {
    readonly independentField: SwapFieldType;
    readonly typedValue: string;
    readonly [SwapField.INPUT]: {
        readonly currencyId: Address | undefined;
    };
    readonly [SwapField.OUTPUT]: {
        readonly currencyId: Address | undefined;
    };
    readonly wasInverted: boolean;
    readonly lastFocusedField: SwapFieldType;
    readonly showBulletin: boolean;
    readonly pageSelector: SwapPageSelectorType;

    actions: {
        selectCurrency: (field: SwapFieldType, currencyId: string | undefined) => void;
        switchCurrencies: () => void;
        typeInput: (field: SwapFieldType, typedValue: string) => void;
        changeShowBulletin: (status: boolean) => void;
        setPageSelector: (type: SwapState["pageSelector"]) => void;
    };
}

export const useSwapState = create<SwapState>((set, get) => ({
    independentField: SwapField.INPUT,
    typedValue: "",
    [SwapField.INPUT]: {
        currencyId: ADDRESS_ZERO,
    },
    [SwapField.OUTPUT]: {
        currencyId: STABLECOINS.USDT.address as Account,
    },
    wasInverted: false,
    lastFocusedField: SwapField.INPUT,
    showBulletin: import.meta.env.VITE_AD_POPUP_ENABLED ? true : false,
    pageSelector: SwapPageSelector.AGGREGATOR,
    actions: {
        selectCurrency: (field, currencyId) => {
            const otherField = field === SwapField.INPUT ? SwapField.OUTPUT : SwapField.INPUT;

            if (currencyId && currencyId === get()[otherField].currencyId) {
                set({
                    independentField:
                        get().independentField === SwapField.INPUT
                            ? SwapField.OUTPUT
                            : SwapField.INPUT,
                    lastFocusedField:
                        get().independentField === SwapField.INPUT
                            ? SwapField.OUTPUT
                            : SwapField.INPUT,
                    [field]: { currencyId },
                    [otherField]: { currencyId: get()[field].currencyId },
                });
            } else {
                set({
                    [field]: { currencyId },
                });
            }
        },
        switchCurrencies: () =>
            set({
                independentField:
                    get().independentField === SwapField.INPUT ? SwapField.OUTPUT : SwapField.INPUT,
                lastFocusedField:
                    get().independentField === SwapField.INPUT ? SwapField.OUTPUT : SwapField.INPUT,
                [SwapField.INPUT]: { currencyId: get()[SwapField.OUTPUT].currencyId },
                [SwapField.OUTPUT]: { currencyId: get()[SwapField.INPUT].currencyId },
            }),
        typeInput: (field, typedValue) =>
            set({
                independentField: field,
                lastFocusedField: field,
                typedValue,
            }),
        changeShowBulletin: (status) =>
            set({
                showBulletin: status,
            }),

        setPageSelector: (type) =>
            set({
                pageSelector: type,
            }),
    },
}));

export function useSwapActionHandlers(): {
    onCurrencySelection: (field: SwapFieldType, currency: Currency) => void;
    onSwitchTokens: () => void;
    onUserInput: (field: SwapFieldType, typedValue: string) => void;
} {
    const {
        actions: { selectCurrency, switchCurrencies, typeInput },
    } = useSwapState();

    const onCurrencySelection = useCallback(
        (field: SwapFieldType, currency: Currency) =>
            selectCurrency(
                field,
                currency.isToken ? currency.address : currency.isNative ? ADDRESS_ZERO : "",
            ),
        [],
    );

    const onSwitchTokens = useCallback(() => {
        switchCurrencies();
    }, []);

    const onUserInput = useCallback((field: SwapFieldType, typedValue: string) => {
        typeInput(field, typedValue);
    }, []);

    return {
        onSwitchTokens,
        onCurrencySelection,
        onUserInput,
    };
}

export function tryParseAmount<T extends Currency>(
    value?: string,
    currency?: T,
): CurrencyAmount<T> | undefined {
    if (!value || !currency) {
        return undefined;
    }
    try {
        const typedValueParsed = parseUnits(value, currency.decimals).toString();
        if (typedValueParsed !== "0") {
            return CurrencyAmount.fromRawAmount(currency, typedValueParsed);
        }
    } catch (error) {
        console.debug(`Failed to parse input amount: "${value}"`, error);
    }
    return undefined;
}

export function useDerivedSwapInfo(): {
    currencies: { [field in SwapFieldType]?: Currency };
    currencyBalances: { [field in SwapFieldType]?: CurrencyAmount<Currency> };
    parsedAmount: CurrencyAmount<Currency> | undefined;
    inputError?: string;
    tradeState: {
        trade: Trade<Currency, Currency, TradeType> | null;
        state: TradeStateType;
        fee?: bigint[] | null;
    };
    toggledTrade: Trade<Currency, Currency, TradeType> | undefined;
    tickAfterSwap: number | null | undefined;
    allowedSlippage: Percent;
    poolFee: number | undefined;
    tick: number | undefined;
    tickSpacing: number | undefined;
    poolAddress: Address | undefined;
} {
    const { address: account } = useAccount();

    const {
        independentField,
        typedValue,
        [SwapField.INPUT]: { currencyId: inputCurrencyId },
        [SwapField.OUTPUT]: { currencyId: outputCurrencyId },
    } = useSwapState();

    const inputCurrency = useCurrency(inputCurrencyId);
    const outputCurrency = useCurrency(outputCurrencyId);

    const isExactIn: boolean = independentField === SwapField.INPUT;
    const parsedAmount = useMemo(
        () => tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),
        [typedValue, isExactIn, inputCurrency, outputCurrency],
    );

    const bestTradeExactIn = useBestTradeExactIn(
        isExactIn ? parsedAmount : undefined,
        outputCurrency ?? undefined,
    );
    const bestTradeExactOut = useBestTradeExactOut(
        inputCurrency ?? undefined,
        !isExactIn ? parsedAmount : undefined,
    );

    const trade = (isExactIn ? bestTradeExactIn : bestTradeExactOut) ?? undefined;

    const [addressA, addressB] = [
        inputCurrency?.isNative ? undefined : inputCurrency?.address || "",
        outputCurrency?.isNative ? undefined : outputCurrency?.address || "",
    ] as Address[];

    const { data: inputCurrencyBalance } = useBalance({
        address: account,
        token: addressA,
        watch: true,
    });
    const { data: outputCurrencyBalance } = useBalance({
        address: account,
        token: addressB,
        watch: true,
    });

    const currencyBalances = {
        [SwapField.INPUT]:
            inputCurrency &&
            inputCurrencyBalance &&
            CurrencyAmount.fromRawAmount(inputCurrency, inputCurrencyBalance.value.toString()),
        [SwapField.OUTPUT]:
            outputCurrency &&
            outputCurrencyBalance &&
            CurrencyAmount.fromRawAmount(outputCurrency, outputCurrencyBalance.value.toString()),
    };

    const currencies: { [field in SwapFieldType]?: Currency } = {
        [SwapField.INPUT]: inputCurrency ?? undefined,
        [SwapField.OUTPUT]: outputCurrency ?? undefined,
    };

    let inputError: string | undefined;
    if (!account) {
        inputError = `Connect Wallet`;
    }

    if (!parsedAmount) {
        inputError = inputError ?? `Input Amount`;
    }

    if (!currencies[SwapField.INPUT] || !currencies[SwapField.OUTPUT]) {
        inputError = inputError ?? `Select a token`;
    }

    const toggledTrade = trade.trade ?? undefined;

    const tickAfterSwap =
        trade.priceAfterSwap &&
        TickMath.getTickAtSqrtRatio(
            JSBI.BigInt(trade.priceAfterSwap[trade.priceAfterSwap.length - 1].toString()),
        );

    const allowedSlippage = useSwapSlippageTolerance(toggledTrade);

    const [balanceIn, amountIn] = [
        currencyBalances[SwapField.INPUT],
        toggledTrade?.maximumAmountIn(allowedSlippage),
    ];

    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {
        inputError = `Insufficient Balance`;
    }

    const isWrap =
        currencies.INPUT &&
        currencies.OUTPUT &&
        currencies.INPUT.wrapped.equals(currencies.OUTPUT.wrapped);

    const poolAddress = isWrap
        ? undefined
        : currencies[SwapField.INPUT] &&
          currencies[SwapField.OUTPUT] &&
          (computePoolAddress({
              tokenA: currencies[SwapField.INPUT]!.wrapped,
              tokenB: currencies[SwapField.OUTPUT]!.wrapped,
          }).toLowerCase() as Address);

    const { data: globalState } = useAlgebraPoolGlobalState({
        address: poolAddress,
    });

    const { data: tickSpacing } = useAlgebraPoolTickSpacing({
        address: poolAddress,
    });

    return {
        currencies,
        currencyBalances,
        parsedAmount,
        inputError,
        tradeState: trade,
        toggledTrade,
        tickAfterSwap,
        allowedSlippage,
        poolFee: globalState && globalState[2],
        tick: globalState && globalState[1],
        tickSpacing: tickSpacing,
        poolAddress,
    };
}

export function useAggregatorSwapInfo(): {
    currencies: { [field in SwapFieldType]?: Currency };
    currencyBalances: { [field in SwapFieldType]?: CurrencyAmount<Currency> };
    payAmount: CurrencyAmount<Currency> | undefined;
    receiveAmount: CurrencyAmount<Currency> | undefined;
    inputError?: string;
    aggregatorData?: RouterData;
    isDataFetching: boolean;
} {
    const { address: account, isConnected } = useAccount();
    const { slippage: userSlippage } = useUserState();
    const allowedSlippage = useSwapSlippageTolerance(undefined);

    const {
        typedValue,
        [SwapField.INPUT]: { currencyId: inputCurrencyId },
        [SwapField.OUTPUT]: { currencyId: outputCurrencyId },
        actions: { typeInput },
    } = useSwapState();

    const inputCurrency = useCurrency(inputCurrencyId);
    const outputCurrency = useCurrency(outputCurrencyId);

    const payAmount = useMemo(
        () => tryParseAmount(typedValue, inputCurrency),
        [typedValue, inputCurrency],
    );
    const [receiveAmount, setReceiveAmount] = useState<CurrencyAmount<Currency>>();

    const slippage = useMemo(
        () => (userSlippage === "auto" ? allowedSlippage : userSlippage),
        [userSlippage, allowedSlippage],
    );

    const { data: aggregatorData, isFetching: isDataFetching } = useAggregatorData({
        from: isConnected ? account : "0x388558ba4C24BaD0aaBbeADae104153D39D04191",
        src: inputCurrency?.isNative ? zeroAddress : inputCurrency?.wrapped.address,
        dst: outputCurrency?.isNative ? zeroAddress : outputCurrency?.wrapped.address,
        amountIn: payAmount?.quotient.toString(),
        slippage: Number(slippage.toSignificant()),
    });

    useEffect(() => {
        typeInput(SwapField.INPUT, "");
    }, [inputCurrencyId]);

    useEffect(() => {
        if (Number(typedValue) == 0) return setReceiveAmount(undefined);
        const slippageNormal = 1 - Number(slippage.toSignificant()) / 100;
        const amount = formatUnits(
            n2bi(Number(aggregatorData?.toAmount ?? 0) * slippageNormal),
            outputCurrency?.wrapped.decimals ?? 18,
        );
        setReceiveAmount(tryParseAmount(amount, outputCurrency));
    }, [typedValue, aggregatorData, outputCurrency, slippage]);

    const [addressA, addressB] = [
        inputCurrency?.isNative ? undefined : inputCurrency?.address || "",
        outputCurrency?.isNative ? undefined : outputCurrency?.address || "",
    ] as Address[];

    const { data: inputCurrencyBalance } = useBalance({
        address: account,
        token: addressA,
        watch: true,
    });
    const { data: outputCurrencyBalance } = useBalance({
        address: account,
        token: addressB,
        watch: true,
    });

    const currencyBalances = {
        [SwapField.INPUT]:
            inputCurrency &&
            inputCurrencyBalance &&
            CurrencyAmount.fromRawAmount(inputCurrency, inputCurrencyBalance.value.toString()),
        [SwapField.OUTPUT]:
            outputCurrency &&
            outputCurrencyBalance &&
            CurrencyAmount.fromRawAmount(outputCurrency, outputCurrencyBalance.value.toString()),
    };

    const currencies: { [field in SwapFieldType]?: Currency } = {
        [SwapField.INPUT]: inputCurrency ?? undefined,
        [SwapField.OUTPUT]: outputCurrency ?? undefined,
    };

    let inputError: string | undefined;
    if (!account) {
        inputError = `Connect Wallet`;
    }

    if (!payAmount) {
        inputError = inputError ?? `Input Amount`;
    }

    if (!currencies[SwapField.INPUT] || !currencies[SwapField.OUTPUT]) {
        inputError = inputError ?? `Select a token`;
    }

    const [balanceIn, amountIn] = [currencyBalances[SwapField.INPUT], payAmount];

    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {
        inputError = `Insufficient Balance`;
    }

    if (aggregatorData?.tx.from != "0x" && aggregatorData?.toAmount === 0n) {
        inputError = `Insufficient Liquidity`;
    }

    return {
        currencies,
        currencyBalances,
        payAmount,
        receiveAmount,
        inputError,
        aggregatorData,
        isDataFetching,
    };
}



================================================
File: src/state/tokensStore.ts
================================================
import { Address } from "viem";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import deepMerge from 'lodash.merge'

interface ImportedTokens {
    [chainId: number]: { 
        [address: Address]: { id: Address, symbol: string, name: string, decimals: number } 
    }
}

interface TokensState {
    importedTokens: ImportedTokens,
    actions: {
        importToken: (address: Address, symbol: string, name: string, decimals: number, chainId: number) => void;
    }
}

export const useTokensState = create(persist<TokensState>((set, get) => ({
    importedTokens: {},
    actions: {
        importToken: (address, symbol, name, decimals, chainId) => {
            const { importedTokens } = get()

            console.log(importedTokens)
            set({
                importedTokens: {
                    ...importedTokens,
                    [chainId]: {
                        ...importedTokens[chainId],
                        [address]: {
                            id: address,
                            symbol,
                            name,
                            decimals
                        }
                    }
                }
            })
        },
    }
}), { name: 'tokens-storage', storage: createJSONStorage(() => localStorage), merge: (persistedState, currentState) => deepMerge(currentState, persistedState) }))


================================================
File: src/state/userStore.ts
================================================
import deepMerge from 'lodash.merge';
import { Percent } from "@glyph-exchange/integral-sdk";
import { useMemo } from "react";
import { create } from "zustand";
import { persist } from "zustand/middleware";

interface UserState {
    txDeadline: number;
    slippage: Percent | "auto";
    isExpertMode: boolean;
    isMultihop: boolean;
    actions: {
        setTxDeadline: (txDeadline: number) => void;
        setSlippage: (slippage: Percent | "auto") => void;
        setIsExpertMode: (isExpertMode: boolean) => void;
        setIsMultihop: (isMultihop: boolean) => void;
    }
}

export const useUserState = create(persist<UserState>((set) => ({
    txDeadline: 180,
    slippage: "auto",
    isExpertMode: false,
    isMultihop: true,
    importedTokens: {},
    actions: {
        setTxDeadline: (txDeadline) => set({
            txDeadline
        }),
        setSlippage: (slippage) => set({
            slippage
        }),
        setIsExpertMode: (isExpertMode) => set({
            isExpertMode
        }),
        setIsMultihop: (isMultihop) => set({
            isMultihop
        })
    }
}), {
        name: 'user-state-storage',
        merge(persistedState: any, currentState) {
            return deepMerge(
                { ...currentState, slippage: persistedState.slippage === "auto" ? "auto" : new Percent(0) },
                persistedState
                );
        },
    }
))

export function useUserSlippageToleranceWithDefault(defaultSlippageTolerance: Percent): Percent {
    const { slippage } = useUserState();
    return useMemo(() => (slippage === "auto" ? defaultSlippageTolerance : slippage), [slippage, defaultSlippageTolerance]);
}


================================================
File: src/styles/fonts.css
================================================
@font-face {
    font-family: FraktionMono-Bold;
    src: url("/fonts/FraktionMono-Bold.otf") format("trueType");
    font-display: block;
}

@font-face {
    font-family: FraktionMono-BoldItalic;
    src: url("/fonts/FraktionMono-BoldItalic.otf") format("trueType");
    font-display: block;
}

@font-face {
    font-family: FraktionMono-Regular;
    src: url("/fonts/FraktionMono-Regular.otf") format("trueType");
    font-display: block;
}

@font-face {
    font-family: FraktionMono-RegularItalic;
    src: url("/fonts/FraktionMono-RegularItalic.otf") format("trueType");
    font-display: block;
}

@font-face {
    font-family: Geneva;
    src: url("/fonts/Geneva.ttf") format("trueType");
    font-display: block;
}

@font-face {
    font-family: Geneva-Regular;
    src: url("/fonts/Geneva.ttf") format("trueType");
    font-display: block;
}



================================================
File: src/styles/index.scss
================================================
@import "fonts.css";
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
    :root {
        --header-height: 60px;
        --footer-height: 76px;

        --background: #0b0f17;
        --foreground: white;

        --card: 0 0% 100%;
        --card-foreground: 222.2 84% 4.9%;

        --popover: 0 0% 100%;
        --popover-foreground: 222.2 84% 4.9%;

        --primary: 222.2 47.4% 11.2%;
        --primary-foreground: 210 40% 98%;

        --secondary: 210 40% 96.1%;
        --secondary-foreground: 222.2 47.4% 11.2%;

        --muted: 210 40% 96.1%;
        --muted-foreground: 215.4 16.3% 46.9%;

        --accent: 210 40% 96.1%;
        --accent-foreground: 222.2 47.4% 11.2%;

        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 210 40% 98%;

        --border: 214.3 31.8% 91.4%;
        --input: 214.3 31.8% 91.4%;
        --ring: 222.2 84% 4.9%;

        --radius: 0.5rem;

        @media (max-width: 431px) {
            --header-height: 56px;
            --footer-height: 76px;
        }
    }

    .dark {
        --background: 222.2 84% 4.9%;
        --foreground: 210 40% 98%;

        --card: 222.2 84% 4.9%;
        --card-foreground: 210 40% 98%;

        --popover: 222.2 84% 4.9%;
        --popover-foreground: 210 40% 98%;

        --primary: 210 40% 98%;
        --primary-foreground: 222.2 47.4% 11.2%;

        --secondary: 217.2 32.6% 17.5%;
        --secondary-foreground: 210 40% 98%;

        --muted: 217.2 32.6% 17.5%;
        --muted-foreground: 215 20.2% 65.1%;

        --accent: 217.2 32.6% 17.5%;
        --accent-foreground: 210 40% 98%;

        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 210 40% 98%;

        --border: 217.2 32.6% 17.5%;
        --input: 217.2 32.6% 17.5%;
        --ring: 212.7 26.8% 83.9%;
    }
}

@layer base {
    * {
        @apply border-border;
    }
    body {
        @apply bg-background text-foreground;
    }
}

ul {
    &::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }
    &::-webkit-scrollbar-track {
        border-radius: 10px;
        background:
            url("/bg-fragment.png"),
            #fff 0% 0% / 69.9999988079071px 69.9999988079071px repeat;
    }
    &::-webkit-scrollbar-thumb {
        background: #fff;
        border-radius: 10px;
    }
}

html,
body,
div {
    &::-webkit-scrollbar {
        width: 28px;
        height: 28px;
        transition: 5s ease;
    }

    &::-webkit-scrollbar-thumb {
        border: 2px solid #000;
        background: #fff;
    }

    &::-webkit-scrollbar-track {
        border: 1px solid #000;
        background:
            url("/bg-fragment.png"),
            #fff 0% 0% / 69.9999988079071px 69.9999988079071px repeat;
    }

    &::-webkit-scrollbar-button {
        width: 28px;
        height: 28px;

        &:single-button:vertical:decrement {
            background: url("/scroll-vertical-decrement.svg") #fff no-repeat;
            border-bottom: 1px solid #000;
        }

        &:single-button:vertical:increment {
            background: url("/scroll-vertical-increment.svg") #fff no-repeat;
            border-top: 1px solid #000;
        }

        &:single-button:horizontal:decrement {
            background: url("/scroll-horizontal-decrement.svg") #fff no-repeat;
            border-right: 1px solid #000;
        }

        &:single-button:horizontal:increment {
            background: url("/scroll-horizontal-increment.svg") #fff no-repeat;
            border-left: 1px solid #000;
        }
    }

    &::-webkit-scrollbar-thumb:hover {
    }

    &::-webkit-scrollbar-corner {
        background: #fff;
    }

    @media (max-width: 431px) {
        overscroll-behavior: none;

        &::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }

        &::-webkit-scrollbar-button {
            width: 16px;
            height: 16px;

            &:single-button:vertical:decrement {
                background-image: url("/scroll-vertical-decrement-mobile.svg");
            }

            &:single-button:vertical:increment {
                background-image: url("/scroll-vertical-increment-mobile.svg");
            }

            &:single-button:horizontal:decrement {
                background: url("/scroll-horizontal-decrement-mobile.svg") #fff no-repeat;
            }

            &:single-button:horizontal:increment {
                background: url("/scroll-horizontal-increment-mobile.svg") #fff no-repeat;
            }
        }
    }
}

#root {
    min-width: 360px;
    max-width: 1154px;
    margin: 0 auto;
    text-align: center;
    padding: var(--header-height) 20px;
    -webkit-tap-highlight-color: transparent;

    @media (max-width: 768px) {
        padding-bottom: calc(var(--footer-height) + 20px);
    }
}

html,
body {
    color: var(--foreground);
    background-color: lightgray;
    background:
        url("/bg-fragment.png"),
        lightgray 0% 0% / 69.9999988079071px 69.9999988079071px repeat;

    height: 100%;
    font-family: FraktionMono-Regular;
}

.card {
    padding: 2em;
}



================================================
File: src/styles/index.tsx
================================================
import { createGlobalStyle } from "styled-components";
import tw, { GlobalStyles as BaseStyles } from "twin.macro";

const CustomStyles = createGlobalStyle`
  body {
    ${() => tw`antialiased`}
  }
`;

const GlobalStyles = () => (
    <>
        <BaseStyles />
        <CustomStyles />
    </>
);

export default GlobalStyles;



================================================
File: src/types/approve-state.ts
================================================
export const ApprovalState = {
    UNKNOWN: 'UNKNOWN',
    NOT_APPROVED: 'NOT_APPROVED',
    PENDING: 'PENDING',
    APPROVED: 'APPROVED',
}

export type ApprovalStateType = typeof ApprovalState[keyof typeof ApprovalState]


================================================
File: src/types/common.ts
================================================
export enum Environment {
    DEV = "DEV",
    PROD = "PROD",
}



================================================
File: src/types/farming-info.ts
================================================
import {
    EternalFarming,
    SinglePoolQuery,
    TokenFieldsFragment,
} from '@/graphql/generated/graphql';

export interface Farming {
    farming: EternalFarming;
    rewardToken: TokenFieldsFragment;
    bonusRewardToken: TokenFieldsFragment | null;
    pool: SinglePoolQuery['pool'];
}



================================================
File: src/types/formatted-position.ts
================================================
import { Address } from "viem";
import { GammaUserPositionInfo, HypervisorInfo } from "./gamma-state";
import { Position } from "@glyph-exchange/integral-sdk";
export interface FormattedPosition {
    id: number;
    isClosed: boolean;
    outOfRange: boolean;
    range: string;
    liquidityUSD: number;
    feesUSD: number;
    apr: number;
    inFarming: boolean;
    inGamma?: boolean;
    hypervisor?: HypervisorInfo;
    userPositionData?: GammaUserPositionInfo;
    gammaPoolId?: Address;
    associatePoolId?: Address;
    positionEntity?: Position;
}



================================================
File: src/types/gamma-state.ts
================================================
import { Address } from "viem";

export type HypervisorReturns = {
    feeApr: number;
    feeApy: number;
};

export type HypervisorInfo = {
    address: string;
    createDate: string;
    poolAddress: string;
    name: string;
    token0: string;
    token1: string;
    decimals0: number;
    decimals1: number;
    depositCap0: number;
    depositCap1: number;
    grossFeesClaimed0: number;
    grossFeesClaimed1: number;
    grossFeesClaimedUSD: string;
    feesReinvested0: number;
    feesReinvested1: number;
    feesReinvestedUSD: string;
    tvl0: number;
    tvl1: number;
    tvlUSD: string;
    totalSupply: number;
    maxTotalSupply: number;
    capacityUsed: string;
    sqrtPrice: string;
    tick: number;
    baseLower: number;
    baseUpper: number;
    inRange: false;
    observationIndex: string;
    poolTvlUSD: string;
    poolFeesUSD: string;
    returns: {
        daily: HypervisorReturns;
        weekly: HypervisorReturns;
        monthly: HypervisorReturns;
        allTime: HypervisorReturns;
        status: string;
    };
};

export type HypervisorsData = {
    [address: string]: HypervisorInfo;
};

export type GammaUserPositionInfo = {
    shares: number;
    shareOfSupply: number;
    balance0: number;
    balance1: number;
    balanceUSD: number;
    returns: {
        initialTokenUSD: number;
        initialTokenCurrentUSD: number;
        currentUSD: number;
        netMarketReturnsUSD: number;
        netMarketReturnsPercentage: string;
        hypervisorReturnsUSD: number;
        hypervisorReturnsPercentage: string;
    };
};

export type GammaUserInfo = {
    owner: string;
    gammaStaked: number;
    gammaStakedUSD: number;
    gammaDeposited: number;
    pendingGammaEarned: number;
    pendingGammaEarnedUSD: number;
    totalGammaEarned: number;
    totalGammaEarnedUSD: number;
    gammaStakedShare: number;
    xgammaAmount: number;
    [hypervisor: Address]: GammaUserPositionInfo;
};

export type GammaUserDatas = {
    [address: string]: GammaUserInfo;
};

export const WrapState = {
    UNKNOWN: "UNKNOWN",
    NOT_WRAPPED: "NOT_WRAPPED",
    PENDING: "PENDING",
    WRAPPED: "WRAPPED",
};

export type WrapStateType = (typeof WrapState)[keyof typeof WrapState];



================================================
File: src/types/manage-liquidity.ts
================================================
export enum ManageLiquidity {
    ADD = 'add',
    INCREASE = 'increase',
}



================================================
File: src/types/page-selector.ts
================================================
export const SwapPageSelector = {
    AGGREGATOR: "aggregator",
    V4AMM: "V4 AMM",
};

export type SwapPageSelectorType = (typeof SwapPageSelector)[keyof typeof SwapPageSelector];



================================================
File: src/types/pool-table-state.ts
================================================
export const PoolTableType = {
    ALL: "All",
    MYPOOLS: "My pools",
} as const;



================================================
File: src/types/position-filter-status.ts
================================================
export enum PositionsStatus {
    OPEN = "Open",
    ON_FARMING = "OnFarming",
    CLOSED = "Closed",
    ON_GAMMA = "OnGamma",
}



================================================
File: src/types/position-state.ts
================================================
export enum PositionManager {
    ALGEBRA = "ALGEBRA",
    GAMMA = "GAMMA",
}



================================================
File: src/types/presets.ts
================================================
export const Presets = {
    SAFE: 'SAFE',
    RISK: 'RISK',
    NORMAL: 'NORMAL',
    FULL: 'FULL',
    STABLE: 'STABLE',
}

export type PresetsType = typeof Presets[keyof typeof Presets]

export interface PresetsArgs {
    type: PresetsType;
    min: number;
    max: number;
}

export const PresetProfits = {
    VERY_LOW: 'VERY_LOW',
    LOW: 'LOW',
    MEDIUM: 'MEDIUM',
    HIGH: 'HIGH',
}

export type PresetProfitsType = typeof PresetProfits[keyof typeof PresetProfits]


================================================
File: src/types/swap-chart.ts
================================================
export const SwapChartView = {
    CANDLES: 'CANDLES',
    LINE: 'LINE',
} as const

export type SwapChartViewType = typeof SwapChartView[keyof typeof SwapChartView]

export const SwapChartPair = {
    AB: 'AB',
    BA: 'BA',
    A: 'A',
    B: 'B',
} as const

export type SwapChartPairType = typeof SwapChartPair[keyof typeof SwapChartPair]

export const SwapChartSpan: { WEEK: 'week', DAY: 'day', MONTH: 'month' } = {
    WEEK: "week",
    DAY: "day",
    MONTH: 'month',
} as const

export type SwapChartSpanType = typeof SwapChartSpan[keyof typeof SwapChartSpan]


================================================
File: src/types/swap-field.ts
================================================

export const SwapField = {
    INPUT: 'INPUT',
    OUTPUT: 'OUTPUT',
} as const

export type SwapFieldType = typeof SwapField[keyof typeof SwapField]


================================================
File: src/types/swap-quote.ts
================================================
export interface QuoteResult {
    0: bigint;
    1: bigint;
    2: bigint[];
    3: number[];
    4: bigint;
    5: number[];
}



================================================
File: src/types/swap-state.ts
================================================

export const SwapCallbackState = {
    INVALID: 'INVALID',
    LOADING: 'LOADING',
    VALID: 'VALID',
}

export type SwapCallbackStateType = typeof SwapCallbackState[keyof typeof SwapCallbackState]



================================================
File: src/types/trade-state.ts
================================================
export const TradeState = {
    LOADING: 'LOADING',
    INVALID: 'INVALID',
    NO_ROUTE_FOUND: 'NO_ROUTE_FOUND',
    VALID: 'VALID',
    SYNCING: 'SYNCING',
}

export type TradeStateType = typeof TradeState[keyof typeof TradeState]


================================================
File: src/utils/index.ts
================================================
export const n2bi = (n?: number | string): bigint => {
    if (!n) return 0n;
    return BigInt(n.toLocaleString().replace(/[,]/g, "").split(".")?.[0] ?? 0);
};



================================================
File: src/utils/common/formatAmount.ts
================================================
import { formatCurrency } from "./formatCurrency";

export function formatAmount(amount: string, decimals = 3): string {
    const amountNum = Number(amount);
    const minAmount = 1 / 10 ** (decimals || 3);

    if (amountNum === 0) return "0";
    if (amountNum < minAmount) return `< ${minAmount}`;
    if (amountNum < 1) return (Math.floor(amountNum / minAmount) * minAmount).toFixed(decimals);
    if (amountNum < 100) return (Math.floor(amountNum * 100) / 100).toString();
    if (amountNum < 10000) return Math.floor(amountNum).toString();

    if (amountNum < 1000000000000000) return formatCurrency.format(Math.floor(amountNum * 100) / 100);

    return "∞";
}

export function reverseFormatAmount(formattedNumber: string): number {
    const suffixes: { [key: string]: number } = {
        K: 1e3,
        M: 1e6,
        B: 1e9,
        T: 1e12,
    };

    const suffix = formattedNumber.slice(-1);
    const value = parseFloat(formattedNumber.slice(0, -1));

    if (formattedNumber.startsWith("< ") || formattedNumber.startsWith("> ")) {
        const value = parseFloat(formattedNumber.slice(2));
        return value > 0 ? value : 0;
    }

    if (suffixes[suffix]) {
        return value * suffixes[suffix];
    } else {
        return parseFloat(formattedNumber);
    }
}



================================================
File: src/utils/common/formatBalance.ts
================================================
import { formatCurrency } from './formatCurrency';

export function formatBalance(formattedBalance: string) {
    const balanceNum = Number(formattedBalance);

    if (formattedBalance === '0') return '0';

    if (balanceNum < 0.001) return '<0.001';

    const formattedBalanceNum = Math.floor(balanceNum * 1000) / 1000;

    return formatCurrency.format(formattedBalanceNum);
}



================================================
File: src/utils/common/formatCurrency.ts
================================================
export const formatCurrency = new Intl.NumberFormat('en-us', {
    notation: 'compact',
    maximumFractionDigits: 3
});



================================================
File: src/utils/common/formatPercent.ts
================================================
export const formatPercent = new Intl.NumberFormat('en-us', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
})



================================================
File: src/utils/common/formatPlural.ts
================================================
export function formatPlural(amount: number, single: string, plural: string) {
    return amount === 1 ? single : plural
}


================================================
File: src/utils/common/formatUSD.ts
================================================
export const formatUSD = new Intl.NumberFormat('en-us', {
    currency: 'USD',
    style: "currency",
    notation: 'compact',
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
})



================================================
File: src/utils/common/truncateHash.ts
================================================
import { Address } from "wagmi";

export function truncateHash(address: Address, startLength = 4, endLength = 4) {
    if (!address) return '';

    return `${address.substring(0, startLength)}...${address.substring(address.length - endLength)}`;
};


================================================
File: src/utils/farming/getFarmingRewards.ts
================================================
import { getFarmingCenter } from '@/generated';
import { Address } from 'viem';

export async function getFarmingRewards({
    rewardToken,
    bonusRewardToken,
    pool,
    nonce,
    tokenId,
}: {
    rewardToken: Address;
    bonusRewardToken: Address;
    pool: Address;
    nonce: bigint;
    tokenId: bigint;
}): Promise<{ reward: bigint; bonusReward: bigint }> {
    try {
        const farmingCenter = getFarmingCenter({});
        const {
            result: [reward, bonusReward],
        } = await farmingCenter.simulate.collectRewards([
            {
                rewardToken,
                bonusRewardToken,
                pool,
                nonce,
            },
            tokenId,
        ]);
        return {
            reward,
            bonusReward,
        };
    } catch (e) {
        console.error(e);
        return {
            reward: 0n,
            bonusReward: 0n,
        };
    }
}



================================================
File: src/utils/farming/getRewardsCalldata.ts
================================================
import { farmingCenterABI } from "@/generated";
import { MaxUint128 } from "@glyph-exchange/integral-sdk";
import { Address, encodeFunctionData } from "viem";
import { isSameRewards } from "./isSameRewards";

export function getRewardsCalldata({
    rewardToken,
    bonusRewardToken,
    pool,
    nonce,
    tokenId,
    account,
}: {
    rewardToken: Address;
    bonusRewardToken: Address;
    pool: Address;
    nonce: bigint;
    tokenId: bigint;
    account: Address;
}): Address[] {
    const collectRewardsCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "collectRewards",
        args: [
            {
                rewardToken,
                bonusRewardToken,
                pool,
                nonce,
            },
            tokenId,
        ],
    });

    const rewardClaimCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "claimReward",
        args: [rewardToken, account, BigInt(MaxUint128)],
    });

    const bonusRewardClaimCalldata = encodeFunctionData({
        abi: farmingCenterABI,
        functionName: "claimReward",
        args: [bonusRewardToken, account, BigInt(MaxUint128)],
    });

    let calldata;
    const isSameReward = isSameRewards(rewardToken, bonusRewardToken);

    if (!isSameReward) {
        calldata = [collectRewardsCalldata, rewardClaimCalldata, bonusRewardClaimCalldata];
    } else {
        calldata = [collectRewardsCalldata, rewardClaimCalldata];
    }
    return calldata;
}



================================================
File: src/utils/farming/isSameRewards.ts
================================================
import { ADDRESS_ZERO } from '@glyph-exchange/integral-sdk';
import { Address } from 'viem';

export const isSameRewards = (
    rewardToken: Address,
    bonusRewardToken: Address
): boolean => {
    return (
        rewardToken.toLowerCase() === bonusRewardToken.toLowerCase() ||
        bonusRewardToken === ADDRESS_ZERO
    );
};



================================================
File: src/utils/pool/getPoolAPR.ts
================================================
import { POOL_AVG_APR_API } from "@/constants/api";
import { Address } from "wagmi";

export async function getPoolAPR(poolId: Address) {
    if (!poolId) return;

    const poolsAPR = await fetch(POOL_AVG_APR_API).then((v) => v.json());

    if (poolsAPR[poolId.toLowerCase()]) {
        return poolsAPR[poolId.toLowerCase()];
    }

    return 0;
}



================================================
File: src/utils/positions/getPositionAPR.ts
================================================
import { getAlgebraPool } from "@/generated"
import { Position } from "@glyph-exchange/integral-sdk"
import { PoolFeeDataFieldsFragment, PoolFieldsFragment } from "@/graphql/generated/graphql"
import { Address } from "wagmi"

export async function getPositionAPR(
    poolId: Address, 
    position: Position, 
    pool: PoolFieldsFragment | undefined | null, 
    poolFeeData: PoolFeeDataFieldsFragment[] | undefined, 
    nativePrice: string | undefined 
) {

    if (!pool || !poolFeeData || !nativePrice) return

    const algebraPool = getAlgebraPool({
        address: poolId
    })

    try {

        const liquidity = await algebraPool.read.liquidity()

        // Today fees
        const poolDayFees = poolFeeData && Boolean(poolFeeData.length) && Number(poolFeeData[0].feesUSD)

        // Avg fees
        // const poolDayFees = poolFeeData && Boolean(poolFeeData.length) && poolFeeData.reduce((acc, v) => acc + Number(v.feesUSD), 0) / poolFeeData.length

        const yearFee = poolDayFees && poolDayFees * 365

        const liquidityRelation = position && liquidity && Number(position.liquidity.toString()) / Number(liquidity)

        const [amount0, amount1] = position ? [position.amount0.toSignificant(), position.amount1.toSignificant()] : [0, 0]

        const tvl = pool && (Number(pool.token0.derivedMatic) * Number(nativePrice) * Number(amount0) + Number(pool.token1.derivedMatic) * Number(nativePrice) * Number(amount1))

        return liquidityRelation && yearFee && tvl && ((yearFee * liquidityRelation) / tvl) * 100

    } catch {
        return 0
    }


}


================================================
File: src/utils/positions/getPositionFees.ts
================================================
import { MAX_UINT128 } from "@/constants/max-uint128";
import { getAlgebraPositionManager } from "@/generated";
import { CurrencyAmount, Pool, unwrappedToken } from "@glyph-exchange/integral-sdk";

export async function getPositionFees(pool: Pool, positionId: number) {

    try {

        const algebraPositionManager = getAlgebraPositionManager({})

        const owner = await algebraPositionManager.read.ownerOf([BigInt(positionId)])

        const { result: [fees0, fees1] } = await algebraPositionManager.simulate.collect([
            {
                tokenId: BigInt(positionId),
                recipient: owner,
                amount0Max: MAX_UINT128,
                amount1Max: MAX_UINT128
            },
        ], {
            account: owner
        })

        return [
            CurrencyAmount.fromRawAmount(unwrappedToken(pool.token0), fees0.toString()),
            CurrencyAmount.fromRawAmount(unwrappedToken(pool.token1), fees1.toString())
        ]

    } catch {
        return [undefined, undefined]
    }

}


================================================
File: src/utils/swap/computePriceImpact.ts
================================================
import { CurrencyAmount, Percent, Token } from "@glyph-exchange/integral-sdk"

export const ONE_HUNDRED_PERCENT = new Percent('1')

export function computeFiatValuePriceImpact(
    fiatValueInput: CurrencyAmount<Token> | undefined | null,
    fiatValueOutput: CurrencyAmount<Token> | undefined | null
): Percent | undefined {
    if (!fiatValueOutput || !fiatValueInput) return undefined

    if (!fiatValueInput.currency.equals(fiatValueOutput.currency)) return undefined

    if (BigInt(fiatValueInput.quotient.toString()) === 0n) return undefined

    const pct = ONE_HUNDRED_PERCENT.subtract(fiatValueOutput.divide(fiatValueInput))

    return new Percent(pct.numerator, pct.denominator)
}



================================================
File: src/utils/swap/prices.ts
================================================
import { Currency, CurrencyAmount, Fraction, Percent, Trade, TradeType } from "@glyph-exchange/integral-sdk"
import JSBI from "jsbi"

export const ONE_BIPS = new Percent(JSBI.BigInt(1), JSBI.BigInt(10000))
export const BIPS_BASE = JSBI.BigInt(10000)
const ONE_HUNDRED_PERCENT = new Percent(JSBI.BigInt(10000), JSBI.BigInt(10000))

export const ALLOWED_PRICE_IMPACT_LOW: Percent = new Percent(JSBI.BigInt(100), BIPS_BASE) // 1%
export const ALLOWED_PRICE_IMPACT_MEDIUM: Percent = new Percent(JSBI.BigInt(300), BIPS_BASE) // 3%
export const ALLOWED_PRICE_IMPACT_HIGH: Percent = new Percent(JSBI.BigInt(500), BIPS_BASE) // 5%
export const PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN: Percent = new Percent(JSBI.BigInt(1000), BIPS_BASE) // 10%
export const BLOCKED_PRICE_IMPACT_NON_EXPERT: Percent = new Percent(JSBI.BigInt(1500), BIPS_BASE) // 15%


export function computeRealizedLPFeePercent(
    trade: Trade<Currency, Currency, TradeType>
): Percent {

    const percent = ONE_HUNDRED_PERCENT.subtract(
        trade.route.pools.reduce<Percent>(
            (currentFee: Percent, pool): Percent =>
                currentFee.multiply(ONE_HUNDRED_PERCENT.subtract(new Fraction(pool.fee, 1_000_000))),
            ONE_HUNDRED_PERCENT
        )
    )

    return new Percent(percent.numerator, percent.denominator)
}

export function computeRealizedLPFeeAmount(
    trade?: Trade<Currency, Currency, TradeType> | null
): CurrencyAmount<Currency> | undefined {
    if (trade) {
        const realizedLPFee = computeRealizedLPFeePercent(trade)

        return CurrencyAmount.fromRawAmount(trade.inputAmount.currency, trade.inputAmount.multiply(realizedLPFee).quotient)
    }

    return undefined
}

const IMPACT_TIERS = [
    BLOCKED_PRICE_IMPACT_NON_EXPERT,
    ALLOWED_PRICE_IMPACT_HIGH,
    ALLOWED_PRICE_IMPACT_MEDIUM,
    ALLOWED_PRICE_IMPACT_LOW
]

type WarningSeverity = 0 | 1 | 2 | 3 | 4

export function warningSeverity(priceImpact: Percent | undefined): WarningSeverity {
    if (!priceImpact) return 4
    let impact: WarningSeverity = IMPACT_TIERS.length as WarningSeverity
    for (const impactLevel of IMPACT_TIERS) {
        if (impactLevel.lessThan(priceImpact)) return impact
        impact--
    }
    return 0
}



================================================
File: .husky/commit-msg
================================================
yarn commitlint --edit 



================================================
File: .husky/pre-commit
================================================
yarn lint-staged



================================================
File: .husky/_/applypatch-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/commit-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/h
================================================
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c



================================================
File: .husky/_/husky.sh
================================================
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"


================================================
File: .husky/_/post-applypatch
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-checkout
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-merge
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-rewrite
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-applypatch
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-auto-gc
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-merge-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-push
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-rebase
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/prepare-commit-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/.gitignore
================================================
*

